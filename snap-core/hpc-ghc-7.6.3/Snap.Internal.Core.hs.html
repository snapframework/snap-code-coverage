<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE BangPatterns               #-}
<span class="lineno">    2 </span>{-# LANGUAGE CPP                        #-}
<span class="lineno">    3 </span>{-# LANGUAGE DeriveDataTypeable         #-}
<span class="lineno">    4 </span>{-# LANGUAGE ExistentialQuantification  #-}
<span class="lineno">    5 </span>{-# LANGUAGE FlexibleContexts           #-}
<span class="lineno">    6 </span>{-# LANGUAGE FlexibleInstances          #-}
<span class="lineno">    7 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    8 </span>{-# LANGUAGE MultiParamTypeClasses      #-}
<span class="lineno">    9 </span>{-# LANGUAGE OverloadedStrings          #-}
<span class="lineno">   10 </span>{-# LANGUAGE Rank2Types                 #-}
<span class="lineno">   11 </span>{-# LANGUAGE ScopedTypeVariables        #-}
<span class="lineno">   12 </span>{-# LANGUAGE TypeFamilies               #-}
<span class="lineno">   13 </span>{-# LANGUAGE TypeSynonymInstances       #-}
<span class="lineno">   14 </span>#if __GLASGOW_HASKELL__ &gt;= 708
<span class="lineno">   15 </span>{-# LANGUAGE StandaloneDeriving         #-}
<span class="lineno">   16 </span>#endif
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>module Snap.Internal.Core
<span class="lineno">   19 </span>  ( MonadSnap(..)
<span class="lineno">   20 </span>  , SnapResult(..)
<span class="lineno">   21 </span>  , EscapeHttpHandler
<span class="lineno">   22 </span>  , EscapeSnap(..)
<span class="lineno">   23 </span>  , Zero(..)
<span class="lineno">   24 </span>  , Snap(..)
<span class="lineno">   25 </span>  , SnapState(..)
<span class="lineno">   26 </span>  , runRequestBody
<span class="lineno">   27 </span>  , readRequestBody
<span class="lineno">   28 </span>  , transformRequestBody
<span class="lineno">   29 </span>  , finishWith
<span class="lineno">   30 </span>  , catchFinishWith
<span class="lineno">   31 </span>  , pass
<span class="lineno">   32 </span>  , method
<span class="lineno">   33 </span>  , methods
<span class="lineno">   34 </span>  , updateContextPath
<span class="lineno">   35 </span>  , pathWith
<span class="lineno">   36 </span>  , dir
<span class="lineno">   37 </span>  , path
<span class="lineno">   38 </span>  , pathArg
<span class="lineno">   39 </span>  , ifTop
<span class="lineno">   40 </span>  , sget
<span class="lineno">   41 </span>  , smodify
<span class="lineno">   42 </span>  , getRequest
<span class="lineno">   43 </span>  , getResponse
<span class="lineno">   44 </span>  , getsRequest
<span class="lineno">   45 </span>  , getsResponse
<span class="lineno">   46 </span>  , putRequest
<span class="lineno">   47 </span>  , putResponse
<span class="lineno">   48 </span>  , modifyRequest
<span class="lineno">   49 </span>  , modifyResponse
<span class="lineno">   50 </span>  , redirect
<span class="lineno">   51 </span>  , redirect'
<span class="lineno">   52 </span>  , logError
<span class="lineno">   53 </span>  , addToOutput
<span class="lineno">   54 </span>  , writeBuilder
<span class="lineno">   55 </span>  , writeBS
<span class="lineno">   56 </span>  , writeLBS
<span class="lineno">   57 </span>  , writeText
<span class="lineno">   58 </span>  , writeLazyText
<span class="lineno">   59 </span>  , sendFile
<span class="lineno">   60 </span>  , sendFilePartial
<span class="lineno">   61 </span>  , localRequest
<span class="lineno">   62 </span>  , withRequest
<span class="lineno">   63 </span>  , withResponse
<span class="lineno">   64 </span>  , ipHeaderFilter
<span class="lineno">   65 </span>  , ipHeaderFilter'
<span class="lineno">   66 </span>  , bracketSnap
<span class="lineno">   67 </span>  , NoHandlerException(..)
<span class="lineno">   68 </span>  , terminateConnection
<span class="lineno">   69 </span>  , escapeHttp
<span class="lineno">   70 </span>  , runSnap
<span class="lineno">   71 </span>  , fixupResponse
<span class="lineno">   72 </span>  , evalSnap
<span class="lineno">   73 </span>  , getParamFrom
<span class="lineno">   74 </span>  , getParam
<span class="lineno">   75 </span>  , getPostParam
<span class="lineno">   76 </span>  , getQueryParam
<span class="lineno">   77 </span>  , getParams
<span class="lineno">   78 </span>  , getPostParams
<span class="lineno">   79 </span>  , getQueryParams
<span class="lineno">   80 </span>  , getCookie
<span class="lineno">   81 </span>  , readCookie
<span class="lineno">   82 </span>  , expireCookie
<span class="lineno">   83 </span>  , setTimeout
<span class="lineno">   84 </span>  , extendTimeout
<span class="lineno">   85 </span>  , modifyTimeout
<span class="lineno">   86 </span>  , getTimeoutModifier
<span class="lineno">   87 </span>  , module Snap.Internal.Http.Types
<span class="lineno">   88 </span>  ) where
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>------------------------------------------------------------------------------
<span class="lineno">   91 </span>import           Control.Applicative                (Alternative ((&lt;|&gt;), empty), Applicative ((&lt;*&gt;), pure), (&lt;$&gt;))
<span class="lineno">   92 </span>import           Control.Exception.Lifted           (ErrorCall (..), Exception, Handler (..), SomeException (..), catch, catches, mask, onException, throwIO)
<span class="lineno">   93 </span>import           Control.Monad                      (Functor (..), Monad (..), MonadPlus (..), ap, liftM, unless, (=&lt;&lt;))
<span class="lineno">   94 </span>import           Control.Monad.Base                 (MonadBase (..))
<span class="lineno">   95 </span>import           Control.Monad.IO.Class             (MonadIO (..))
<span class="lineno">   96 </span>import           Control.Monad.Trans.Control        (MonadBaseControl (..))
<span class="lineno">   97 </span>import           Control.Monad.Trans.State          (StateT (..))
<span class="lineno">   98 </span>import           Data.ByteString.Builder            (Builder, byteString, lazyByteString)
<span class="lineno">   99 </span>import           Data.ByteString.Char8              (ByteString)
<span class="lineno">  100 </span>import qualified Data.ByteString.Char8              as S (break, concat, drop, dropWhile, intercalate, length, take, takeWhile)
<span class="lineno">  101 </span>import qualified Data.ByteString.Internal           as S (create)
<span class="lineno">  102 </span>import qualified Data.ByteString.Lazy.Char8         as L (ByteString, fromChunks)
<span class="lineno">  103 </span>import           Data.CaseInsensitive               (CI)
<span class="lineno">  104 </span>import           Data.Maybe                         (Maybe (..), listToMaybe, maybe)
<span class="lineno">  105 </span>import qualified Data.Text                          as T (Text)
<span class="lineno">  106 </span>import qualified Data.Text.Encoding as T (encodeUtf8)
<span class="lineno">  107 </span>import qualified Data.Text.Lazy.Encoding as LT (encodeUtf8)
<span class="lineno">  108 </span>import qualified Data.Text.Lazy                     as LT (Text)
<span class="lineno">  109 </span>import           Data.Time                          (Day (ModifiedJulianDay), UTCTime (UTCTime))
<span class="lineno">  110 </span>#if __GLASGOW_HASKELL__ &lt; 708
<span class="lineno">  111 </span>import           Data.Typeable                      (TyCon, Typeable, Typeable1 (..), mkTyCon3, mkTyConApp)
<span class="lineno">  112 </span>#else
<span class="lineno">  113 </span>import           Data.Typeable                      (Typeable)
<span class="lineno">  114 </span>#endif
<span class="lineno">  115 </span>import           Data.Word                          (Word64, Word8)
<span class="lineno">  116 </span>import           Foreign.Ptr                        (Ptr, plusPtr)
<span class="lineno">  117 </span>import           Foreign.Storable                   (poke)
<span class="lineno">  118 </span>import           Prelude                            (Bool (..), Either (..), Eq (..), FilePath, IO, Int, Num (..), Ord (..), Show (..), String, const, divMod, elem, filter, fromIntegral, id, map, max, otherwise, quot, ($), ($!), (++), (.), (||))
<span class="lineno">  119 </span>import           System.IO.Streams                  (InputStream, OutputStream)
<span class="lineno">  120 </span>import qualified System.IO.Streams                  as Streams
<span class="lineno">  121 </span>import           System.Posix.Types                 (FileOffset)
<span class="lineno">  122 </span>import           System.PosixCompat.Files           (fileSize, getFileStatus)
<span class="lineno">  123 </span>#if !MIN_VERSION_bytestring(0,10,6)
<span class="lineno">  124 </span>import qualified Data.ByteString.Internal           as S (inlinePerformIO)
<span class="lineno">  125 </span>#else
<span class="lineno">  126 </span>import qualified Data.ByteString.Internal           as S (accursedUnutterablePerformIO)
<span class="lineno">  127 </span>#endif
<span class="lineno">  128 </span>------------------------------------------------------------------------------
<span class="lineno">  129 </span>import qualified Data.Readable                      as R
<span class="lineno">  130 </span>import           Snap.Internal.Http.Types           (Cookie (..), HasHeaders (..), HttpVersion, Method (..), Params, Request (..), Response (..), ResponseBody (..), StreamProc, addHeader, addResponseCookie, clearContentLength, deleteHeader, deleteResponseCookie, emptyResponse, formatHttpTime, formatLogTime, getHeader, getResponseCookie, getResponseCookies, listHeaders, modifyResponseBody, modifyResponseCookie, normalizeMethod, parseHttpTime, rqModifyParams, rqParam, rqPostParam, rqQueryParam, rqSetParam, rspBodyMap, rspBodyToEnum, setContentLength, setContentType, setHeader, setResponseBody, setResponseCode, setResponseStatus, statusReasonMap)
<span class="lineno">  131 </span>import           Snap.Internal.Parsing              (urlDecode)
<span class="lineno">  132 </span>import qualified Snap.Types.Headers                 as H
<span class="lineno">  133 </span>------------------------------------------------------------------------------
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>------------------------------------------------------------------------------
<span class="lineno">  137 </span>-- | 'MonadSnap' is a type class, analogous to 'MonadIO' for 'IO', that makes it
<span class="lineno">  138 </span>-- easy to wrap 'Snap' inside monad transformers.
<span class="lineno">  139 </span>class (Monad m, MonadIO m, MonadBaseControl IO m, MonadPlus m, Functor m,
<span class="lineno">  140 </span>       Applicative m, Alternative m) =&gt; MonadSnap m where
<span class="lineno">  141 </span>  -- | Lift a computation from the 'Snap' monad.
<span class="lineno">  142 </span>  liftSnap :: Snap a -&gt; m a
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>------------------------------------------------------------------------------
<span class="lineno">  146 </span>data SnapResult a = SnapValue a
<span class="lineno">  147 </span>                  | Zero Zero
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>------------------------------------------------------------------------------
<span class="lineno">  151 </span>-- | Type of external handler passed to 'escapeHttp'.
<span class="lineno">  152 </span>type EscapeHttpHandler =  ((Int -&gt; Int) -&gt; IO ())    -- ^ timeout modifier
<span class="lineno">  153 </span>                       -&gt; InputStream ByteString     -- ^ socket read end
<span class="lineno">  154 </span>                       -&gt; OutputStream Builder       -- ^ socket write end
<span class="lineno">  155 </span>                       -&gt; IO ()
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>------------------------------------------------------------------------------
<span class="lineno">  159 </span>-- | Used internally to implement 'escapeHttp'.
<span class="lineno">  160 </span>data EscapeSnap = TerminateConnection SomeException
<span class="lineno">  161 </span>                | EscapeHttp EscapeHttpHandler
<span class="lineno">  162 </span>  deriving (<span class="decl"><span class="istickedoff">Typeable</span></span>)
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>instance Exception EscapeSnap
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>instance Show EscapeSnap where
<span class="lineno">  167 </span>    <span class="decl"><span class="istickedoff">show (TerminateConnection e) = &quot;&lt;terminated: &quot; ++ show e ++ &quot;&gt;&quot;</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff">show (EscapeHttp _)          = &quot;&lt;escape http&gt;&quot;</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>------------------------------------------------------------------------------
<span class="lineno">  172 </span>data Zero = PassOnProcessing
<span class="lineno">  173 </span>          | EarlyTermination Response
<span class="lineno">  174 </span>          | EscapeSnap EscapeSnap
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>                             --------------------
<span class="lineno">  177 </span>                             -- The Snap Monad --
<span class="lineno">  178 </span>                             --------------------
<span class="lineno">  179 </span>{-|
<span class="lineno">  180 </span>'Snap' is the 'Monad' that user web handlers run in. 'Snap' gives you:
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>1. Stateful access to fetch or modify an HTTP 'Request'.
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>    @
<span class="lineno">  185 </span>    printRqContextPath :: Snap ()
<span class="lineno">  186 </span>    printRqContextPath = 'writeBS' . 'rqContextPath' =&lt;&lt; 'getRequest'
<span class="lineno">  187 </span>    @
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>2. Stateful access to fetch or modify an HTTP 'Response'.
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>    @
<span class="lineno">  192 </span>    printRspStatusReason :: Snap ()
<span class="lineno">  193 </span>    printRspStatusReason = 'writeBS' . 'rspStatusReason' =&lt;&lt; 'getResponse'
<span class="lineno">  194 </span>    @
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>3. Failure \/ 'Alternative' \/ 'MonadPlus' semantics: a 'Snap' handler can
<span class="lineno">  197 </span>choose not to handle a given request, using 'empty' or its synonym 'pass', and
<span class="lineno">  198 </span>you can try alternative handlers with the '&lt;|&gt;' operator:
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>    @
<span class="lineno">  201 </span>    a :: Snap String
<span class="lineno">  202 </span>    a = 'pass'
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>    b :: Snap String
<span class="lineno">  205 </span>    b = return \&quot;foo\&quot;
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>    c :: Snap String
<span class="lineno">  208 </span>    c = a '&lt;|&gt;' b             -- try running a, if it fails then try b
<span class="lineno">  209 </span>    @
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>4. Convenience functions ('writeBS', 'writeLBS', 'writeText', 'writeLazyText',
<span class="lineno">  212 </span>'addToOutput') for queueing output to be written to the 'Response', or for
<span class="lineno">  213 </span>streaming to the response using
<span class="lineno">  214 </span>&lt;http://hackage.haskell.org/package/io-streams io-streams&gt;:
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>    @
<span class="lineno">  217 </span>    example :: ('OutputStream' 'Builder' -&gt; IO ('OutputStream' 'Builder')) -&gt; Snap ()
<span class="lineno">  218 </span>    example streamProc = do
<span class="lineno">  219 </span>        'writeBS'   \&quot;I\'m a strict bytestring\&quot;
<span class="lineno">  220 </span>        'writeLBS'  \&quot;I\'m a lazy bytestring\&quot;
<span class="lineno">  221 </span>        'writeText' \&quot;I\'m strict text\&quot;
<span class="lineno">  222 </span>        'addToOutput' streamProc
<span class="lineno">  223 </span>    @
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>5. Early termination: if you call 'finishWith':
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>    @
<span class="lineno">  228 </span>    a :: Snap ()
<span class="lineno">  229 </span>    a = do
<span class="lineno">  230 </span>        'modifyResponse' $ 'setResponseStatus' 500 \&quot;Internal Server Error\&quot;
<span class="lineno">  231 </span>        'writeBS' \&quot;500 error\&quot;
<span class="lineno">  232 </span>        r &lt;- 'getResponse'
<span class="lineno">  233 </span>        'finishWith' r
<span class="lineno">  234 </span>    @
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>    then any subsequent processing will be skipped and the supplied 'Response'
<span class="lineno">  237 </span>    value will be returned from 'runSnap' as-is.
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>6. Access to the 'IO' monad through a 'MonadIO' instance:
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>    @
<span class="lineno">  242 </span>    a :: Snap ()
<span class="lineno">  243 </span>    a = 'liftIO' fireTheMissiles
<span class="lineno">  244 </span>    @
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>7. The ability to set or extend a timeout which will kill the handler thread
<span class="lineno">  247 </span>after @N@ seconds of inactivity (the default is 20 seconds):
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>    @
<span class="lineno">  250 </span>    a :: Snap ()
<span class="lineno">  251 </span>    a = 'setTimeout' 30
<span class="lineno">  252 </span>    @
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>8. Throw and catch exceptions using a 'MonadBaseControl' instance:
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>    @
<span class="lineno">  257 </span>    import &quot;Control.Exception.Lifted&quot; ('SomeException', 'throwIO', 'catch')
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>    foo :: Snap ()
<span class="lineno">  260 </span>    foo = bar \`catch\` \(e::'SomeException') -&gt; baz
<span class="lineno">  261 </span>      where
<span class="lineno">  262 </span>        bar = 'throwIO' FooException
<span class="lineno">  263 </span>    @
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>9. Log a message to the error log:
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>    @
<span class="lineno">  268 </span>    foo :: Snap ()
<span class="lineno">  269 </span>    foo = 'logError' \&quot;grumble.\&quot;
<span class="lineno">  270 </span>    @
<span class="lineno">  271 </span>-}
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>-- Haddock comment broken in two to work around https://github.com/haskell/haddock/issues/313
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- | You may notice that most of the type signatures in this module contain a
<span class="lineno">  276 </span>-- @('MonadSnap' m) =&gt; ...@ typeclass constraint. 'MonadSnap' is a typeclass
<span class="lineno">  277 </span>-- which, in essence, says \&quot;you can get back to the 'Snap' monad from
<span class="lineno">  278 </span>-- here\&quot;. Using 'MonadSnap' you can extend the 'Snap' monad with additional
<span class="lineno">  279 </span>-- functionality and still have access to most of the 'Snap' functions without
<span class="lineno">  280 </span>-- writing 'Control.Monad.Trans.Class.lift' everywhere. Instances are already
<span class="lineno">  281 </span>-- provided for most of the common monad transformers
<span class="lineno">  282 </span>-- ('Control.Monad.Trans.Reader.ReaderT', 'Control.Monad.Trans.Writer.WriterT',
<span class="lineno">  283 </span>-- 'Control.Monad.Trans.State.StateT', etc.).
<span class="lineno">  284 </span>newtype Snap a = Snap {
<span class="lineno">  285 </span>      <span class="istickedoff"><span class="decl"><span class="istickedoff">unSnap</span></span></span> :: forall r . (a -&gt; SnapState -&gt; IO r)   -- success continuation
<span class="lineno">  286 </span>             -&gt; (Zero -&gt; SnapState -&gt; IO r)           -- mzero continuation
<span class="lineno">  287 </span>             -&gt; SnapState                             -- state for the monad
<span class="lineno">  288 </span>             -&gt; IO r
<span class="lineno">  289 </span>    }
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>------------------------------------------------------------------------------
<span class="lineno">  293 </span>data SnapState = SnapState
<span class="lineno">  294 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">_snapRequest</span></span></span>       :: Request
<span class="lineno">  295 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">_snapResponse</span></span></span>      :: Response
<span class="lineno">  296 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">_snapLogError</span></span></span>      :: ByteString -&gt; IO ()
<span class="lineno">  297 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">_snapModifyTimeout</span></span></span> :: (Int -&gt; Int) -&gt; IO ()
<span class="lineno">  298 </span>    }
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>-- TODO(greg): error log action and timeout modifier are never modified.
<span class="lineno">  301 </span>-- Splitting them out into their own datatype would save 16 bytes of allocation
<span class="lineno">  302 </span>-- every time you modify the request or response, but would gobble a register.
<span class="lineno">  303 </span>-- Benchmark it both ways.
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>------------------------------------------------------------------------------
<span class="lineno">  306 </span>instance Monad Snap where
<span class="lineno">  307 </span>    <span class="decl"><span class="istickedoff">(&gt;&gt;=)  = snapBind</span></span>
<span class="lineno">  308 </span>    <span class="decl"><span class="istickedoff">return = snapReturn</span></span>
<span class="lineno">  309 </span>    <span class="decl"><span class="istickedoff">fail   = snapFail</span></span>
<span class="lineno">  310 </span>
<span class="lineno">  311 </span>
<span class="lineno">  312 </span>------------------------------------------------------------------------------
<span class="lineno">  313 </span>snapBind :: Snap a -&gt; (a -&gt; Snap b) -&gt; Snap b
<span class="lineno">  314 </span><span class="decl"><span class="istickedoff">snapBind m f = Snap $ \sk fk st -&gt; unSnap m (\a st' -&gt; unSnap (f a) sk fk st') fk st</span></span>
<span class="lineno">  315 </span>{-# INLINE snapBind #-}
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>snapReturn :: a -&gt; Snap a
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">snapReturn = pure</span></span>
<span class="lineno">  320 </span>{-# INLINE snapReturn #-}
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>snapFail :: String -&gt; Snap a
<span class="lineno">  324 </span><span class="decl"><span class="istickedoff">snapFail !_ = Snap $ \_ fk st -&gt; fk PassOnProcessing st</span></span>
<span class="lineno">  325 </span>{-# INLINE snapFail #-}
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>
<span class="lineno">  328 </span>------------------------------------------------------------------------------
<span class="lineno">  329 </span>instance MonadIO Snap where
<span class="lineno">  330 </span>    <span class="decl"><span class="istickedoff">liftIO m = Snap $ \sk _ st -&gt; do x &lt;- m</span>
<span class="lineno">  331 </span><span class="spaces">                                     </span><span class="istickedoff">sk x st</span></span>
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>------------------------------------------------------------------------------
<span class="lineno">  335 </span>instance (MonadBase IO) Snap where
<span class="lineno">  336 </span>    <span class="decl"><span class="istickedoff">liftBase = liftIO</span></span>
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>------------------------------------------------------------------------------
<span class="lineno">  340 </span>newtype StSnap a = StSnap {
<span class="lineno">  341 </span>      <span class="istickedoff"><span class="decl"><span class="istickedoff">unStSnap</span></span></span> :: StM (StateT SnapState IO) (SnapResult a)
<span class="lineno">  342 </span>    }
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>instance (MonadBaseControl IO) Snap where
<span class="lineno">  345 </span>    type StM Snap a = StSnap a
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>    <span class="decl"><span class="istickedoff">liftBaseWith f = stateTToSnap $ liftM SnapValue $</span>
<span class="lineno">  348 </span><span class="spaces">                     </span><span class="istickedoff">liftBaseWith $ \g' -&gt; f $ \m -&gt;</span>
<span class="lineno">  349 </span><span class="spaces">                     </span><span class="istickedoff">liftM StSnap $ g' $ snapToStateT m</span></span>
<span class="lineno">  350 </span>    {-# INLINE liftBaseWith #-}
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>    <span class="decl"><span class="istickedoff">restoreM = stateTToSnap . restoreM . unStSnap</span></span>
<span class="lineno">  353 </span>    {-# INLINE restoreM #-}
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>------------------------------------------------------------------------------
<span class="lineno">  356 </span>snapToStateT :: Snap a -&gt; StateT SnapState IO (SnapResult a)
<span class="lineno">  357 </span><span class="decl"><span class="istickedoff">snapToStateT m = StateT $ \st -&gt; do</span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">unSnap m (\a st' -&gt; return (SnapValue a, st'))</span>
<span class="lineno">  359 </span><span class="spaces">             </span><span class="istickedoff">(\z st' -&gt; return (Zero z, st')) st</span></span>
<span class="lineno">  360 </span>{-# INLINE snapToStateT #-}
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>------------------------------------------------------------------------------
<span class="lineno">  364 </span>{-# INLINE stateTToSnap #-}
<span class="lineno">  365 </span>stateTToSnap :: StateT SnapState IO (SnapResult a) -&gt; Snap a
<span class="lineno">  366 </span><span class="decl"><span class="istickedoff">stateTToSnap m = Snap $ \sk fk st -&gt; do</span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="istickedoff">(a, st') &lt;- runStateT m st</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">case a of</span>
<span class="lineno">  369 </span><span class="spaces">      </span><span class="istickedoff">SnapValue x -&gt; sk x st'</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">Zero z      -&gt; fk z st'</span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>------------------------------------------------------------------------------
<span class="lineno">  374 </span>instance MonadPlus Snap where
<span class="lineno">  375 </span>    <span class="decl"><span class="istickedoff">mzero = Snap $ \_ fk st -&gt; fk PassOnProcessing st</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>    <span class="decl"><span class="istickedoff">a `mplus` b =</span>
<span class="lineno">  378 </span><span class="spaces">        </span><span class="istickedoff">Snap $ \sk fk st -&gt;</span>
<span class="lineno">  379 </span><span class="spaces">            </span><span class="istickedoff">let fk' z st' = case z of</span>
<span class="lineno">  380 </span><span class="spaces">                              </span><span class="istickedoff">PassOnProcessing -&gt; unSnap b sk fk st'</span>
<span class="lineno">  381 </span><span class="spaces">                              </span><span class="istickedoff">_                -&gt; fk z st'</span>
<span class="lineno">  382 </span><span class="spaces">            </span><span class="istickedoff">in unSnap a sk fk' st</span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>------------------------------------------------------------------------------
<span class="lineno">  386 </span>instance Functor Snap where
<span class="lineno">  387 </span>    <span class="decl"><span class="istickedoff">fmap f m = Snap $ \sk fk st -&gt; unSnap m (sk . f) fk st</span></span>
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>------------------------------------------------------------------------------
<span class="lineno">  390 </span>instance Applicative Snap where
<span class="lineno">  391 </span>    <span class="decl"><span class="istickedoff">pure x  = Snap $ \sk _ st -&gt; sk x st</span></span>
<span class="lineno">  392 </span>    <span class="decl"><span class="istickedoff">(&lt;*&gt;)   = ap</span></span>
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>------------------------------------------------------------------------------
<span class="lineno">  396 </span>instance Alternative Snap where
<span class="lineno">  397 </span>    <span class="decl"><span class="istickedoff">empty = mzero</span></span>
<span class="lineno">  398 </span>    <span class="decl"><span class="istickedoff">(&lt;|&gt;) = mplus</span></span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>------------------------------------------------------------------------------
<span class="lineno">  402 </span>instance MonadSnap Snap where
<span class="lineno">  403 </span>    <span class="decl"><span class="istickedoff">liftSnap = id</span></span>
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>------------------------------------------------------------------------------
<span class="lineno">  407 </span>-- | The Typeable instance is here so Snap can be dynamically executed with
<span class="lineno">  408 </span>-- Hint.
<span class="lineno">  409 </span>#if __GLASGOW_HASKELL__ &lt; 708
<span class="lineno">  410 </span>snapTyCon :: TyCon
<span class="lineno">  411 </span>#if MIN_VERSION_base(4,4,0)
<span class="lineno">  412 </span><span class="decl"><span class="istickedoff">snapTyCon = mkTyCon3 &quot;snap-core&quot; &quot;Snap.Core&quot; &quot;Snap&quot;</span></span>
<span class="lineno">  413 </span>#else
<span class="lineno">  414 </span>snapTyCon = mkTyCon &quot;Snap.Core.Snap&quot;
<span class="lineno">  415 </span>#endif
<span class="lineno">  416 </span>{-# NOINLINE snapTyCon #-}
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>instance Typeable1 Snap where
<span class="lineno">  419 </span>    <span class="decl"><span class="istickedoff">typeOf1 _ = mkTyConApp snapTyCon []</span></span>
<span class="lineno">  420 </span>#else
<span class="lineno">  421 </span>deriving instance Typeable Snap
<span class="lineno">  422 </span>#endif
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>------------------------------------------------------------------------------
<span class="lineno">  425 </span>-- | Pass the request body stream to a consuming procedure, returning the
<span class="lineno">  426 </span>-- result.
<span class="lineno">  427 </span>--
<span class="lineno">  428 </span>-- If the consuming procedure you pass in here throws an exception, Snap will
<span class="lineno">  429 </span>-- attempt to clear the rest of the unread request body (using
<span class="lineno">  430 </span>-- 'System.IO.Streams.Combinators.skipToEof') before rethrowing the
<span class="lineno">  431 </span>-- exception. If you used 'terminateConnection', however, Snap will give up and
<span class="lineno">  432 </span>-- immediately close the socket.
<span class="lineno">  433 </span>--
<span class="lineno">  434 </span>-- To prevent slowloris attacks, the connection will be also terminated if the
<span class="lineno">  435 </span>-- input socket produces data too slowly (500 bytes per second is the default
<span class="lineno">  436 </span>-- limit).
<span class="lineno">  437 </span>--
<span class="lineno">  438 </span>-- Example:
<span class="lineno">  439 </span>--
<span class="lineno">  440 </span>-- @
<span class="lineno">  441 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  442 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno">  443 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Lazy&quot; as L
<span class="lineno">  444 </span>-- ghci&gt; import &quot;Data.Char&quot; (toUpper)
<span class="lineno">  445 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  446 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  447 </span>-- ghci&gt; import qualified &quot;System.IO.Streams&quot; as Streams
<span class="lineno">  448 </span>-- ghci&gt; let r = T.put \&quot;\/foo\&quot; \&quot;text\/plain\&quot; \&quot;some text\&quot;
<span class="lineno">  449 </span>-- ghci&gt; :{
<span class="lineno">  450 </span>-- ghci| let f s = do u \&lt;- Streams.map (B8.map toUpper) s
<span class="lineno">  451 </span>-- ghci|              l \&lt;- Streams.toList u
<span class="lineno">  452 </span>-- ghci|              return $ L.fromChunks l
<span class="lineno">  453 </span>-- ghci| :}
<span class="lineno">  454 </span>-- ghci&gt; T.runHandler r ('runRequestBody' f &gt;&gt;= 'writeLBS')
<span class="lineno">  455 </span>-- HTTP/1.1 200 OK
<span class="lineno">  456 </span>-- server: Snap/test
<span class="lineno">  457 </span>-- date: Thu, 07 Aug 2014 20:48:40 GMT
<span class="lineno">  458 </span>--
<span class="lineno">  459 </span>-- SOME TEXT
<span class="lineno">  460 </span>-- @
<span class="lineno">  461 </span>runRequestBody :: MonadSnap m =&gt;
<span class="lineno">  462 </span>                  (InputStream ByteString -&gt; IO a)
<span class="lineno">  463 </span>               -&gt; m a
<span class="lineno">  464 </span><span class="decl"><span class="istickedoff">runRequestBody proc = do</span>
<span class="lineno">  465 </span><span class="spaces">    </span><span class="istickedoff">bumpTimeout &lt;- liftM ($ max 5) getTimeoutModifier</span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">req         &lt;- getRequest</span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="istickedoff">body        &lt;- liftIO $ Streams.throwIfTooSlow bumpTimeout 500 5 $</span>
<span class="lineno">  468 </span><span class="spaces">                            </span><span class="istickedoff">rqBody req</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">run body</span>
<span class="lineno">  470 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  471 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">skip body = liftIO (Streams.skipToEof body) `catch` tooSlow</span>
<span class="lineno">  473 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">tooSlow (e :: Streams.RateTooSlowException) =</span>
<span class="lineno">  475 </span><span class="spaces">        </span><span class="istickedoff">terminateConnection e</span>
<span class="lineno">  476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="istickedoff">run body = (liftIO $ do</span>
<span class="lineno">  478 </span><span class="spaces">        </span><span class="istickedoff">x &lt;- proc body</span>
<span class="lineno">  479 </span><span class="spaces">        </span><span class="istickedoff">Streams.skipToEof body</span>
<span class="lineno">  480 </span><span class="spaces">        </span><span class="istickedoff">return x) `catches` handlers</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  482 </span><span class="spaces">        </span><span class="istickedoff">handlers = [ Handler tooSlow, Handler other ]</span>
<span class="lineno">  483 </span><span class="spaces">        </span><span class="istickedoff">other (e :: SomeException) = skip body &gt;&gt; throwIO e</span></span>
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>------------------------------------------------------------------------------
<span class="lineno">  487 </span>-- | Returns the request body as a lazy bytestring. /Note that the request is
<span class="lineno">  488 </span>-- not actually provided lazily!/
<span class="lineno">  489 </span>--
<span class="lineno">  490 </span>-- Example:
<span class="lineno">  491 </span>--
<span class="lineno">  492 </span>-- @
<span class="lineno">  493 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  494 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  495 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  496 </span>-- ghci&gt; let r = T.put \&quot;\/foo\&quot; \&quot;text\/plain\&quot; \&quot;some text\&quot;
<span class="lineno">  497 </span>-- ghci&gt; T.runHandler r ('readRequestBody' 2048 &gt;&gt;= 'writeLBS')
<span class="lineno">  498 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  499 </span>-- server: Snap\/test
<span class="lineno">  500 </span>-- date: Thu, 07 Aug 2014 20:08:44 GMT
<span class="lineno">  501 </span>--
<span class="lineno">  502 </span>-- some text
<span class="lineno">  503 </span>-- @
<span class="lineno">  504 </span>--
<span class="lineno">  505 </span>-- /Since: 0.6/
<span class="lineno">  506 </span>readRequestBody :: MonadSnap m =&gt;
<span class="lineno">  507 </span>                   Word64  -- ^ size of the largest request body we're willing
<span class="lineno">  508 </span>                           -- to accept. If a request body longer than this is
<span class="lineno">  509 </span>                           -- received, a 'TooManyBytesReadException' is
<span class="lineno">  510 </span>                           -- thrown. See 'takeNoMoreThan'.
<span class="lineno">  511 </span>                -&gt; m L.ByteString
<span class="lineno">  512 </span><span class="decl"><span class="istickedoff">readRequestBody sz = liftM L.fromChunks $ runRequestBody f</span>
<span class="lineno">  513 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  514 </span><span class="spaces">    </span><span class="istickedoff">f str = Streams.throwIfProducesMoreThan (fromIntegral sz) str &gt;&gt;=</span>
<span class="lineno">  515 </span><span class="spaces">            </span><span class="istickedoff">Streams.toList</span></span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>
<span class="lineno">  518 </span>------------------------------------------------------------------------------
<span class="lineno">  519 </span>-- | Normally Snap is careful to ensure that the request body is fully
<span class="lineno">  520 </span>-- consumed after your web handler runs, but before the 'Response' body
<span class="lineno">  521 </span>-- is streamed out the socket. If you want to transform the request body into
<span class="lineno">  522 </span>-- some output in O(1) space, you should use this function.
<span class="lineno">  523 </span>--
<span class="lineno">  524 </span>-- Take care: in order for this to work, the HTTP client must be written with
<span class="lineno">  525 </span>-- input-to-output streaming in mind.
<span class="lineno">  526 </span>--
<span class="lineno">  527 </span>-- Note that upon calling this function, response processing finishes early as
<span class="lineno">  528 </span>-- if you called 'finishWith'. Make sure you set any content types, headers,
<span class="lineno">  529 </span>-- cookies, etc. before you call this function.
<span class="lineno">  530 </span>--
<span class="lineno">  531 </span>-- Example:
<span class="lineno">  532 </span>--
<span class="lineno">  533 </span>-- @
<span class="lineno">  534 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  535 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno">  536 </span>-- ghci&gt; import &quot;Data.Char&quot; (toUpper)
<span class="lineno">  537 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  538 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  539 </span>-- ghci&gt; import qualified &quot;System.IO.Streams&quot; as Streams
<span class="lineno">  540 </span>-- ghci&gt; let r = T.put \&quot;\/foo\&quot; \&quot;text\/plain\&quot; \&quot;some text\&quot;
<span class="lineno">  541 </span>-- ghci&gt; let f = Streams.map (B8.map toUpper)
<span class="lineno">  542 </span>-- ghci&gt; T.runHandler r ('transformRequestBody' f &gt;&gt; 'readRequestBody' 2048 &gt;&gt;= 'writeLBS')
<span class="lineno">  543 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  544 </span>-- server: Snap\/test
<span class="lineno">  545 </span>-- date: Thu, 07 Aug 2014 20:30:15 GMT
<span class="lineno">  546 </span>--
<span class="lineno">  547 </span>-- SOME TEXT
<span class="lineno">  548 </span>-- @
<span class="lineno">  549 </span>transformRequestBody :: (InputStream ByteString -&gt; IO (InputStream ByteString))
<span class="lineno">  550 </span>                         -- ^ the 'InputStream' from the 'Request' is passed to
<span class="lineno">  551 </span>                         -- this function, and then the resulting 'InputStream'
<span class="lineno">  552 </span>                         -- is fed to the output.
<span class="lineno">  553 </span>                     -&gt; Snap ()
<span class="lineno">  554 </span><span class="decl"><span class="istickedoff">transformRequestBody trans = do</span>
<span class="lineno">  555 </span><span class="spaces">    </span><span class="istickedoff">req     &lt;- getRequest</span>
<span class="lineno">  556 </span><span class="spaces">    </span><span class="istickedoff">is      &lt;- liftIO ((trans $ rqBody req) &gt;&gt;=</span>
<span class="lineno">  557 </span><span class="spaces">                         </span><span class="istickedoff">Streams.mapM (return . byteString))</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="istickedoff">origRsp &lt;- getResponse</span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">let rsp = setResponseBody (\out -&gt; Streams.connect is out &gt;&gt; return out) $</span>
<span class="lineno">  560 </span><span class="spaces">              </span><span class="istickedoff">origRsp { rspTransformingRqBody = True }</span>
<span class="lineno">  561 </span><span class="spaces">    </span><span class="istickedoff">finishWith rsp</span></span>
<span class="lineno">  562 </span>
<span class="lineno">  563 </span>
<span class="lineno">  564 </span>------------------------------------------------------------------------------
<span class="lineno">  565 </span>-- | Short-circuits a 'Snap' monad action early, storing the given
<span class="lineno">  566 </span>-- 'Response' value in its state.
<span class="lineno">  567 </span>--
<span class="lineno">  568 </span>-- IMPORTANT: Be vary careful when using this with things like a DB library's
<span class="lineno">  569 </span>-- `withTransaction` function or any other kind of setup/teardown block, as it
<span class="lineno">  570 </span>-- can prevent the cleanup from being called and result in resource leaks.
<span class="lineno">  571 </span>--
<span class="lineno">  572 </span>-- Example:
<span class="lineno">  573 </span>--
<span class="lineno">  574 </span>-- @
<span class="lineno">  575 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  576 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  577 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  578 </span>-- ghci&gt; import &quot;Control.Applicative&quot;
<span class="lineno">  579 </span>-- ghci&gt; let r = T.get \&quot;\/\&quot; M.empty
<span class="lineno">  580 </span>-- ghci&gt; T.runHandler r (('ifTop' $ 'writeBS' \&quot;TOP\&quot;) \&lt;|&gt; 'finishWith' 'emptyResponse')
<span class="lineno">  581 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  582 </span>-- server: Snap\/test
<span class="lineno">  583 </span>-- date: Thu, 07 Aug 2014 16:58:57 GMT
<span class="lineno">  584 </span>--
<span class="lineno">  585 </span>-- TOP
<span class="lineno">  586 </span>-- ghci&gt; let r\' = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  587 </span>-- ghci&gt; T.runHandler r\' (('ifTop' $ 'writeBS' \&quot;TOP\&quot;) \&lt;|&gt; 'finishWith' 'emptyResponse')
<span class="lineno">  588 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  589 </span>-- server: Snap\/test
<span class="lineno">  590 </span>-- date: Thu, 07 Aug 2014 17:50:50 GMT
<span class="lineno">  591 </span>--
<span class="lineno">  592 </span>--
<span class="lineno">  593 </span>-- @
<span class="lineno">  594 </span>finishWith :: MonadSnap m =&gt; Response -&gt; m a
<span class="lineno">  595 </span><span class="decl"><span class="istickedoff">finishWith r = liftSnap $ Snap $ \_ fk st -&gt; fk (EarlyTermination r) st</span></span>
<span class="lineno">  596 </span>{-# INLINE finishWith #-}
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>------------------------------------------------------------------------------
<span class="lineno">  600 </span>-- | Capture the flow of control in case a handler calls 'finishWith'.
<span class="lineno">  601 </span>--
<span class="lineno">  602 </span>-- /WARNING/: in the event of a call to 'transformRequestBody' it is possible
<span class="lineno">  603 </span>-- to violate HTTP protocol safety when using this function. If you call
<span class="lineno">  604 </span>-- 'catchFinishWith' it is suggested that you do not modify the body of the
<span class="lineno">  605 </span>-- 'Response' which was passed to the 'finishWith' call.
<span class="lineno">  606 </span>--
<span class="lineno">  607 </span>-- Example:
<span class="lineno">  608 </span>--
<span class="lineno">  609 </span>-- @
<span class="lineno">  610 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  611 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno">  612 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  613 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  614 </span>-- ghci&gt; import &quot;Control.Applicative&quot;
<span class="lineno">  615 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  616 </span>-- ghci&gt; let h = ('ifTop' $ 'writeBS' \&quot;TOP\&quot;) \&lt;|&gt; 'finishWith' 'emptyResponse'
<span class="lineno">  617 </span>-- ghci&gt; T.runHandler r ('catchFinishWith' h &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno">  618 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  619 </span>-- server: Snap\/test
<span class="lineno">  620 </span>-- date: Thu, 07 Aug 2014 18:35:42 GMT
<span class="lineno">  621 </span>--
<span class="lineno">  622 </span>-- Left HTTP\/1.1 200 OK
<span class="lineno">  623 </span>--
<span class="lineno">  624 </span>--
<span class="lineno">  625 </span>-- @
<span class="lineno">  626 </span>catchFinishWith :: Snap a -&gt; Snap (Either Response a)
<span class="lineno">  627 </span><span class="decl"><span class="istickedoff">catchFinishWith (Snap m) = Snap $ \sk fk st -&gt; do</span>
<span class="lineno">  628 </span><span class="spaces">    </span><span class="istickedoff">let sk' v s = sk (Right v) s</span>
<span class="lineno">  629 </span><span class="spaces">    </span><span class="istickedoff">let fk' z s = case z of</span>
<span class="lineno">  630 </span><span class="spaces">                    </span><span class="istickedoff">(EarlyTermination resp) -&gt; sk (Left resp) s</span>
<span class="lineno">  631 </span><span class="spaces">                    </span><span class="istickedoff">_                       -&gt; fk z s</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="istickedoff">m sk' fk' st</span></span>
<span class="lineno">  633 </span>{-# INLINE catchFinishWith #-}
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>------------------------------------------------------------------------------
<span class="lineno">  637 </span>-- | Fails out of a 'Snap' monad action.  This is used to indicate
<span class="lineno">  638 </span>-- that you choose not to handle the given request within the given
<span class="lineno">  639 </span>-- handler.
<span class="lineno">  640 </span>--
<span class="lineno">  641 </span>-- Example:
<span class="lineno">  642 </span>--
<span class="lineno">  643 </span>-- @
<span class="lineno">  644 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  645 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  646 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  647 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  648 </span>-- ghci&gt; T.runHandler r 'pass'
<span class="lineno">  649 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  650 </span>-- server: Snap\/test
<span class="lineno">  651 </span>-- date: Thu, 07 Aug 2014 13:35:42 GMT
<span class="lineno">  652 </span>--
<span class="lineno">  653 </span>-- \&lt;!DOCTYPE html&gt;
<span class="lineno">  654 </span>-- \&lt;html&gt;
<span class="lineno">  655 </span>-- \&lt;head&gt;
<span class="lineno">  656 </span>-- \&lt;title&gt;Not found\&lt;\/title&gt;
<span class="lineno">  657 </span>-- \&lt;\/head&gt;
<span class="lineno">  658 </span>-- \&lt;body&gt;
<span class="lineno">  659 </span>-- \&lt;code&gt;No handler accepted \&quot;\/foo\/bar\&quot;&lt;\/code&gt;
<span class="lineno">  660 </span>-- \&lt;\/body&gt;\&lt;\/html&gt;
<span class="lineno">  661 </span>-- @
<span class="lineno">  662 </span>pass :: MonadSnap m =&gt; m a
<span class="lineno">  663 </span><span class="decl"><span class="istickedoff">pass = empty</span></span>
<span class="lineno">  664 </span>
<span class="lineno">  665 </span>
<span class="lineno">  666 </span>------------------------------------------------------------------------------
<span class="lineno">  667 </span>-- | Runs a 'Snap' monad action only if the request's HTTP method matches
<span class="lineno">  668 </span>-- the given method.
<span class="lineno">  669 </span>--
<span class="lineno">  670 </span>-- Example:
<span class="lineno">  671 </span>--
<span class="lineno">  672 </span>-- @
<span class="lineno">  673 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  674 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  675 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  676 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  677 </span>-- ghci&gt; T.runHandler r ('method' 'GET' $ 'writeBS' \&quot;OK\&quot;)
<span class="lineno">  678 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  679 </span>-- server: Snap\/test
<span class="lineno">  680 </span>-- date: Thu, 07 Aug 2014 13:38:48 GMT
<span class="lineno">  681 </span>--
<span class="lineno">  682 </span>-- OK
<span class="lineno">  683 </span>-- ghci&gt; T.runHandler r ('method' 'POST' $ 'writeBS' \&quot;OK\&quot;)
<span class="lineno">  684 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  685 </span>-- ...
<span class="lineno">  686 </span>-- @
<span class="lineno">  687 </span>method :: MonadSnap m =&gt; Method -&gt; m a -&gt; m a
<span class="lineno">  688 </span><span class="decl"><span class="istickedoff">method m action = do</span>
<span class="lineno">  689 </span><span class="spaces">    </span><span class="istickedoff">req &lt;- getRequest</span>
<span class="lineno">  690 </span><span class="spaces">    </span><span class="istickedoff">unless (rqMethod req == m) pass</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="istickedoff">action</span></span>
<span class="lineno">  692 </span>{-# INLINE method #-}
<span class="lineno">  693 </span>
<span class="lineno">  694 </span>
<span class="lineno">  695 </span>------------------------------------------------------------------------------
<span class="lineno">  696 </span>-- | Runs a 'Snap' monad action only if the request's HTTP method matches
<span class="lineno">  697 </span>-- one of the given methods.
<span class="lineno">  698 </span>--
<span class="lineno">  699 </span>-- Example:
<span class="lineno">  700 </span>--
<span class="lineno">  701 </span>-- @
<span class="lineno">  702 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  703 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  704 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  705 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  706 </span>-- ghci&gt; T.runHandler r ('methods' ['GET', 'POST'] $ 'writeBS' \&quot;OK\&quot;)
<span class="lineno">  707 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  708 </span>-- server: Snap\/test
<span class="lineno">  709 </span>-- date: Thu, 07 Aug 2014 13:38:48 GMT
<span class="lineno">  710 </span>--
<span class="lineno">  711 </span>-- OK
<span class="lineno">  712 </span>-- ghci&gt; T.runHandler r ('methods' ['POST'] $ 'writeBS' \&quot;OK\&quot;)
<span class="lineno">  713 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  714 </span>-- ...
<span class="lineno">  715 </span>-- @
<span class="lineno">  716 </span>methods :: MonadSnap m =&gt; [Method] -&gt; m a -&gt; m a
<span class="lineno">  717 </span><span class="decl"><span class="istickedoff">methods ms action = do</span>
<span class="lineno">  718 </span><span class="spaces">    </span><span class="istickedoff">req &lt;- getRequest</span>
<span class="lineno">  719 </span><span class="spaces">    </span><span class="istickedoff">unless (rqMethod req `elem` ms) pass</span>
<span class="lineno">  720 </span><span class="spaces">    </span><span class="istickedoff">action</span></span>
<span class="lineno">  721 </span>{-# INLINE methods #-}
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>
<span class="lineno">  724 </span>------------------------------------------------------------------------------
<span class="lineno">  725 </span>-- Appends n bytes of the path info to the context path with a
<span class="lineno">  726 </span>-- trailing slash.
<span class="lineno">  727 </span>updateContextPath :: Int -&gt; Request -&gt; Request
<span class="lineno">  728 </span><span class="decl"><span class="istickedoff">updateContextPath n req | n &gt; 0     = req { rqContextPath = ctx</span>
<span class="lineno">  729 </span><span class="spaces">                                          </span><span class="istickedoff">, rqPathInfo    = pinfo }</span>
<span class="lineno">  730 </span><span class="spaces">                        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = req</span>
<span class="lineno">  731 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  732 </span><span class="spaces">    </span><span class="istickedoff">ctx'  = S.take n (rqPathInfo req)</span>
<span class="lineno">  733 </span><span class="spaces">    </span><span class="istickedoff">ctx   = S.concat [rqContextPath req, ctx', &quot;/&quot;]</span>
<span class="lineno">  734 </span><span class="spaces">    </span><span class="istickedoff">pinfo = S.drop (n+1) (rqPathInfo req)</span></span>
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>
<span class="lineno">  737 </span>------------------------------------------------------------------------------
<span class="lineno">  738 </span>-- Runs a 'Snap' monad action only if the 'rqPathInfo' matches the given
<span class="lineno">  739 </span>-- predicate.
<span class="lineno">  740 </span>pathWith :: MonadSnap m
<span class="lineno">  741 </span>         =&gt; (ByteString -&gt; ByteString -&gt; Bool)
<span class="lineno">  742 </span>         -&gt; ByteString
<span class="lineno">  743 </span>         -&gt; m a
<span class="lineno">  744 </span>         -&gt; m a
<span class="lineno">  745 </span><span class="decl"><span class="istickedoff">pathWith c p action = do</span>
<span class="lineno">  746 </span><span class="spaces">    </span><span class="istickedoff">req &lt;- getRequest</span>
<span class="lineno">  747 </span><span class="spaces">    </span><span class="istickedoff">unless (c p (rqPathInfo req)) pass</span>
<span class="lineno">  748 </span><span class="spaces">    </span><span class="istickedoff">localRequest (updateContextPath $ S.length p) action</span></span>
<span class="lineno">  749 </span>
<span class="lineno">  750 </span>
<span class="lineno">  751 </span>------------------------------------------------------------------------------
<span class="lineno">  752 </span>-- | Runs a 'Snap' monad action only when the 'rqPathInfo' of the request
<span class="lineno">  753 </span>-- starts with the given path. For example,
<span class="lineno">  754 </span>--
<span class="lineno">  755 </span>-- &gt; dir &quot;foo&quot; handler
<span class="lineno">  756 </span>--
<span class="lineno">  757 </span>-- Will fail if 'rqPathInfo' is not \&quot;@\/foo@\&quot; or \&quot;@\/foo\/...@\&quot;, and will
<span class="lineno">  758 </span>-- add @\&quot;foo\/\&quot;@ to the handler's local 'rqContextPath'.
<span class="lineno">  759 </span>--
<span class="lineno">  760 </span>-- Example:
<span class="lineno">  761 </span>--
<span class="lineno">  762 </span>-- @
<span class="lineno">  763 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  764 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  765 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  766 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  767 </span>-- ghci&gt; T.runHandler r ('dir' \&quot;foo\&quot; $ 'writeBS' \&quot;OK\&quot;)
<span class="lineno">  768 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  769 </span>-- server: Snap\/test
<span class="lineno">  770 </span>-- date: Thu, 07 Aug 2014 14:52:24 GMT
<span class="lineno">  771 </span>--
<span class="lineno">  772 </span>-- OK
<span class="lineno">  773 </span>-- ghci&gt; T.runHandler r ('dir' \&quot;baz\&quot; $ 'writeBS' \&quot;OK\&quot;)
<span class="lineno">  774 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  775 </span>-- ...
<span class="lineno">  776 </span>-- @
<span class="lineno">  777 </span>dir :: MonadSnap m
<span class="lineno">  778 </span>    =&gt; ByteString  -- ^ path component to match
<span class="lineno">  779 </span>    -&gt; m a         -- ^ handler to run
<span class="lineno">  780 </span>    -&gt; m a
<span class="lineno">  781 </span><span class="decl"><span class="istickedoff">dir = pathWith f</span>
<span class="lineno">  782 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  783 </span><span class="spaces">    </span><span class="istickedoff">f dr pinfo = dr == x</span>
<span class="lineno">  784 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  785 </span><span class="spaces">        </span><span class="istickedoff">(x,_) = S.break (=='/') pinfo</span></span>
<span class="lineno">  786 </span>{-# INLINE dir #-}
<span class="lineno">  787 </span>
<span class="lineno">  788 </span>
<span class="lineno">  789 </span>------------------------------------------------------------------------------
<span class="lineno">  790 </span>-- | Runs a 'Snap' monad action only for requests where 'rqPathInfo' is
<span class="lineno">  791 </span>-- exactly equal to the given string. If the path matches, locally sets
<span class="lineno">  792 </span>-- 'rqContextPath' to the old value of 'rqPathInfo', sets 'rqPathInfo'=\&quot;\&quot;,
<span class="lineno">  793 </span>-- and runs the given handler.
<span class="lineno">  794 </span>--
<span class="lineno">  795 </span>-- Example:
<span class="lineno">  796 </span>--
<span class="lineno">  797 </span>-- @
<span class="lineno">  798 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  799 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  800 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  801 </span>-- ghci&gt; T.runHandler (T.get \&quot;\/foo\&quot; M.empty) ('path' \&quot;foo\&quot; $ 'writeBS' \&quot;bar\&quot;)
<span class="lineno">  802 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  803 </span>-- server: Snap\/test
<span class="lineno">  804 </span>-- date: Thu, 07 Aug 2014 14:15:42 GMT
<span class="lineno">  805 </span>--
<span class="lineno">  806 </span>-- bar
<span class="lineno">  807 </span>-- ghci&gt; T.runHandler (T.get \&quot;\/foo\&quot; M.empty) ('path' \&quot;bar\&quot; $ 'writeBS' \&quot;baz\&quot;)
<span class="lineno">  808 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  809 </span>-- ...
<span class="lineno">  810 </span>-- @
<span class="lineno">  811 </span>path :: MonadSnap m
<span class="lineno">  812 </span>     =&gt; ByteString  -- ^ path to match against
<span class="lineno">  813 </span>     -&gt; m a         -- ^ handler to run
<span class="lineno">  814 </span>     -&gt; m a
<span class="lineno">  815 </span><span class="decl"><span class="istickedoff">path = pathWith (==)</span></span>
<span class="lineno">  816 </span>{-# INLINE path #-}
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>
<span class="lineno">  819 </span>------------------------------------------------------------------------------
<span class="lineno">  820 </span>-- | Runs a 'Snap' monad action only when the first path component is
<span class="lineno">  821 </span>-- successfully parsed as the argument to the supplied handler function.
<span class="lineno">  822 </span>--
<span class="lineno">  823 </span>-- Note that the path segment is url-decoded prior to being passed to 'fromBS';
<span class="lineno">  824 </span>-- this is new as of snap-core 0.10.
<span class="lineno">  825 </span>--
<span class="lineno">  826 </span>-- Example:
<span class="lineno">  827 </span>--
<span class="lineno">  828 </span>-- @
<span class="lineno">  829 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  830 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  831 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  832 </span>-- ghci&gt; let r = T.get \&quot;\/11\/foo\/bar\&quot; M.empty
<span class="lineno">  833 </span>-- ghci&gt; let f = (\\i -&gt; if i == 11 then 'writeBS' \&quot;11\&quot; else 'writeBS' \&quot;???\&quot;)
<span class="lineno">  834 </span>-- ghci&gt; T.runHandler r ('pathArg' f)
<span class="lineno">  835 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  836 </span>-- server: Snap\/test
<span class="lineno">  837 </span>-- date: Thu, 07 Aug 2014 14:27:10 GMT
<span class="lineno">  838 </span>--
<span class="lineno">  839 </span>-- 11
<span class="lineno">  840 </span>-- ghci&gt; let r\' = T.get \&quot;\/foo\/11\/bar\&quot; M.empty
<span class="lineno">  841 </span>-- ghci&gt; T.runHandler r\' ('pathArg' f)
<span class="lineno">  842 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  843 </span>-- ...
<span class="lineno">  844 </span>-- @
<span class="lineno">  845 </span>pathArg :: (R.Readable a, MonadSnap m)
<span class="lineno">  846 </span>        =&gt; (a -&gt; m b)
<span class="lineno">  847 </span>        -&gt; m b
<span class="lineno">  848 </span><span class="decl"><span class="istickedoff">pathArg f = do</span>
<span class="lineno">  849 </span><span class="spaces">    </span><span class="istickedoff">req &lt;- getRequest</span>
<span class="lineno">  850 </span><span class="spaces">    </span><span class="istickedoff">let (p,_) = S.break (=='/') (rqPathInfo req)</span>
<span class="lineno">  851 </span><span class="spaces">    </span><span class="istickedoff">p' &lt;- maybe mzero return $ urlDecode p</span>
<span class="lineno">  852 </span><span class="spaces">    </span><span class="istickedoff">a &lt;- R.fromBS p'</span>
<span class="lineno">  853 </span><span class="spaces">    </span><span class="istickedoff">localRequest (updateContextPath $ S.length p) (f a)</span></span>
<span class="lineno">  854 </span>
<span class="lineno">  855 </span>
<span class="lineno">  856 </span>------------------------------------------------------------------------------
<span class="lineno">  857 </span>-- | Runs a 'Snap' monad action only when 'rqPathInfo' is empty.
<span class="lineno">  858 </span>--
<span class="lineno">  859 </span>-- Example:
<span class="lineno">  860 </span>--
<span class="lineno">  861 </span>-- @
<span class="lineno">  862 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  863 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  864 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  865 </span>-- ghci&gt; let r = T.get \&quot;\/\&quot; M.empty
<span class="lineno">  866 </span>-- ghci&gt; T.runHandler r ('ifTop' $ 'writeBS' &quot;OK&quot;)
<span class="lineno">  867 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  868 </span>-- server: Snap\/test
<span class="lineno">  869 </span>-- date: Thu, 07 Aug 2014 14:56:39 GMT
<span class="lineno">  870 </span>--
<span class="lineno">  871 </span>-- OK
<span class="lineno">  872 </span>-- ghci&gt; let r\' = T.get \&quot;\/foo\&quot; M.empty
<span class="lineno">  873 </span>-- ghci&gt; T.runHandler r\' ('ifTop' $ 'writeBS' \&quot;OK\&quot;)
<span class="lineno">  874 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  875 </span>-- ...
<span class="lineno">  876 </span>-- @
<span class="lineno">  877 </span>ifTop :: MonadSnap m =&gt; m a -&gt; m a
<span class="lineno">  878 </span><span class="decl"><span class="istickedoff">ifTop = path &quot;&quot;</span></span>
<span class="lineno">  879 </span>{-# INLINE ifTop #-}
<span class="lineno">  880 </span>
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>------------------------------------------------------------------------------
<span class="lineno">  883 </span>-- | Local Snap version of 'get'.
<span class="lineno">  884 </span>sget :: Snap SnapState
<span class="lineno">  885 </span><span class="decl"><span class="istickedoff">sget = Snap $ \sk _ st -&gt; sk st st</span></span>
<span class="lineno">  886 </span>{-# INLINE sget #-}
<span class="lineno">  887 </span>
<span class="lineno">  888 </span>
<span class="lineno">  889 </span>------------------------------------------------------------------------------
<span class="lineno">  890 </span>-- | Local Snap monad version of 'modify'.
<span class="lineno">  891 </span>smodify :: (SnapState -&gt; SnapState) -&gt; Snap ()
<span class="lineno">  892 </span><span class="decl"><span class="istickedoff">smodify f = Snap $ \sk _ st -&gt; sk () (f st)</span></span>
<span class="lineno">  893 </span>{-# INLINE smodify #-}
<span class="lineno">  894 </span>
<span class="lineno">  895 </span>
<span class="lineno">  896 </span>------------------------------------------------------------------------------
<span class="lineno">  897 </span>-- | Grabs the 'Request' object out of the 'Snap' monad.
<span class="lineno">  898 </span>--
<span class="lineno">  899 </span>-- Example:
<span class="lineno">  900 </span>--
<span class="lineno">  901 </span>-- @
<span class="lineno">  902 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  903 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  904 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  905 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  906 </span>-- ghci&gt; T.runHandler r ('writeBS' . 'rqURI' =\&lt;\&lt; 'getRequest')
<span class="lineno">  907 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  908 </span>-- server: Snap\/test
<span class="lineno">  909 </span>-- date: Sat, 02 Aug 2014 07:51:54 GMT
<span class="lineno">  910 </span>--
<span class="lineno">  911 </span>-- \/foo\/bar
<span class="lineno">  912 </span>-- @
<span class="lineno">  913 </span>getRequest :: MonadSnap m =&gt; m Request
<span class="lineno">  914 </span><span class="decl"><span class="istickedoff">getRequest = liftSnap $ liftM _snapRequest sget</span></span>
<span class="lineno">  915 </span>{-# INLINE getRequest #-}
<span class="lineno">  916 </span>
<span class="lineno">  917 </span>
<span class="lineno">  918 </span>------------------------------------------------------------------------------
<span class="lineno">  919 </span>-- | Grabs something out of the 'Request' object, using the given projection
<span class="lineno">  920 </span>-- function. See 'gets'.
<span class="lineno">  921 </span>--
<span class="lineno">  922 </span>-- Example:
<span class="lineno">  923 </span>--
<span class="lineno">  924 </span>-- @
<span class="lineno">  925 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  926 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  927 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  928 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  929 </span>-- ghci&gt; T.runHandler r ('writeBS' =\&lt;\&lt; 'getsRequest' 'rqURI')
<span class="lineno">  930 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  931 </span>-- server: Snap\/test
<span class="lineno">  932 </span>-- date: Sat, 02 Aug 2014 07:51:54 GMT
<span class="lineno">  933 </span>--
<span class="lineno">  934 </span>-- \/foo\/bar
<span class="lineno">  935 </span>-- @
<span class="lineno">  936 </span>getsRequest :: MonadSnap m =&gt; (Request -&gt; a) -&gt; m a
<span class="lineno">  937 </span><span class="decl"><span class="istickedoff">getsRequest f = liftSnap $ liftM (f . _snapRequest) sget</span></span>
<span class="lineno">  938 </span>{-# INLINE getsRequest #-}
<span class="lineno">  939 </span>
<span class="lineno">  940 </span>
<span class="lineno">  941 </span>------------------------------------------------------------------------------
<span class="lineno">  942 </span>-- | Grabs the 'Response' object out of the 'Snap' monad.
<span class="lineno">  943 </span>--
<span class="lineno">  944 </span>-- Example:
<span class="lineno">  945 </span>--
<span class="lineno">  946 </span>-- @
<span class="lineno">  947 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  948 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  949 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  950 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  951 </span>-- ghci&gt; T.runHandler r ('writeBS' . 'rspStatusReason' =\&lt;\&lt; 'getResponse')
<span class="lineno">  952 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  953 </span>-- server: Snap\/test
<span class="lineno">  954 </span>-- date: Sat, 02 Aug 2014 15:06:00 GMT
<span class="lineno">  955 </span>--
<span class="lineno">  956 </span>-- OK
<span class="lineno">  957 </span>-- @
<span class="lineno">  958 </span>getResponse :: MonadSnap m =&gt; m Response
<span class="lineno">  959 </span><span class="decl"><span class="istickedoff">getResponse = liftSnap $ liftM _snapResponse sget</span></span>
<span class="lineno">  960 </span>{-# INLINE getResponse #-}
<span class="lineno">  961 </span>
<span class="lineno">  962 </span>
<span class="lineno">  963 </span>------------------------------------------------------------------------------
<span class="lineno">  964 </span>-- | Grabs something out of the 'Response' object, using the given projection
<span class="lineno">  965 </span>-- function. See 'gets'.
<span class="lineno">  966 </span>--
<span class="lineno">  967 </span>-- Example:
<span class="lineno">  968 </span>--
<span class="lineno">  969 </span>-- @
<span class="lineno">  970 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  971 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  972 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  973 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  974 </span>-- ghci&gt; T.runHandler r ('writeBS' =\&lt;\&lt; 'getsResponse' 'rspStatusReason')
<span class="lineno">  975 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  976 </span>-- server: Snap\/test
<span class="lineno">  977 </span>-- date: Wed, 06 Aug 2014 13:35:45 GMT
<span class="lineno">  978 </span>--
<span class="lineno">  979 </span>-- OK
<span class="lineno">  980 </span>-- @
<span class="lineno">  981 </span>getsResponse :: MonadSnap m =&gt; (Response -&gt; a) -&gt; m a
<span class="lineno">  982 </span><span class="decl"><span class="istickedoff">getsResponse f = liftSnap $ liftM (f . _snapResponse) sget</span></span>
<span class="lineno">  983 </span>{-# INLINE getsResponse #-}
<span class="lineno">  984 </span>
<span class="lineno">  985 </span>
<span class="lineno">  986 </span>------------------------------------------------------------------------------
<span class="lineno">  987 </span>-- | Puts a new 'Response' object into the 'Snap' monad.
<span class="lineno">  988 </span>--
<span class="lineno">  989 </span>-- Example:
<span class="lineno">  990 </span>--
<span class="lineno">  991 </span>-- @
<span class="lineno">  992 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  993 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  994 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  995 </span>-- ghci&gt; let rsp = 'setResponseCode' 404 'emptyResponse'
<span class="lineno">  996 </span>-- ghci&gt; let req = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  997 </span>-- ghci&gt; T.runHandler req ('putResponse' rsp)
<span class="lineno">  998 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  999 </span>-- server: Snap\/test
<span class="lineno"> 1000 </span>-- date: Wed, 06 Aug 2014 13:59:58 GMT
<span class="lineno"> 1001 </span>--
<span class="lineno"> 1002 </span>--
<span class="lineno"> 1003 </span>-- @
<span class="lineno"> 1004 </span>putResponse :: MonadSnap m =&gt; Response -&gt; m ()
<span class="lineno"> 1005 </span><span class="decl"><span class="istickedoff">putResponse r = liftSnap $ smodify $ \ss -&gt; ss { _snapResponse = r }</span></span>
<span class="lineno"> 1006 </span>{-# INLINE putResponse #-}
<span class="lineno"> 1007 </span>
<span class="lineno"> 1008 </span>
<span class="lineno"> 1009 </span>------------------------------------------------------------------------------
<span class="lineno"> 1010 </span>-- | Puts a new 'Request' object into the 'Snap' monad.
<span class="lineno"> 1011 </span>-- Example:
<span class="lineno"> 1012 </span>--
<span class="lineno"> 1013 </span>-- @
<span class="lineno"> 1014 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1015 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1016 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1017 </span>-- ghci&gt; :{
<span class="lineno"> 1018 </span>-- ghci| let hndlr = do rq \&lt;- T.buildRequest (T.get \&quot;\/bar\/foo\&quot; M.empty)
<span class="lineno"> 1019 </span>-- ghci|                'putRequest' rq
<span class="lineno"> 1020 </span>-- ghci|                uri\' \&lt;- 'getsRequest' 'rqURI'
<span class="lineno"> 1021 </span>-- ghci|                'writeBS' uri\'
<span class="lineno"> 1022 </span>-- ghci| :}
<span class="lineno"> 1023 </span>-- ghci&gt; T.runHandler (T.get \&quot;\/foo\/bar\&quot; M.empty) hndlr
<span class="lineno"> 1024 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1025 </span>-- server: Snap\/test
<span class="lineno"> 1026 </span>-- date: Wed, 06 Aug 2014 15:13:46 GMT
<span class="lineno"> 1027 </span>--
<span class="lineno"> 1028 </span>-- \/bar\/foo
<span class="lineno"> 1029 </span>-- @
<span class="lineno"> 1030 </span>putRequest :: MonadSnap m =&gt; Request -&gt; m ()
<span class="lineno"> 1031 </span><span class="decl"><span class="istickedoff">putRequest r = liftSnap $ smodify $ \ss -&gt; ss { _snapRequest = r }</span></span>
<span class="lineno"> 1032 </span>{-# INLINE putRequest #-}
<span class="lineno"> 1033 </span>
<span class="lineno"> 1034 </span>
<span class="lineno"> 1035 </span>------------------------------------------------------------------------------
<span class="lineno"> 1036 </span>-- | Modifies the 'Request' object stored in a 'Snap' monad.
<span class="lineno"> 1037 </span>-- Example:
<span class="lineno"> 1038 </span>--
<span class="lineno"> 1039 </span>-- @
<span class="lineno"> 1040 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1041 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1042 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1043 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1044 </span>-- ghci&gt; r\' \&lt;- T.buildRequest $ T.get \&quot;\/bar\/foo\&quot; M.empty
<span class="lineno"> 1045 </span>-- ghci&gt; T.runHandler r ('modifyRequest' (const r\') &gt;&gt; 'getsRequest' 'rqURI' &gt;&gt;= 'writeBS')
<span class="lineno"> 1046 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1047 </span>-- server: Snap\/test
<span class="lineno"> 1048 </span>-- date: Wed, 06 Aug 2014 15:24:25 GMT
<span class="lineno"> 1049 </span>--
<span class="lineno"> 1050 </span>-- \/bar\/foo
<span class="lineno"> 1051 </span>-- @
<span class="lineno"> 1052 </span>modifyRequest :: MonadSnap m =&gt; (Request -&gt; Request) -&gt; m ()
<span class="lineno"> 1053 </span><span class="decl"><span class="istickedoff">modifyRequest f = liftSnap $</span>
<span class="lineno"> 1054 </span><span class="spaces">    </span><span class="istickedoff">smodify $ \ss -&gt; ss { _snapRequest = f $ _snapRequest ss }</span></span>
<span class="lineno"> 1055 </span>{-# INLINE modifyRequest #-}
<span class="lineno"> 1056 </span>
<span class="lineno"> 1057 </span>
<span class="lineno"> 1058 </span>------------------------------------------------------------------------------
<span class="lineno"> 1059 </span>-- | Modifes the 'Response' object stored in a 'Snap' monad.
<span class="lineno"> 1060 </span>-- Example:
<span class="lineno"> 1061 </span>--
<span class="lineno"> 1062 </span>-- @
<span class="lineno"> 1063 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1064 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1065 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1066 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1067 </span>-- ghci&gt; T.runHandler r ('modifyResponse' $ 'setResponseCode' 404)
<span class="lineno"> 1068 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno"> 1069 </span>-- server: Snap\/test
<span class="lineno"> 1070 </span>-- date: Wed, 06 Aug 2014 15:27:11 GMT
<span class="lineno"> 1071 </span>--
<span class="lineno"> 1072 </span>--
<span class="lineno"> 1073 </span>-- @
<span class="lineno"> 1074 </span>modifyResponse :: MonadSnap m =&gt; (Response -&gt; Response) -&gt; m ()
<span class="lineno"> 1075 </span><span class="decl"><span class="istickedoff">modifyResponse f = liftSnap $</span>
<span class="lineno"> 1076 </span><span class="spaces">     </span><span class="istickedoff">smodify $ \ss -&gt; ss { _snapResponse = f $ _snapResponse ss }</span></span>
<span class="lineno"> 1077 </span>{-# INLINE modifyResponse #-}
<span class="lineno"> 1078 </span>
<span class="lineno"> 1079 </span>
<span class="lineno"> 1080 </span>------------------------------------------------------------------------------
<span class="lineno"> 1081 </span>-- | Performs a redirect by setting the @Location@ header to the given target
<span class="lineno"> 1082 </span>-- URL/path and the status code to 302 in the 'Response' object stored in a
<span class="lineno"> 1083 </span>-- 'Snap' monad. Note that the target URL is not validated in any way.
<span class="lineno"> 1084 </span>-- Consider using 'redirect'' instead, which allows you to choose the correct
<span class="lineno"> 1085 </span>-- status code.
<span class="lineno"> 1086 </span>--
<span class="lineno"> 1087 </span>-- Example:
<span class="lineno"> 1088 </span>--
<span class="lineno"> 1089 </span>-- @
<span class="lineno"> 1090 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1091 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1092 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1093 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1094 </span>-- ghci&gt; T.runHandler r ('redirect' \&quot;http:\/\/snapframework.com\&quot;)
<span class="lineno"> 1095 </span>-- HTTP\/1.1 302 Found
<span class="lineno"> 1096 </span>-- content-length: 0
<span class="lineno"> 1097 </span>-- location: http:\/\/snapframework.com
<span class="lineno"> 1098 </span>-- server: Snap\/test
<span class="lineno"> 1099 </span>-- date: Thu, 07 Aug 2014 08:52:11 GMT
<span class="lineno"> 1100 </span>-- Content-Length: 0
<span class="lineno"> 1101 </span>--
<span class="lineno"> 1102 </span>--
<span class="lineno"> 1103 </span>-- @
<span class="lineno"> 1104 </span>redirect :: MonadSnap m =&gt; ByteString -&gt; m a
<span class="lineno"> 1105 </span><span class="decl"><span class="istickedoff">redirect target = redirect' target 302</span></span>
<span class="lineno"> 1106 </span>{-# INLINE redirect #-}
<span class="lineno"> 1107 </span>
<span class="lineno"> 1108 </span>
<span class="lineno"> 1109 </span>------------------------------------------------------------------------------
<span class="lineno"> 1110 </span>-- | Performs a redirect by setting the @Location@ header to the given target
<span class="lineno"> 1111 </span>-- URL/path and the status code (should be one of 301, 302, 303 or 307) in the
<span class="lineno"> 1112 </span>-- 'Response' object stored in a 'Snap' monad. Note that the target URL is not
<span class="lineno"> 1113 </span>-- validated in any way.
<span class="lineno"> 1114 </span>--
<span class="lineno"> 1115 </span>-- Example:
<span class="lineno"> 1116 </span>--
<span class="lineno"> 1117 </span>-- @
<span class="lineno"> 1118 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1119 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1120 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1121 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1122 </span>-- ghci&gt; T.runHandler r ('redirect'' \&quot;http:\/\/snapframework.com\&quot; 301)
<span class="lineno"> 1123 </span>-- HTTP\/1.1 307 Temporary Redirect
<span class="lineno"> 1124 </span>-- content-length: 0
<span class="lineno"> 1125 </span>-- location: http:\/\/snapframework.com
<span class="lineno"> 1126 </span>-- server: Snap\/test
<span class="lineno"> 1127 </span>-- date: Thu, 07 Aug 2014 08:55:51 GMT
<span class="lineno"> 1128 </span>-- Content-Length: 0
<span class="lineno"> 1129 </span>--
<span class="lineno"> 1130 </span>--
<span class="lineno"> 1131 </span>-- @
<span class="lineno"> 1132 </span>redirect' :: MonadSnap m =&gt; ByteString -&gt; Int -&gt; m a
<span class="lineno"> 1133 </span><span class="decl"><span class="istickedoff">redirect' target status = do</span>
<span class="lineno"> 1134 </span><span class="spaces">    </span><span class="istickedoff">r &lt;- getResponse</span>
<span class="lineno"> 1135 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1136 </span><span class="spaces">    </span><span class="istickedoff">finishWith</span>
<span class="lineno"> 1137 </span><span class="spaces">        </span><span class="istickedoff">$ setResponseCode status</span>
<span class="lineno"> 1138 </span><span class="spaces">        </span><span class="istickedoff">$ setContentLength 0</span>
<span class="lineno"> 1139 </span><span class="spaces">        </span><span class="istickedoff">$ modifyResponseBody (const $ return . id)</span>
<span class="lineno"> 1140 </span><span class="spaces">        </span><span class="istickedoff">$ setHeader &quot;Location&quot; target r</span></span>
<span class="lineno"> 1141 </span>
<span class="lineno"> 1142 </span>{-# INLINE redirect' #-}
<span class="lineno"> 1143 </span>
<span class="lineno"> 1144 </span>
<span class="lineno"> 1145 </span>------------------------------------------------------------------------------
<span class="lineno"> 1146 </span>-- | Log an error message in the 'Snap' monad.
<span class="lineno"> 1147 </span>--
<span class="lineno"> 1148 </span>-- Example:
<span class="lineno"> 1149 </span>--
<span class="lineno"> 1150 </span>-- @
<span class="lineno"> 1151 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1152 </span>-- ghci&gt; 'runSnap' ('logError' \&quot;fatal error!\&quot;) ('error' . B8.unpack) undefined undefined
<span class="lineno"> 1153 </span>-- *** Exception: fatal error!
<span class="lineno"> 1154 </span>-- @
<span class="lineno"> 1155 </span>logError :: MonadSnap m =&gt; ByteString -&gt; m ()
<span class="lineno"> 1156 </span><span class="decl"><span class="istickedoff">logError s = liftSnap $ Snap $ \sk _ st -&gt; do</span>
<span class="lineno"> 1157 </span><span class="spaces">    </span><span class="istickedoff">_snapLogError st s</span>
<span class="lineno"> 1158 </span><span class="spaces">    </span><span class="istickedoff">sk () st</span></span>
<span class="lineno"> 1159 </span>{-# INLINE logError #-}
<span class="lineno"> 1160 </span>
<span class="lineno"> 1161 </span>
<span class="lineno"> 1162 </span>------------------------------------------------------------------------------
<span class="lineno"> 1163 </span>-- | Run the given stream procedure, adding its output to the 'Response' stored
<span class="lineno"> 1164 </span>-- in the 'Snap' monad state.
<span class="lineno"> 1165 </span>--
<span class="lineno"> 1166 </span>-- Example:
<span class="lineno"> 1167 </span>--
<span class="lineno"> 1168 </span>-- @
<span class="lineno"> 1169 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1170 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1171 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1172 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Builder&quot; as B
<span class="lineno"> 1173 </span>-- ghci&gt; import qualified &quot;System.IO.Streams&quot; as Streams
<span class="lineno"> 1174 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1175 </span>-- ghci&gt; :{
<span class="lineno"> 1176 </span>-- ghci| let f str = do {
<span class="lineno"> 1177 </span>-- ghci|   Streams.write (Just $ B.byteString \&quot;Hello, streams world\&quot;) str;
<span class="lineno"> 1178 </span>-- ghci|   return str }
<span class="lineno"> 1179 </span>-- ghci| :}
<span class="lineno"> 1180 </span>-- ghci&gt; T.runHandler r ('addToOutput' f)
<span class="lineno"> 1181 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1182 </span>-- server: Snap\/test
<span class="lineno"> 1183 </span>-- date: Wed, 06 Aug 2014 17:55:47 GMT
<span class="lineno"> 1184 </span>--
<span class="lineno"> 1185 </span>-- Hello, streams world
<span class="lineno"> 1186 </span>-- @
<span class="lineno"> 1187 </span>addToOutput :: MonadSnap m
<span class="lineno"> 1188 </span>            =&gt; (OutputStream Builder -&gt; IO (OutputStream Builder))
<span class="lineno"> 1189 </span>                    -- ^ output to add
<span class="lineno"> 1190 </span>            -&gt; m ()
<span class="lineno"> 1191 </span><span class="decl"><span class="istickedoff">addToOutput enum = modifyResponse $ modifyResponseBody (c enum)</span>
<span class="lineno"> 1192 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1193 </span><span class="spaces">    </span><span class="istickedoff">c a b = \out -&gt; b out &gt;&gt;= a</span></span>
<span class="lineno"> 1194 </span>
<span class="lineno"> 1195 </span>------------------------------------------------------------------------------
<span class="lineno"> 1196 </span>-- | Adds the given 'Builder' to the body of the 'Response' stored in the
<span class="lineno"> 1197 </span>-- | 'Snap' monad state.
<span class="lineno"> 1198 </span>--
<span class="lineno"> 1199 </span>-- Example:
<span class="lineno"> 1200 </span>--
<span class="lineno"> 1201 </span>-- @
<span class="lineno"> 1202 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1203 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1204 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1205 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Builder&quot; as B
<span class="lineno"> 1206 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1207 </span>-- ghci&gt; T.runHandler r ('writeBuilder' $ B.byteString \&quot;Hello, world\&quot;)
<span class="lineno"> 1208 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1209 </span>-- server: Snap\/test
<span class="lineno"> 1210 </span>-- date: Wed, 06 Aug 2014 17:33:33 GMT
<span class="lineno"> 1211 </span>--
<span class="lineno"> 1212 </span>-- Hello, world
<span class="lineno"> 1213 </span>-- @
<span class="lineno"> 1214 </span>writeBuilder :: MonadSnap m =&gt; Builder -&gt; m ()
<span class="lineno"> 1215 </span><span class="decl"><span class="istickedoff">writeBuilder b = addToOutput f</span>
<span class="lineno"> 1216 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1217 </span><span class="spaces">    </span><span class="istickedoff">f str = Streams.write (Just b) str &gt;&gt; return str</span></span>
<span class="lineno"> 1218 </span>{-# INLINE writeBuilder #-}
<span class="lineno"> 1219 </span>
<span class="lineno"> 1220 </span>
<span class="lineno"> 1221 </span>------------------------------------------------------------------------------
<span class="lineno"> 1222 </span>-- | Adds the given strict 'ByteString' to the body of the 'Response' stored
<span class="lineno"> 1223 </span>-- in the 'Snap' monad state.
<span class="lineno"> 1224 </span>--
<span class="lineno"> 1225 </span>-- Warning: This function is intentionally non-strict. If any pure
<span class="lineno"> 1226 </span>-- exceptions are raised by the expression creating the 'ByteString',
<span class="lineno"> 1227 </span>-- the exception won't actually be raised within the Snap handler.
<span class="lineno"> 1228 </span>--
<span class="lineno"> 1229 </span>-- Example:
<span class="lineno"> 1230 </span>--
<span class="lineno"> 1231 </span>-- @
<span class="lineno"> 1232 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1233 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1234 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1235 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1236 </span>-- ghci&gt; T.runHandler r ('writeBS' \&quot;Hello, bytestring world\&quot;)
<span class="lineno"> 1237 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1238 </span>-- server: Snap\/test
<span class="lineno"> 1239 </span>-- date: Wed, 06 Aug 2014 17:34:27 GMT
<span class="lineno"> 1240 </span>--
<span class="lineno"> 1241 </span>-- Hello, bytestring world
<span class="lineno"> 1242 </span>-- @
<span class="lineno"> 1243 </span>writeBS :: MonadSnap m =&gt; ByteString -&gt; m ()
<span class="lineno"> 1244 </span><span class="decl"><span class="istickedoff">writeBS = writeBuilder . byteString</span></span>
<span class="lineno"> 1245 </span>{-# INLINE writeBS #-}
<span class="lineno"> 1246 </span>
<span class="lineno"> 1247 </span>
<span class="lineno"> 1248 </span>------------------------------------------------------------------------------
<span class="lineno"> 1249 </span>-- | Adds the given lazy 'L.ByteString' to the body of the 'Response' stored
<span class="lineno"> 1250 </span>-- in the 'Snap' monad state.
<span class="lineno"> 1251 </span>--
<span class="lineno"> 1252 </span>-- Warning: This function is intentionally non-strict. If any pure
<span class="lineno"> 1253 </span>-- exceptions are raised by the expression creating the 'ByteString',
<span class="lineno"> 1254 </span>-- the exception won't actually be raised within the Snap handler.
<span class="lineno"> 1255 </span>--
<span class="lineno"> 1256 </span>-- Example:
<span class="lineno"> 1257 </span>--
<span class="lineno"> 1258 </span>-- @
<span class="lineno"> 1259 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1260 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1261 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1262 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1263 </span>-- ghci&gt; T.runHandler r ('writeLBS' \&quot;Hello, lazy bytestring world\&quot;)
<span class="lineno"> 1264 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1265 </span>-- server: Snap\/test
<span class="lineno"> 1266 </span>-- date: Wed, 06 Aug 2014 17:35:15 GMT
<span class="lineno"> 1267 </span>--
<span class="lineno"> 1268 </span>-- Hello, lazy bytestring world
<span class="lineno"> 1269 </span>-- @
<span class="lineno"> 1270 </span>writeLBS :: MonadSnap m =&gt; L.ByteString -&gt; m ()
<span class="lineno"> 1271 </span><span class="decl"><span class="istickedoff">writeLBS = writeBuilder . lazyByteString</span></span>
<span class="lineno"> 1272 </span>{-# INLINE writeLBS #-}
<span class="lineno"> 1273 </span>
<span class="lineno"> 1274 </span>
<span class="lineno"> 1275 </span>------------------------------------------------------------------------------
<span class="lineno"> 1276 </span>-- | Adds the given strict 'T.Text' to the body of the 'Response' stored in
<span class="lineno"> 1277 </span>-- the 'Snap' monad state.
<span class="lineno"> 1278 </span>--
<span class="lineno"> 1279 </span>-- Warning: This function is intentionally non-strict. If any pure
<span class="lineno"> 1280 </span>-- exceptions are raised by the expression creating the 'ByteString',
<span class="lineno"> 1281 </span>-- the exception won't actually be raised within the Snap handler.
<span class="lineno"> 1282 </span>--
<span class="lineno"> 1283 </span>-- Example:
<span class="lineno"> 1284 </span>--
<span class="lineno"> 1285 </span>-- @
<span class="lineno"> 1286 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1287 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1288 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1289 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1290 </span>-- ghci&gt; T.runHandler r ('writeText' \&quot;Hello, text world\&quot;)
<span class="lineno"> 1291 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1292 </span>-- server: Snap\/test
<span class="lineno"> 1293 </span>-- date: Wed, 06 Aug 2014 17:36:38 GMT
<span class="lineno"> 1294 </span>--
<span class="lineno"> 1295 </span>-- Hello, text world
<span class="lineno"> 1296 </span>-- @
<span class="lineno"> 1297 </span>writeText :: MonadSnap m =&gt; T.Text -&gt; m ()
<span class="lineno"> 1298 </span><span class="decl"><span class="istickedoff">writeText = writeBS . T.encodeUtf8</span></span>
<span class="lineno"> 1299 </span>  -- it's inefficient, but we don't have bytestring builder text functions for
<span class="lineno"> 1300 </span>  -- 0.9-era bytestring
<span class="lineno"> 1301 </span>{-# INLINE writeText #-}
<span class="lineno"> 1302 </span>
<span class="lineno"> 1303 </span>
<span class="lineno"> 1304 </span>------------------------------------------------------------------------------
<span class="lineno"> 1305 </span>-- | Adds the given lazy 'LT.Text' to the body of the 'Response' stored in the
<span class="lineno"> 1306 </span>-- 'Snap' monad state.
<span class="lineno"> 1307 </span>--
<span class="lineno"> 1308 </span>-- Warning: This function is intentionally non-strict. If any pure
<span class="lineno"> 1309 </span>-- exceptions are raised by the expression creating the 'ByteString',
<span class="lineno"> 1310 </span>-- the exception won't actually be raised within the Snap handler.
<span class="lineno"> 1311 </span>--
<span class="lineno"> 1312 </span>-- Example:
<span class="lineno"> 1313 </span>--
<span class="lineno"> 1314 </span>-- @
<span class="lineno"> 1315 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1316 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1317 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1318 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1319 </span>-- ghci&gt; T.runHandler r ('writeLazyText' \&quot;Hello, lazy text world\&quot;)
<span class="lineno"> 1320 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1321 </span>-- server: Snap\/test
<span class="lineno"> 1322 </span>-- date: Wed, 06 Aug 2014 17:37:41 GMT
<span class="lineno"> 1323 </span>--
<span class="lineno"> 1324 </span>-- Hello, lazy text world
<span class="lineno"> 1325 </span>-- @
<span class="lineno"> 1326 </span>writeLazyText :: MonadSnap m =&gt; LT.Text -&gt; m ()
<span class="lineno"> 1327 </span><span class="decl"><span class="istickedoff">writeLazyText = writeLBS . LT.encodeUtf8</span></span>
<span class="lineno"> 1328 </span>{-# INLINE writeLazyText #-}
<span class="lineno"> 1329 </span>
<span class="lineno"> 1330 </span>
<span class="lineno"> 1331 </span>------------------------------------------------------------------------------
<span class="lineno"> 1332 </span>-- | Sets the output to be the contents of the specified file.
<span class="lineno"> 1333 </span>--
<span class="lineno"> 1334 </span>-- Calling 'sendFile' will overwrite any output queued to be sent in the
<span class="lineno"> 1335 </span>-- 'Response'. If the response body is not modified after the call to
<span class="lineno"> 1336 </span>-- 'sendFile', Snap will use the efficient @sendfile()@ system call on
<span class="lineno"> 1337 </span>-- platforms that support it.
<span class="lineno"> 1338 </span>--
<span class="lineno"> 1339 </span>-- If the response body is modified (using 'modifyResponseBody'), the file
<span class="lineno"> 1340 </span>-- will be read using @mmap()@.
<span class="lineno"> 1341 </span>--
<span class="lineno"> 1342 </span>-- Example:
<span class="lineno"> 1343 </span>--
<span class="lineno"> 1344 </span>-- @
<span class="lineno"> 1345 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1346 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1347 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1348 </span>-- ghci&gt; 'writeFile' \&quot;\/tmp\/snap-file\&quot; \&quot;Hello, sendFile world\&quot;
<span class="lineno"> 1349 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1350 </span>-- ghci&gt; T.runHandler r ('sendFile' \&quot;\/tmp\/snap-file\&quot;)
<span class="lineno"> 1351 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1352 </span>-- content-length: 21
<span class="lineno"> 1353 </span>-- server: Snap\/test
<span class="lineno"> 1354 </span>-- date: Wed, 06 Aug 2014 17:45:10 GMT
<span class="lineno"> 1355 </span>-- Content-Length: 21
<span class="lineno"> 1356 </span>--
<span class="lineno"> 1357 </span>-- Hello, sendFile world
<span class="lineno"> 1358 </span>-- @
<span class="lineno"> 1359 </span>sendFile :: (MonadSnap m) =&gt; FilePath -&gt; m ()
<span class="lineno"> 1360 </span><span class="decl"><span class="istickedoff">sendFile f = modifyResponse $ \r -&gt; r { rspBody = SendFile f Nothing }</span></span>
<span class="lineno"> 1361 </span>
<span class="lineno"> 1362 </span>
<span class="lineno"> 1363 </span>------------------------------------------------------------------------------
<span class="lineno"> 1364 </span>-- | Sets the output to be the contents of the specified file, within the
<span class="lineno"> 1365 </span>-- given (start,end) range.
<span class="lineno"> 1366 </span>--
<span class="lineno"> 1367 </span>-- Calling 'sendFilePartial' will overwrite any output queued to be sent in
<span class="lineno"> 1368 </span>-- the 'Response'. If the response body is not modified after the call to
<span class="lineno"> 1369 </span>-- 'sendFilePartial', Snap will use the efficient @sendfile()@ system call on
<span class="lineno"> 1370 </span>-- platforms that support it.
<span class="lineno"> 1371 </span>--
<span class="lineno"> 1372 </span>-- If the response body is modified (using 'modifyResponseBody'), the file
<span class="lineno"> 1373 </span>-- will be read using @mmap()@.
<span class="lineno"> 1374 </span>--
<span class="lineno"> 1375 </span>-- Example:
<span class="lineno"> 1376 </span>--
<span class="lineno"> 1377 </span>-- @
<span class="lineno"> 1378 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1379 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1380 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1381 </span>-- ghci&gt; 'writeFile' \&quot;\/tmp\/snap-file\&quot; \&quot;Hello, sendFilePartial world\&quot;
<span class="lineno"> 1382 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1383 </span>-- ghci&gt; T.runHandler r ('sendFilePartial' \&quot;\/tmp\/snap-file\&quot; (7, 28))
<span class="lineno"> 1384 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1385 </span>-- content-length: 21
<span class="lineno"> 1386 </span>-- server: Snap\/test
<span class="lineno"> 1387 </span>-- date: Wed, 06 Aug 2014 17:47:20 GMT
<span class="lineno"> 1388 </span>-- Content-Length: 21
<span class="lineno"> 1389 </span>--
<span class="lineno"> 1390 </span>-- sendFilePartial world
<span class="lineno"> 1391 </span>-- @
<span class="lineno"> 1392 </span>sendFilePartial :: (MonadSnap m) =&gt; FilePath -&gt; (Word64, Word64) -&gt; m ()
<span class="lineno"> 1393 </span><span class="decl"><span class="istickedoff">sendFilePartial f rng = modifyResponse $ \r -&gt;</span>
<span class="lineno"> 1394 </span><span class="spaces">                        </span><span class="istickedoff">r { rspBody = SendFile f (Just rng) }</span></span>
<span class="lineno"> 1395 </span>
<span class="lineno"> 1396 </span>
<span class="lineno"> 1397 </span>------------------------------------------------------------------------------
<span class="lineno"> 1398 </span>-- | Runs a 'Snap' action with a locally-modified 'Request' state
<span class="lineno"> 1399 </span>-- object. The 'Request' object in the Snap monad state after the call
<span class="lineno"> 1400 </span>-- to localRequest will be unchanged.
<span class="lineno"> 1401 </span>-- Example:
<span class="lineno"> 1402 </span>--
<span class="lineno"> 1403 </span>-- @
<span class="lineno"> 1404 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1405 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1406 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1407 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1408 </span>-- ghci&gt; r\' \&lt;- T.buildRequest $ T.get \&quot;\/bar\/foo\&quot; M.empty
<span class="lineno"> 1409 </span>-- ghci&gt; let printRqURI = 'getsRequest' 'rqURI' &gt;&gt;= 'writeBS' &gt;&gt; 'writeBS' \&quot;\\n\&quot;
<span class="lineno"> 1410 </span>-- ghci&gt; T.runHandler r (printRqURI &gt;&gt; 'localRequest' (const r\') printRqURI)
<span class="lineno"> 1411 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1412 </span>-- server: Snap\/test
<span class="lineno"> 1413 </span>-- date: Wed, 06 Aug 2014 15:34:12 GMT
<span class="lineno"> 1414 </span>--
<span class="lineno"> 1415 </span>-- \/foo\/bar
<span class="lineno"> 1416 </span>-- \/bar\/foo
<span class="lineno"> 1417 </span>--
<span class="lineno"> 1418 </span>-- @
<span class="lineno"> 1419 </span>localRequest :: MonadSnap m =&gt; (Request -&gt; Request) -&gt; m a -&gt; m a
<span class="lineno"> 1420 </span><span class="decl"><span class="istickedoff">localRequest f m = do</span>
<span class="lineno"> 1421 </span><span class="spaces">    </span><span class="istickedoff">req &lt;- getRequest</span>
<span class="lineno"> 1422 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1423 </span><span class="spaces">    </span><span class="istickedoff">runAct req &lt;|&gt; (putRequest req &gt;&gt; pass)</span>
<span class="lineno"> 1424 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1425 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1426 </span><span class="spaces">    </span><span class="istickedoff">runAct req = do</span>
<span class="lineno"> 1427 </span><span class="spaces">        </span><span class="istickedoff">modifyRequest f</span>
<span class="lineno"> 1428 </span><span class="spaces">        </span><span class="istickedoff">result &lt;- m</span>
<span class="lineno"> 1429 </span><span class="spaces">        </span><span class="istickedoff">putRequest req</span>
<span class="lineno"> 1430 </span><span class="spaces">        </span><span class="istickedoff">return result</span></span>
<span class="lineno"> 1431 </span>{-# INLINE localRequest #-}
<span class="lineno"> 1432 </span>
<span class="lineno"> 1433 </span>
<span class="lineno"> 1434 </span>------------------------------------------------------------------------------
<span class="lineno"> 1435 </span>-- | Fetches the 'Request' from state and hands it to the given action.
<span class="lineno"> 1436 </span>-- Example:
<span class="lineno"> 1437 </span>--
<span class="lineno"> 1438 </span>-- @
<span class="lineno"> 1439 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1440 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1441 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1442 </span>-- ghci&gt; import &quot;Control.Monad.IO.Class&quot;
<span class="lineno"> 1443 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1444 </span>-- ghci&gt; let h = 'withRequest' (\\rq -&gt; 'liftIO' (T.requestToString rq) &gt;&gt;= 'writeBS')
<span class="lineno"> 1445 </span>-- ghci&gt; T.runHandler r h
<span class="lineno"> 1446 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1447 </span>-- server: Snap\/test
<span class="lineno"> 1448 </span>-- date: Wed, 06 Aug 2014 15:44:24 GMT
<span class="lineno"> 1449 </span>--
<span class="lineno"> 1450 </span>-- GET \/foo\/bar HTTP\/1.1
<span class="lineno"> 1451 </span>-- host: localhost
<span class="lineno"> 1452 </span>--
<span class="lineno"> 1453 </span>--
<span class="lineno"> 1454 </span>-- @
<span class="lineno"> 1455 </span>withRequest :: MonadSnap m =&gt; (Request -&gt; m a) -&gt; m a
<span class="lineno"> 1456 </span><span class="decl"><span class="istickedoff">withRequest = (getRequest &gt;&gt;=)</span></span>
<span class="lineno"> 1457 </span>{-# INLINE withRequest #-}
<span class="lineno"> 1458 </span>
<span class="lineno"> 1459 </span>
<span class="lineno"> 1460 </span>------------------------------------------------------------------------------
<span class="lineno"> 1461 </span>-- | Fetches the 'Response' from state and hands it to the given action.
<span class="lineno"> 1462 </span>-- Example:
<span class="lineno"> 1463 </span>--
<span class="lineno"> 1464 </span>-- @
<span class="lineno"> 1465 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1466 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1467 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1468 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1469 </span>-- ghci&gt; T.runHandler r ('withResponse' $ 'writeBS' . 'rspStatusReason')
<span class="lineno"> 1470 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1471 </span>-- server: Snap\/test
<span class="lineno"> 1472 </span>-- date: Wed, 06 Aug 2014 15:48:45 GMT
<span class="lineno"> 1473 </span>--
<span class="lineno"> 1474 </span>-- OK
<span class="lineno"> 1475 </span>-- @
<span class="lineno"> 1476 </span>withResponse :: MonadSnap m =&gt; (Response -&gt; m a) -&gt; m a
<span class="lineno"> 1477 </span><span class="decl"><span class="istickedoff">withResponse = (getResponse &gt;&gt;=)</span></span>
<span class="lineno"> 1478 </span>{-# INLINE withResponse #-}
<span class="lineno"> 1479 </span>
<span class="lineno"> 1480 </span>
<span class="lineno"> 1481 </span>------------------------------------------------------------------------------
<span class="lineno"> 1482 </span>-- | Modifies the 'Request' in the state to set the 'rqRemoteAddr'
<span class="lineno"> 1483 </span>-- field to the value in the X-Forwarded-For header. If the header is
<span class="lineno"> 1484 </span>-- not present, this action has no effect.
<span class="lineno"> 1485 </span>--
<span class="lineno"> 1486 </span>-- This action should be used only when working behind a reverse http
<span class="lineno"> 1487 </span>-- proxy that sets the X-Forwarded-For header. This is the only way to
<span class="lineno"> 1488 </span>-- ensure the value in the X-Forwarded-For header can be trusted.
<span class="lineno"> 1489 </span>--
<span class="lineno"> 1490 </span>-- This is provided as a filter so actions that require the remote
<span class="lineno"> 1491 </span>-- address can get it in a uniform manner. It has specifically limited
<span class="lineno"> 1492 </span>-- functionality to ensure that its transformation can be trusted,
<span class="lineno"> 1493 </span>-- when used correctly.
<span class="lineno"> 1494 </span>ipHeaderFilter :: MonadSnap m =&gt; m ()
<span class="lineno"> 1495 </span><span class="decl"><span class="istickedoff">ipHeaderFilter = ipHeaderFilter' &quot;x-forwarded-for&quot;</span></span>
<span class="lineno"> 1496 </span>
<span class="lineno"> 1497 </span>
<span class="lineno"> 1498 </span>------------------------------------------------------------------------------
<span class="lineno"> 1499 </span>-- | Modifies the 'Request' in the state to set the 'rqRemoteAddr'
<span class="lineno"> 1500 </span>-- field to the value from the header specified.  If the header
<span class="lineno"> 1501 </span>-- specified is not present, this action has no effect.
<span class="lineno"> 1502 </span>--
<span class="lineno"> 1503 </span>-- This action should be used only when working behind a reverse http
<span class="lineno"> 1504 </span>-- proxy that sets the header being looked at. This is the only way to
<span class="lineno"> 1505 </span>-- ensure the value in the header can be trusted.
<span class="lineno"> 1506 </span>--
<span class="lineno"> 1507 </span>-- This is provided as a filter so actions that require the remote
<span class="lineno"> 1508 </span>-- address can get it in a uniform manner. It has specifically limited
<span class="lineno"> 1509 </span>-- functionality to ensure that its transformation can be trusted,
<span class="lineno"> 1510 </span>-- when used correctly.
<span class="lineno"> 1511 </span>ipHeaderFilter' :: MonadSnap m =&gt; CI ByteString -&gt; m ()
<span class="lineno"> 1512 </span><span class="decl"><span class="istickedoff">ipHeaderFilter' header = do</span>
<span class="lineno"> 1513 </span><span class="spaces">    </span><span class="istickedoff">headerContents &lt;- getHeader header &lt;$&gt; getRequest</span>
<span class="lineno"> 1514 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1515 </span><span class="spaces">    </span><span class="istickedoff">let whitespace = [ ' ', '\t', '\r', '\n' ]</span>
<span class="lineno"> 1516 </span><span class="spaces">        </span><span class="istickedoff">ipChrs = '.' : &quot;0123456789&quot;</span>
<span class="lineno"> 1517 </span><span class="spaces">        </span><span class="istickedoff">trim f s = f (`elem` s)</span>
<span class="lineno"> 1518 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1519 </span><span class="spaces">        </span><span class="istickedoff">clean = trim S.takeWhile ipChrs . trim S.dropWhile whitespace</span>
<span class="lineno"> 1520 </span><span class="spaces">        </span><span class="istickedoff">setIP ip = modifyRequest $ \rq -&gt; rq { rqClientAddr = clean ip }</span>
<span class="lineno"> 1521 </span><span class="spaces">    </span><span class="istickedoff">maybe (return $! ()) setIP headerContents</span></span>
<span class="lineno"> 1522 </span>
<span class="lineno"> 1523 </span>
<span class="lineno"> 1524 </span>------------------------------------------------------------------------------
<span class="lineno"> 1525 </span>-- | This function brackets a Snap action in resource acquisition and
<span class="lineno"> 1526 </span>-- release. This is provided because MonadCatchIO's 'bracket' function
<span class="lineno"> 1527 </span>-- doesn't work properly in the case of a short-circuit return from
<span class="lineno"> 1528 </span>-- the action being bracketed.
<span class="lineno"> 1529 </span>--
<span class="lineno"> 1530 </span>-- In order to prevent confusion regarding the effects of the
<span class="lineno"> 1531 </span>-- aquisition and release actions on the Snap state, this function
<span class="lineno"> 1532 </span>-- doesn't accept Snap actions for the acquire or release actions.
<span class="lineno"> 1533 </span>--
<span class="lineno"> 1534 </span>-- This function will run the release action in all cases where the
<span class="lineno"> 1535 </span>-- acquire action succeeded.  This includes the following behaviors
<span class="lineno"> 1536 </span>-- from the bracketed Snap action.
<span class="lineno"> 1537 </span>--
<span class="lineno"> 1538 </span>-- 1. Normal completion
<span class="lineno"> 1539 </span>--
<span class="lineno"> 1540 </span>-- 2. Short-circuit completion, either from calling 'fail' or 'finishWith'
<span class="lineno"> 1541 </span>--
<span class="lineno"> 1542 </span>-- 3. An exception being thrown.
<span class="lineno"> 1543 </span>--
<span class="lineno"> 1544 </span>-- Example:
<span class="lineno"> 1545 </span>--
<span class="lineno"> 1546 </span>-- @
<span class="lineno"> 1547 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1548 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1549 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1550 </span>-- ghci&gt; let br = 'bracketSnap' (putStrLn \&quot;before\&quot;) (const $ putStrLn \&quot;after\&quot;)
<span class="lineno"> 1551 </span>-- ghci&gt; T.runHandler (T.get \&quot;/\&quot; M.empty) (br $ const $ writeBS \&quot;OK\&quot;)
<span class="lineno"> 1552 </span>-- before
<span class="lineno"> 1553 </span>-- after
<span class="lineno"> 1554 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1555 </span>-- server: Snap\/test
<span class="lineno"> 1556 </span>-- date: Thu, 07 Aug 2014 18:41:50 GMT
<span class="lineno"> 1557 </span>--
<span class="lineno"> 1558 </span>-- OK
<span class="lineno"> 1559 </span>-- @
<span class="lineno"> 1560 </span>bracketSnap :: IO a -&gt; (a -&gt; IO b) -&gt; (a -&gt; Snap c) -&gt; Snap c
<span class="lineno"> 1561 </span><span class="decl"><span class="istickedoff">bracketSnap before after thing = mask $ \restore -&gt;</span>
<span class="lineno"> 1562 </span><span class="spaces">                                 </span><span class="istickedoff">stateTToSnap $ do</span>
<span class="lineno"> 1563 </span><span class="spaces">    </span><span class="istickedoff">a &lt;- liftIO before</span>
<span class="lineno"> 1564 </span><span class="spaces">    </span><span class="istickedoff">let after' = liftIO $ after a</span>
<span class="lineno"> 1565 </span><span class="spaces">    </span><span class="istickedoff">r &lt;- snapToStateT (restore $ thing a) `onException` after'</span>
<span class="lineno"> 1566 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- after'</span>
<span class="lineno"> 1567 </span><span class="spaces">    </span><span class="istickedoff">return r</span></span>
<span class="lineno"> 1568 </span>
<span class="lineno"> 1569 </span>
<span class="lineno"> 1570 </span>------------------------------------------------------------------------------
<span class="lineno"> 1571 </span>-- | This exception is thrown if the handler you supply to 'runSnap' fails.
<span class="lineno"> 1572 </span>data NoHandlerException = NoHandlerException String
<span class="lineno"> 1573 </span>   deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff">Typeable</span></span>)
<span class="lineno"> 1574 </span>
<span class="lineno"> 1575 </span>
<span class="lineno"> 1576 </span>------------------------------------------------------------------------------
<span class="lineno"> 1577 </span>instance Show NoHandlerException where
<span class="lineno"> 1578 </span>    <span class="decl"><span class="istickedoff">show (NoHandlerException e) = &quot;No handler for request: failure was &quot; ++ e</span></span>
<span class="lineno"> 1579 </span>
<span class="lineno"> 1580 </span>
<span class="lineno"> 1581 </span>------------------------------------------------------------------------------
<span class="lineno"> 1582 </span>instance Exception NoHandlerException
<span class="lineno"> 1583 </span>
<span class="lineno"> 1584 </span>
<span class="lineno"> 1585 </span>------------------------------------------------------------------------------
<span class="lineno"> 1586 </span>-- | Terminate the HTTP session with the given exception.
<span class="lineno"> 1587 </span>--
<span class="lineno"> 1588 </span>-- Example:
<span class="lineno"> 1589 </span>--
<span class="lineno"> 1590 </span>-- @
<span class="lineno"> 1591 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1592 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1593 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1594 </span>-- ghci&gt; import qualified &quot;Control.Exception&quot; as E
<span class="lineno"> 1595 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 1596 </span>-- ghci&gt; T.runHandler r (terminateConnection $ E.AssertionFailed \&quot;Assertion failed!\&quot;)
<span class="lineno"> 1597 </span>-- *** Exception: \&lt;terminated: Assertion failed!&gt;
<span class="lineno"> 1598 </span>-- @
<span class="lineno"> 1599 </span>terminateConnection :: (Exception e, MonadSnap m) =&gt; e -&gt; m a
<span class="lineno"> 1600 </span><span class="decl"><span class="istickedoff">terminateConnection e =</span>
<span class="lineno"> 1601 </span><span class="spaces">    </span><span class="istickedoff">liftSnap $ Snap $ \_ fk -&gt; fk $ EscapeSnap $ TerminateConnection</span>
<span class="lineno"> 1602 </span><span class="spaces">                                  </span><span class="istickedoff">$ SomeException e</span></span>
<span class="lineno"> 1603 </span>
<span class="lineno"> 1604 </span>
<span class="lineno"> 1605 </span>------------------------------------------------------------------------------
<span class="lineno"> 1606 </span>-- | Terminate the HTTP session and hand control to some external handler,
<span class="lineno"> 1607 </span>-- escaping all further HTTP traffic.
<span class="lineno"> 1608 </span>--
<span class="lineno"> 1609 </span>-- The external handler takes three arguments: a function to modify the thread's
<span class="lineno"> 1610 </span>-- timeout, and a read and a write ends to the socket.
<span class="lineno"> 1611 </span>escapeHttp :: MonadSnap m =&gt;
<span class="lineno"> 1612 </span>              EscapeHttpHandler
<span class="lineno"> 1613 </span>           -&gt; m ()
<span class="lineno"> 1614 </span><span class="decl"><span class="istickedoff">escapeHttp h = liftSnap $ Snap $ \_ fk st -&gt; fk (EscapeSnap $ EscapeHttp h) st</span></span>
<span class="lineno"> 1615 </span>
<span class="lineno"> 1616 </span>
<span class="lineno"> 1617 </span>------------------------------------------------------------------------------
<span class="lineno"> 1618 </span>-- | Runs a 'Snap' monad action.
<span class="lineno"> 1619 </span>--
<span class="lineno"> 1620 </span>-- This function is mostly intended for library writers; instead of invoking
<span class="lineno"> 1621 </span>-- 'runSnap' directly, use 'Snap.Http.Server.httpServe' or
<span class="lineno"> 1622 </span>-- 'Snap.Test.runHandler' (for testing).
<span class="lineno"> 1623 </span>runSnap :: Snap a                   -- ^ Action to run.
<span class="lineno"> 1624 </span>        -&gt; (ByteString -&gt; IO ())    -- ^ Error logging action.
<span class="lineno"> 1625 </span>        -&gt; ((Int -&gt; Int) -&gt; IO ())  -- ^ Timeout action.
<span class="lineno"> 1626 </span>        -&gt; Request                  -- ^ HTTP request.
<span class="lineno"> 1627 </span>        -&gt; IO (Request, Response)
<span class="lineno"> 1628 </span><span class="decl"><span class="istickedoff">runSnap (Snap m) logerr timeoutAction req =</span>
<span class="lineno"> 1629 </span><span class="spaces">    </span><span class="istickedoff">m ok diediedie ss</span>
<span class="lineno"> 1630 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1631 </span><span class="spaces">    </span><span class="istickedoff">ok _ st = return (_snapRequest st, _snapResponse st)</span>
<span class="lineno"> 1632 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1633 </span><span class="spaces">    </span><span class="istickedoff">diediedie z !st = do</span>
<span class="lineno"> 1634 </span><span class="spaces">        </span><span class="istickedoff">resp &lt;- case z of</span>
<span class="lineno"> 1635 </span><span class="spaces">                  </span><span class="istickedoff">PassOnProcessing     -&gt; return fourohfour</span>
<span class="lineno"> 1636 </span><span class="spaces">                  </span><span class="istickedoff">(EarlyTermination x) -&gt; return x</span>
<span class="lineno"> 1637 </span><span class="spaces">                  </span><span class="istickedoff">(EscapeSnap e)       -&gt; throwIO e</span>
<span class="lineno"> 1638 </span><span class="spaces">        </span><span class="istickedoff">return (_snapRequest st, resp)</span>
<span class="lineno"> 1639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1640 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno"> 1641 </span><span class="spaces">    </span><span class="istickedoff">fourohfour = do</span>
<span class="lineno"> 1642 </span><span class="spaces">        </span><span class="istickedoff">clearContentLength                  $</span>
<span class="lineno"> 1643 </span><span class="spaces">          </span><span class="istickedoff">setResponseStatus 404 &quot;Not Found&quot; $</span>
<span class="lineno"> 1644 </span><span class="spaces">          </span><span class="istickedoff">setResponseBody enum404           $</span>
<span class="lineno"> 1645 </span><span class="spaces">          </span><span class="istickedoff">emptyResponse</span>
<span class="lineno"> 1646 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1647 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno"> 1648 </span><span class="spaces">    </span><span class="istickedoff">enum404 out = do</span>
<span class="lineno"> 1649 </span><span class="spaces">        </span><span class="istickedoff">is &lt;- Streams.fromList html</span>
<span class="lineno"> 1650 </span><span class="spaces">        </span><span class="istickedoff">Streams.connect is out</span>
<span class="lineno"> 1651 </span><span class="spaces">        </span><span class="istickedoff">return out</span>
<span class="lineno"> 1652 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1653 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno"> 1654 </span><span class="spaces">    </span><span class="istickedoff">html = map byteString [ &quot;&lt;!DOCTYPE html&gt;\n&quot;</span>
<span class="lineno"> 1655 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;&lt;html&gt;\n&quot;</span>
<span class="lineno"> 1656 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;&lt;head&gt;\n&quot;</span>
<span class="lineno"> 1657 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;&lt;title&gt;Not found&lt;/title&gt;\n&quot;</span>
<span class="lineno"> 1658 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;&lt;/head&gt;\n&quot;</span>
<span class="lineno"> 1659 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;&lt;body&gt;\n&quot;</span>
<span class="lineno"> 1660 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;&lt;code&gt;No handler accepted \&quot;&quot;</span>
<span class="lineno"> 1661 </span><span class="spaces">                          </span><span class="istickedoff">, rqURI req</span>
<span class="lineno"> 1662 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;\&quot;&lt;/code&gt;\n&lt;/body&gt;&lt;/html&gt;&quot;</span>
<span class="lineno"> 1663 </span><span class="spaces">                          </span><span class="istickedoff">]</span>
<span class="lineno"> 1664 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1665 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno"> 1666 </span><span class="spaces">    </span><span class="istickedoff">dresp = emptyResponse</span>
<span class="lineno"> 1667 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1668 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno"> 1669 </span><span class="spaces">    </span><span class="istickedoff">ss = SnapState req dresp logerr timeoutAction</span></span>
<span class="lineno"> 1670 </span>{-# INLINE runSnap #-}
<span class="lineno"> 1671 </span>
<span class="lineno"> 1672 </span>
<span class="lineno"> 1673 </span>
<span class="lineno"> 1674 </span>--------------------------------------------------------------------------
<span class="lineno"> 1675 </span>-- | Post-process a finalized HTTP response:
<span class="lineno"> 1676 </span>--
<span class="lineno"> 1677 </span>-- * fixup content-length header
<span class="lineno"> 1678 </span>-- * properly handle 204/304 responses
<span class="lineno"> 1679 </span>-- * if request was HEAD, remove response body
<span class="lineno"> 1680 </span>--
<span class="lineno"> 1681 </span>-- Note that we do NOT deal with transfer-encoding: chunked or &quot;connection:
<span class="lineno"> 1682 </span>-- close&quot; here.
<span class="lineno"> 1683 </span>--
<span class="lineno"> 1684 </span>{-# INLINE fixupResponse #-}
<span class="lineno"> 1685 </span>fixupResponse :: Request -&gt; Response -&gt; IO Response
<span class="lineno"> 1686 </span><span class="decl"><span class="istickedoff">fixupResponse req rsp = {-# SCC &quot;fixupResponse&quot; #-} do</span>
<span class="lineno"> 1687 </span><span class="spaces">    </span><span class="istickedoff">rsp' &lt;- case rspBody rsp of</span>
<span class="lineno"> 1688 </span><span class="spaces">              </span><span class="istickedoff">(Stream _)                -&gt; return rsp</span>
<span class="lineno"> 1689 </span><span class="spaces">              </span><span class="istickedoff">(SendFile f Nothing)      -&gt; setFileSize f rsp</span>
<span class="lineno"> 1690 </span><span class="spaces">              </span><span class="istickedoff">(SendFile _ (Just (s,e))) -&gt; return $! setContentLength (e-s) rsp</span>
<span class="lineno"> 1691 </span><span class="spaces">    </span><span class="istickedoff">let !cl = if noBody then Nothing else rspContentLength rsp'</span>
<span class="lineno"> 1692 </span><span class="spaces">    </span><span class="istickedoff">let rsp'' = if noBody</span>
<span class="lineno"> 1693 </span><span class="spaces">                  </span><span class="istickedoff">then rsp' { rspBody          = Stream $ return . id</span>
<span class="lineno"> 1694 </span><span class="spaces">                            </span><span class="istickedoff">, rspContentLength = Nothing</span>
<span class="lineno"> 1695 </span><span class="spaces">                            </span><span class="istickedoff">}</span>
<span class="lineno"> 1696 </span><span class="spaces">                  </span><span class="istickedoff">else rsp'</span>
<span class="lineno"> 1697 </span><span class="spaces">    </span><span class="istickedoff">return $! updateHeaders (H.fromList . addCL cl . fixup . H.toList) rsp''</span>
<span class="lineno"> 1698 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1699 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1700 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno"> 1701 </span><span class="spaces">    </span><span class="istickedoff">addCL Nothing xs   = xs</span>
<span class="lineno"> 1702 </span><span class="spaces">    </span><span class="istickedoff">addCL (Just cl) xs = (&quot;content-length&quot;, word64ToByteString cl):xs</span>
<span class="lineno"> 1703 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1704 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno"> 1705 </span><span class="spaces">    </span><span class="istickedoff">setFileSize :: FilePath -&gt; Response -&gt; IO Response</span>
<span class="lineno"> 1706 </span><span class="spaces">    </span><span class="istickedoff">setFileSize fp r = {-# SCC &quot;setFileSize&quot; #-} do</span>
<span class="lineno"> 1707 </span><span class="spaces">        </span><span class="istickedoff">fs &lt;- liftM fromIntegral $ getFileSize fp</span>
<span class="lineno"> 1708 </span><span class="spaces">        </span><span class="istickedoff">return $! r { rspContentLength = Just fs }</span>
<span class="lineno"> 1709 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1710 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------------------------</span>
<span class="lineno"> 1711 </span><span class="spaces">    </span><span class="istickedoff">getFileSize :: FilePath -&gt; IO FileOffset</span>
<span class="lineno"> 1712 </span><span class="spaces">    </span><span class="istickedoff">getFileSize fp = liftM fileSize $ getFileStatus fp</span>
<span class="lineno"> 1713 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1714 </span><span class="spaces">    </span><span class="istickedoff">code   = rspStatus rsp</span>
<span class="lineno"> 1715 </span><span class="spaces">    </span><span class="istickedoff">noBody = code == 204 || code == 304 || rqMethod req == HEAD</span>
<span class="lineno"> 1716 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1717 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------------------------</span>
<span class="lineno"> 1718 </span><span class="spaces">    </span><span class="istickedoff">fixup [] = []</span>
<span class="lineno"> 1719 </span><span class="spaces">    </span><span class="istickedoff">fixup ((&quot;date&quot;,_):xs)           = fixup xs</span>
<span class="lineno"> 1720 </span><span class="spaces">    </span><span class="istickedoff">fixup ((&quot;content-length&quot;,_):xs) = fixup xs</span>
<span class="lineno"> 1721 </span><span class="spaces">    </span><span class="istickedoff">fixup (x@(&quot;transfer-encoding&quot;,_):xs) = if noBody</span>
<span class="lineno"> 1722 </span><span class="spaces">                                             </span><span class="istickedoff">then fixup xs</span>
<span class="lineno"> 1723 </span><span class="spaces">                                             </span><span class="istickedoff">else x : fixup xs</span>
<span class="lineno"> 1724 </span><span class="spaces">    </span><span class="istickedoff">fixup (x:xs) = x : fixup xs</span></span>
<span class="lineno"> 1725 </span>
<span class="lineno"> 1726 </span>
<span class="lineno"> 1727 </span>------------------------------------------------------------------------------
<span class="lineno"> 1728 </span>-- This number code stolen and massaged from Bryan's blog post:
<span class="lineno"> 1729 </span>-- http://www.serpentine.com/blog/2013/03/20/whats-good-for-c-is-good-for-haskell/
<span class="lineno"> 1730 </span>
<span class="lineno"> 1731 </span>{-# INLINE countDigits #-}
<span class="lineno"> 1732 </span>countDigits :: Word64 -&gt; Int
<span class="lineno"> 1733 </span><span class="decl"><span class="istickedoff">countDigits v0 = go 1 v0</span>
<span class="lineno"> 1734 </span><span class="spaces">  </span><span class="istickedoff">where go !k v</span>
<span class="lineno"> 1735 </span><span class="spaces">           </span><span class="istickedoff">| v &lt; 10    = k</span>
<span class="lineno"> 1736 </span><span class="spaces">           </span><span class="istickedoff">| v &lt; 100   = k + 1</span>
<span class="lineno"> 1737 </span><span class="spaces">           </span><span class="istickedoff">| v &lt; 1000  = k + 2</span>
<span class="lineno"> 1738 </span><span class="spaces">           </span><span class="istickedoff">| v &lt; 10000 = k + 3</span>
<span class="lineno"> 1739 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = go (k+4) (v `quot` 10000)</span></span>
<span class="lineno"> 1740 </span>
<span class="lineno"> 1741 </span>
<span class="lineno"> 1742 </span>------------------------------------------------------------------------------
<span class="lineno"> 1743 </span>{-# INLINE word64ToByteString #-}
<span class="lineno"> 1744 </span>word64ToByteString :: Word64 -&gt; ByteString
<span class="lineno"> 1745 </span><span class="decl"><span class="istickedoff">word64ToByteString d =</span>
<span class="lineno"> 1746 </span><span class="spaces"></span><span class="istickedoff">#if !MIN_VERSION_bytestring(0,10,6)</span>
<span class="lineno"> 1747 </span><span class="spaces">    </span><span class="istickedoff">S.inlinePerformIO $</span>
<span class="lineno"> 1748 </span><span class="spaces"></span><span class="istickedoff">#else</span>
<span class="lineno"> 1749 </span><span class="spaces">    </span><span class="istickedoff">S.accursedUnutterablePerformIO $</span>
<span class="lineno"> 1750 </span><span class="spaces"></span><span class="istickedoff">#endif</span>
<span class="lineno"> 1751 </span><span class="spaces">    </span><span class="istickedoff">if d &lt; 10</span>
<span class="lineno"> 1752 </span><span class="spaces">       </span><span class="istickedoff">then S.create 1 $ \p -&gt; poke p (i2w d)</span>
<span class="lineno"> 1753 </span><span class="spaces">       </span><span class="istickedoff">else let !n = countDigits d</span>
<span class="lineno"> 1754 </span><span class="spaces">            </span><span class="istickedoff">in S.create n $ posDecimal n d</span></span>
<span class="lineno"> 1755 </span>
<span class="lineno"> 1756 </span>
<span class="lineno"> 1757 </span>{-# INLINE posDecimal #-}
<span class="lineno"> 1758 </span>posDecimal :: Int -&gt; Word64 -&gt; Ptr Word8 -&gt; IO ()
<span class="lineno"> 1759 </span><span class="decl"><span class="istickedoff">posDecimal !n0 !v0 !op0 = go n0 (plusPtr op0 (n0-1)) v0</span>
<span class="lineno"> 1760 </span><span class="spaces">  </span><span class="istickedoff">where go !n !op !v</span>
<span class="lineno"> 1761 </span><span class="spaces">          </span><span class="istickedoff">| n == 1 = poke op $! i2w v</span>
<span class="lineno"> 1762 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = do</span>
<span class="lineno"> 1763 </span><span class="spaces">              </span><span class="istickedoff">let (!v', !d) = divMod v 10</span>
<span class="lineno"> 1764 </span><span class="spaces">              </span><span class="istickedoff">poke op $! i2w d</span>
<span class="lineno"> 1765 </span><span class="spaces">              </span><span class="istickedoff">go (n-1) (plusPtr op (-1)) v'</span></span>
<span class="lineno"> 1766 </span>
<span class="lineno"> 1767 </span>
<span class="lineno"> 1768 </span>{-# INLINE i2w #-}
<span class="lineno"> 1769 </span>i2w :: Word64 -&gt; Word8
<span class="lineno"> 1770 </span><span class="decl"><span class="istickedoff">i2w v = 48 + fromIntegral v</span></span>
<span class="lineno"> 1771 </span>
<span class="lineno"> 1772 </span>
<span class="lineno"> 1773 </span>------------------------------------------------------------------------------
<span class="lineno"> 1774 </span>evalSnap :: Snap a
<span class="lineno"> 1775 </span>         -&gt; (ByteString -&gt; IO ())
<span class="lineno"> 1776 </span>         -&gt; ((Int -&gt; Int) -&gt; IO ())
<span class="lineno"> 1777 </span>         -&gt; Request
<span class="lineno"> 1778 </span>         -&gt; IO a
<span class="lineno"> 1779 </span><span class="decl"><span class="istickedoff">evalSnap (Snap m) logerr timeoutAction req =</span>
<span class="lineno"> 1780 </span><span class="spaces">    </span><span class="istickedoff">m (\v _ -&gt; return v) diediedie ss</span>
<span class="lineno"> 1781 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1782 </span><span class="spaces">    </span><span class="istickedoff">diediedie z _ = case z of</span>
<span class="lineno"> 1783 </span><span class="spaces">      </span><span class="istickedoff">PassOnProcessing     -&gt; throwIO $ NoHandlerException &quot;pass&quot;</span>
<span class="lineno"> 1784 </span><span class="spaces">      </span><span class="istickedoff">(EarlyTermination _) -&gt; throwIO $ ErrorCall &quot;no value&quot;</span>
<span class="lineno"> 1785 </span><span class="spaces">      </span><span class="istickedoff">(EscapeSnap e)       -&gt; throwIO e</span>
<span class="lineno"> 1786 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1787 </span><span class="spaces">    </span><span class="istickedoff">dresp = emptyResponse</span>
<span class="lineno"> 1788 </span><span class="spaces">    </span><span class="istickedoff">ss = SnapState req dresp logerr timeoutAction</span></span>
<span class="lineno"> 1789 </span>{-# INLINE evalSnap #-}
<span class="lineno"> 1790 </span>
<span class="lineno"> 1791 </span>
<span class="lineno"> 1792 </span>------------------------------------------------------------------------------
<span class="lineno"> 1793 </span>getParamFrom :: MonadSnap m =&gt;
<span class="lineno"> 1794 </span>                (ByteString -&gt; Request -&gt; Maybe [ByteString])
<span class="lineno"> 1795 </span>             -&gt; ByteString
<span class="lineno"> 1796 </span>             -&gt; m (Maybe ByteString)
<span class="lineno"> 1797 </span><span class="decl"><span class="istickedoff">getParamFrom f k = do</span>
<span class="lineno"> 1798 </span><span class="spaces">    </span><span class="istickedoff">rq &lt;- getRequest</span>
<span class="lineno"> 1799 </span><span class="spaces">    </span><span class="istickedoff">return $! liftM (S.intercalate &quot; &quot;) $ f k rq</span></span>
<span class="lineno"> 1800 </span>{-# INLINE getParamFrom #-}
<span class="lineno"> 1801 </span>
<span class="lineno"> 1802 </span>
<span class="lineno"> 1803 </span>------------------------------------------------------------------------------
<span class="lineno"> 1804 </span>-- | See 'rqParam'. Looks up a value for the given named parameter in the
<span class="lineno"> 1805 </span>-- 'Request'. If more than one value was entered for the given parameter name,
<span class="lineno"> 1806 </span>-- 'getParam' gloms the values together with @'S.intercalate' \&quot; \&quot;@.
<span class="lineno"> 1807 </span>--
<span class="lineno"> 1808 </span>-- Example:
<span class="lineno"> 1809 </span>--
<span class="lineno"> 1810 </span>-- @
<span class="lineno"> 1811 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1812 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1813 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1814 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1815 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; $ M.fromList [(\&quot;foo\&quot;, [\&quot;bar\&quot;])]
<span class="lineno"> 1816 </span>-- ghci&gt; T.runHandler r ('getParam' \&quot;foo\&quot; &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno"> 1817 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1818 </span>-- server: Snap\/test
<span class="lineno"> 1819 </span>-- date: Mon, 11 Aug 2014 12:57:20 GMT
<span class="lineno"> 1820 </span>--
<span class="lineno"> 1821 </span>-- Just \&quot;bar\&quot;
<span class="lineno"> 1822 </span>-- @
<span class="lineno"> 1823 </span>getParam :: MonadSnap m
<span class="lineno"> 1824 </span>         =&gt; ByteString          -- ^ parameter name to look up
<span class="lineno"> 1825 </span>         -&gt; m (Maybe ByteString)
<span class="lineno"> 1826 </span><span class="decl"><span class="istickedoff">getParam = getParamFrom rqParam</span></span>
<span class="lineno"> 1827 </span>{-# INLINE getParam #-}
<span class="lineno"> 1828 </span>
<span class="lineno"> 1829 </span>
<span class="lineno"> 1830 </span>------------------------------------------------------------------------------
<span class="lineno"> 1831 </span>-- | See 'rqPostParam'. Looks up a value for the given named parameter in the
<span class="lineno"> 1832 </span>-- POST form parameters mapping in 'Request'. If more than one value was
<span class="lineno"> 1833 </span>-- entered for the given parameter name, 'getPostParam' gloms the values
<span class="lineno"> 1834 </span>-- together with: @'S.intercalate' \&quot; \&quot;@.
<span class="lineno"> 1835 </span>--
<span class="lineno"> 1836 </span>-- Example:
<span class="lineno"> 1837 </span>--
<span class="lineno"> 1838 </span>-- @
<span class="lineno"> 1839 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1840 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1841 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1842 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1843 </span>-- ghci&gt; let r = T.postUrlEncoded \&quot;\/foo\/bar\&quot; $ M.fromList [(\&quot;foo\&quot;, [\&quot;bar\&quot;])]
<span class="lineno"> 1844 </span>-- ghci&gt; T.runHandler r ('getPostParam' \&quot;foo\&quot; &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno"> 1845 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1846 </span>-- server: Snap\/test
<span class="lineno"> 1847 </span>-- date: Mon, 11 Aug 2014 13:01:04 GMT
<span class="lineno"> 1848 </span>--
<span class="lineno"> 1849 </span>-- Just \&quot;bar\&quot;
<span class="lineno"> 1850 </span>-- @
<span class="lineno"> 1851 </span>getPostParam :: MonadSnap m
<span class="lineno"> 1852 </span>             =&gt; ByteString          -- ^ parameter name to look up
<span class="lineno"> 1853 </span>             -&gt; m (Maybe ByteString)
<span class="lineno"> 1854 </span><span class="decl"><span class="istickedoff">getPostParam = getParamFrom rqPostParam</span></span>
<span class="lineno"> 1855 </span>{-# INLINE getPostParam #-}
<span class="lineno"> 1856 </span>
<span class="lineno"> 1857 </span>
<span class="lineno"> 1858 </span>------------------------------------------------------------------------------
<span class="lineno"> 1859 </span>-- | See 'rqQueryParam'. Looks up a value for the given named parameter in the
<span class="lineno"> 1860 </span>-- query string parameters mapping in 'Request'. If more than one value was
<span class="lineno"> 1861 </span>-- entered for the given parameter name, 'getQueryParam' gloms the values
<span class="lineno"> 1862 </span>-- together with  @'S.intercalate' \&quot; \&quot;@.
<span class="lineno"> 1863 </span>--
<span class="lineno"> 1864 </span>-- Example:
<span class="lineno"> 1865 </span>--
<span class="lineno"> 1866 </span>-- @
<span class="lineno"> 1867 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1868 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1869 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1870 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1871 </span>-- ghci&gt; let r = T.postUrlEncoded \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; T.setQueryStringRaw \&quot;foo=bar&amp;foo=baz\&quot;
<span class="lineno"> 1872 </span>-- ghci&gt; T.runHandler r ('getQueryParam' \&quot;foo\&quot; &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno"> 1873 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1874 </span>-- server: Snap\/test
<span class="lineno"> 1875 </span>-- date: Mon, 11 Aug 2014 13:06:50 GMT
<span class="lineno"> 1876 </span>--
<span class="lineno"> 1877 </span>-- Just \&quot;bar baz\&quot;
<span class="lineno"> 1878 </span>-- @
<span class="lineno"> 1879 </span>getQueryParam :: MonadSnap m
<span class="lineno"> 1880 </span>              =&gt; ByteString          -- ^ parameter name to look up
<span class="lineno"> 1881 </span>              -&gt; m (Maybe ByteString)
<span class="lineno"> 1882 </span><span class="decl"><span class="istickedoff">getQueryParam = getParamFrom rqQueryParam</span></span>
<span class="lineno"> 1883 </span>{-# INLINE getQueryParam #-}
<span class="lineno"> 1884 </span>
<span class="lineno"> 1885 </span>
<span class="lineno"> 1886 </span>------------------------------------------------------------------------------
<span class="lineno"> 1887 </span>-- | See 'rqParams'. Convenience function to return 'Params' from the
<span class="lineno"> 1888 </span>-- 'Request' inside of a 'MonadSnap' instance.
<span class="lineno"> 1889 </span>--
<span class="lineno"> 1890 </span>-- Example:
<span class="lineno"> 1891 </span>--
<span class="lineno"> 1892 </span>-- @
<span class="lineno"> 1893 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1894 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1895 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1896 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1897 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; $ M.fromList [(\&quot;foo\&quot;, [\&quot;bar\&quot;])]
<span class="lineno"> 1898 </span>-- ghci&gt; T.runHandler r ('getParams' &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno"> 1899 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1900 </span>-- server: Snap\/test
<span class="lineno"> 1901 </span>-- date: Mon, 11 Aug 2014 13:02:54 GMT
<span class="lineno"> 1902 </span>--
<span class="lineno"> 1903 </span>-- fromList [(\&quot;foo\&quot;,[\&quot;bar\&quot;])]
<span class="lineno"> 1904 </span>-- @
<span class="lineno"> 1905 </span>getParams :: MonadSnap m =&gt; m Params
<span class="lineno"> 1906 </span><span class="decl"><span class="istickedoff">getParams = getRequest &gt;&gt;= return . rqParams</span></span>
<span class="lineno"> 1907 </span>
<span class="lineno"> 1908 </span>
<span class="lineno"> 1909 </span>------------------------------------------------------------------------------
<span class="lineno"> 1910 </span>-- | See 'rqParams'. Convenience function to return 'Params' from the
<span class="lineno"> 1911 </span>-- 'Request' inside of a 'MonadSnap' instance.
<span class="lineno"> 1912 </span>--
<span class="lineno"> 1913 </span>-- Example:
<span class="lineno"> 1914 </span>--
<span class="lineno"> 1915 </span>-- @
<span class="lineno"> 1916 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1917 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1918 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1919 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1920 </span>-- ghci&gt; let r = T.postUrlEncoded \&quot;\/foo\/bar\&quot; $ M.fromList [(\&quot;foo\&quot;, [\&quot;bar\&quot;])]
<span class="lineno"> 1921 </span>-- ghci&gt; T.runHandler r ('getPostParams' &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno"> 1922 </span>-- HTTP/1.1 200 OK
<span class="lineno"> 1923 </span>-- server: Snap/test
<span class="lineno"> 1924 </span>-- date: Mon, 11 Aug 2014 13:04:34 GMT
<span class="lineno"> 1925 </span>--
<span class="lineno"> 1926 </span>-- fromList [(&quot;foo&quot;,[&quot;bar&quot;])]
<span class="lineno"> 1927 </span>-- @
<span class="lineno"> 1928 </span>getPostParams :: MonadSnap m =&gt; m Params
<span class="lineno"> 1929 </span><span class="decl"><span class="istickedoff">getPostParams = getRequest &gt;&gt;= return . rqPostParams</span></span>
<span class="lineno"> 1930 </span>
<span class="lineno"> 1931 </span>
<span class="lineno"> 1932 </span>------------------------------------------------------------------------------
<span class="lineno"> 1933 </span>-- | See 'rqParams'. Convenience function to return 'Params' from the
<span class="lineno"> 1934 </span>-- 'Request' inside of a 'MonadSnap' instance.
<span class="lineno"> 1935 </span>--
<span class="lineno"> 1936 </span>-- Example:
<span class="lineno"> 1937 </span>--
<span class="lineno"> 1938 </span>-- @
<span class="lineno"> 1939 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1940 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1941 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1942 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1943 </span>-- ghci&gt; let r = T.postUrlEncoded \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; T.setQueryStringRaw \&quot;foo=bar&amp;foo=baz\&quot;
<span class="lineno"> 1944 </span>-- ghci&gt; T.runHandler r ('getQueryParams' &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno"> 1945 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1946 </span>-- server: Snap\/test
<span class="lineno"> 1947 </span>-- date: Mon, 11 Aug 2014 13:10:17 GMT
<span class="lineno"> 1948 </span>--
<span class="lineno"> 1949 </span>-- fromList [(\&quot;foo\&quot;,[\&quot;bar\&quot;,\&quot;baz\&quot;])]
<span class="lineno"> 1950 </span>-- @
<span class="lineno"> 1951 </span>getQueryParams :: MonadSnap m =&gt; m Params
<span class="lineno"> 1952 </span><span class="decl"><span class="istickedoff">getQueryParams = getRequest &gt;&gt;= return . rqQueryParams</span></span>
<span class="lineno"> 1953 </span>
<span class="lineno"> 1954 </span>
<span class="lineno"> 1955 </span>------------------------------------------------------------------------------
<span class="lineno"> 1956 </span>-- | Gets the HTTP 'Cookie' with the specified name.
<span class="lineno"> 1957 </span>--
<span class="lineno"> 1958 </span>-- Example:
<span class="lineno"> 1959 </span>--
<span class="lineno"> 1960 </span>-- @
<span class="lineno"> 1961 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1962 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1963 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1964 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Char8&quot; as B8
<span class="lineno"> 1965 </span>-- ghci&gt; let cookie = 'Cookie' \&quot;name\&quot; \&quot;value\&quot; Nothing Nothing Nothing False False
<span class="lineno"> 1966 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; T.addCookies [cookie]
<span class="lineno"> 1967 </span>-- ghci&gt; T.runHandler r ('getCookie' \&quot;name\&quot; &gt;&gt;= 'writeBS' . B8.pack . show)
<span class="lineno"> 1968 </span>-- HTTP/1.1 200 OK
<span class="lineno"> 1969 </span>-- server: Snap/test
<span class="lineno"> 1970 </span>-- date: Thu, 07 Aug 2014 12:16:58 GMT
<span class="lineno"> 1971 </span>--
<span class="lineno"> 1972 </span>-- Just (Cookie {cookieName = &quot;name&quot;, cookieValue = &quot;value&quot;, ...})
<span class="lineno"> 1973 </span>-- @
<span class="lineno"> 1974 </span>getCookie :: MonadSnap m
<span class="lineno"> 1975 </span>          =&gt; ByteString
<span class="lineno"> 1976 </span>          -&gt; m (Maybe Cookie)
<span class="lineno"> 1977 </span><span class="decl"><span class="istickedoff">getCookie name = withRequest $</span>
<span class="lineno"> 1978 </span><span class="spaces">    </span><span class="istickedoff">return . listToMaybe . filter (\c -&gt; cookieName c == name) . rqCookies</span></span>
<span class="lineno"> 1979 </span>
<span class="lineno"> 1980 </span>
<span class="lineno"> 1981 </span>------------------------------------------------------------------------------
<span class="lineno"> 1982 </span>-- | Gets the HTTP 'Cookie' with the specified name and decodes it.  If the
<span class="lineno"> 1983 </span>-- decoding fails, the handler calls pass.
<span class="lineno"> 1984 </span>--
<span class="lineno"> 1985 </span>-- Example:
<span class="lineno"> 1986 </span>--
<span class="lineno"> 1987 </span>-- @
<span class="lineno"> 1988 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1989 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 1990 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 1991 </span>-- ghci&gt; let cookie = 'Cookie' \&quot;name\&quot; \&quot;value\&quot; Nothing Nothing Nothing False False
<span class="lineno"> 1992 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; T.addCookies [cookie]
<span class="lineno"> 1993 </span>-- ghci&gt; T.runHandler r ('readCookie' \&quot;name\&quot; &gt;&gt;= 'writeBS')
<span class="lineno"> 1994 </span>-- HTTP/1.1 200 OK
<span class="lineno"> 1995 </span>-- server: Snap/test
<span class="lineno"> 1996 </span>-- date: Thu, 07 Aug 2014 12:20:09 GMT
<span class="lineno"> 1997 </span>--
<span class="lineno"> 1998 </span>-- value
<span class="lineno"> 1999 </span>-- @
<span class="lineno"> 2000 </span>readCookie :: (MonadSnap m, R.Readable a)
<span class="lineno"> 2001 </span>           =&gt; ByteString
<span class="lineno"> 2002 </span>           -&gt; m a
<span class="lineno"> 2003 </span><span class="decl"><span class="istickedoff">readCookie name = maybe pass (R.fromBS . cookieValue) =&lt;&lt; getCookie name</span></span>
<span class="lineno"> 2004 </span>
<span class="lineno"> 2005 </span>
<span class="lineno"> 2006 </span>------------------------------------------------------------------------------
<span class="lineno"> 2007 </span>-- | Expire given 'Cookie' in client's browser.
<span class="lineno"> 2008 </span>--
<span class="lineno"> 2009 </span>-- Example:
<span class="lineno"> 2010 </span>--
<span class="lineno"> 2011 </span>-- @
<span class="lineno"> 2012 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 2013 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno"> 2014 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno"> 2015 </span>-- ghci&gt; let r = T.get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno"> 2016 </span>-- ghci&gt; let cookie = Cookie &quot;name&quot; &quot;&quot; Nothing (Just &quot;/subsite&quot;) Nothing True False
<span class="lineno"> 2017 </span>-- ghci&gt; T.runHandler r ('expireCookie' cookie)
<span class="lineno"> 2018 </span>-- HTTP/1.1 200 OK
<span class="lineno"> 2019 </span>-- set-cookie: name=; path=/subsite; expires=Sat, 24 Dec 1994 06:28:16 GMT; Secure
<span class="lineno"> 2020 </span>-- server: Snap/test
<span class="lineno"> 2021 </span>--
<span class="lineno"> 2022 </span>-- date: Thu, 07 Aug 2014 12:21:27 GMT
<span class="lineno"> 2023 </span>-- ghci&gt; let cookie = Cookie &quot;name&quot; &quot;value&quot; Nothing Nothing Nothing False False
<span class="lineno"> 2024 </span>-- ghci&gt; let r2 = T.get \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; T.addCookies [cookie]
<span class="lineno"> 2025 </span>-- ghci&gt; T.runHandler r ('getCookie' &quot;name&quot; &gt;&gt;= maybe (return ()) 'expireCookie')
<span class="lineno"> 2026 </span>-- HTTP/1.1 200 OK
<span class="lineno"> 2027 </span>-- set-cookie: name=; expires=Sat, 24 Dec 1994 06:28:16 GMT
<span class="lineno"> 2028 </span>-- server: Snap/test
<span class="lineno"> 2029 </span>--
<span class="lineno"> 2030 </span>--
<span class="lineno"> 2031 </span>-- @
<span class="lineno"> 2032 </span>expireCookie :: (MonadSnap m) =&gt; Cookie -&gt; m ()
<span class="lineno"> 2033 </span><span class="decl"><span class="istickedoff">expireCookie cookie = do</span>
<span class="lineno"> 2034 </span><span class="spaces">  </span><span class="istickedoff">let old = UTCTime (ModifiedJulianDay 0) 0</span>
<span class="lineno"> 2035 </span><span class="spaces">  </span><span class="istickedoff">modifyResponse $ addResponseCookie</span>
<span class="lineno"> 2036 </span><span class="spaces">                 </span><span class="istickedoff">$ cookie { cookieValue = &quot;&quot;</span>
<span class="lineno"> 2037 </span><span class="spaces">                          </span><span class="istickedoff">, cookieExpires = (Just old) }</span></span>
<span class="lineno"> 2038 </span>
<span class="lineno"> 2039 </span>------------------------------------------------------------------------------
<span class="lineno"> 2040 </span>-- | Causes the handler thread to be killed @n@ seconds from now.
<span class="lineno"> 2041 </span>setTimeout :: MonadSnap m =&gt; Int -&gt; m ()
<span class="lineno"> 2042 </span><span class="decl"><span class="istickedoff">setTimeout = modifyTimeout . const</span></span>
<span class="lineno"> 2043 </span>
<span class="lineno"> 2044 </span>
<span class="lineno"> 2045 </span>------------------------------------------------------------------------------
<span class="lineno"> 2046 </span>-- | Causes the handler thread to be killed at least @n@ seconds from now.
<span class="lineno"> 2047 </span>extendTimeout :: MonadSnap m =&gt; Int -&gt; m ()
<span class="lineno"> 2048 </span><span class="decl"><span class="istickedoff">extendTimeout = modifyTimeout . max</span></span>
<span class="lineno"> 2049 </span>
<span class="lineno"> 2050 </span>
<span class="lineno"> 2051 </span>------------------------------------------------------------------------------
<span class="lineno"> 2052 </span>-- | Modifies the amount of time remaining before the request times out.
<span class="lineno"> 2053 </span>modifyTimeout :: MonadSnap m =&gt; (Int -&gt; Int) -&gt; m ()
<span class="lineno"> 2054 </span><span class="decl"><span class="istickedoff">modifyTimeout f = do</span>
<span class="lineno"> 2055 </span><span class="spaces">    </span><span class="istickedoff">m &lt;- getTimeoutModifier</span>
<span class="lineno"> 2056 </span><span class="spaces">    </span><span class="istickedoff">liftIO $ m f</span></span>
<span class="lineno"> 2057 </span>
<span class="lineno"> 2058 </span>
<span class="lineno"> 2059 </span>------------------------------------------------------------------------------
<span class="lineno"> 2060 </span>-- | Returns an 'IO' action which you can use to modify the timeout value.
<span class="lineno"> 2061 </span>getTimeoutModifier :: MonadSnap m =&gt; m ((Int -&gt; Int) -&gt; IO ())
<span class="lineno"> 2062 </span><span class="decl"><span class="istickedoff">getTimeoutModifier = liftSnap $ liftM _snapModifyTimeout sget</span></span>

</pre>
</body>
</html>
