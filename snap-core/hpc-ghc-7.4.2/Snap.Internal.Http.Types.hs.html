<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE BangPatterns              #-}
<span class="lineno">    2 </span>{-# LANGUAGE CPP                       #-}
<span class="lineno">    3 </span>{-# LANGUAGE EmptyDataDecls            #-}
<span class="lineno">    4 </span>{-# LANGUAGE ExistentialQuantification #-}
<span class="lineno">    5 </span>{-# LANGUAGE FlexibleInstances         #-}
<span class="lineno">    6 </span>{-# LANGUAGE ForeignFunctionInterface  #-}
<span class="lineno">    7 </span>{-# LANGUAGE OverloadedStrings         #-}
<span class="lineno">    8 </span>{-# LANGUAGE Rank2Types                #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeSynonymInstances      #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>------------------------------------------------------------------------------
<span class="lineno">   12 </span>-- | An internal Snap module containing HTTP types.
<span class="lineno">   13 </span>--
<span class="lineno">   14 </span>-- /N.B./ this is an internal interface, please don't write user code that
<span class="lineno">   15 </span>-- depends on it. Most of these declarations (except for the
<span class="lineno">   16 </span>-- unsafe/encapsulation-breaking ones) are re-exported from &quot;Snap.Core&quot;.
<span class="lineno">   17 </span>--
<span class="lineno">   18 </span>module Snap.Internal.Http.Types where
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>------------------------------------------------------------------------------
<span class="lineno">   21 </span>import           Control.Monad              (unless)
<span class="lineno">   22 </span>import           Data.ByteString            (ByteString)
<span class="lineno">   23 </span>import           Data.ByteString.Builder    (Builder, byteString, toLazyByteString)
<span class="lineno">   24 </span>import qualified Data.ByteString.Char8      as S
<span class="lineno">   25 </span>import qualified Data.ByteString.Lazy.Char8 as L
<span class="lineno">   26 </span>import           Data.CaseInsensitive       (CI)
<span class="lineno">   27 </span>import qualified Data.CaseInsensitive       as CI
<span class="lineno">   28 </span>import qualified Data.IntMap                as IM
<span class="lineno">   29 </span>import           Data.List                  hiding (take)
<span class="lineno">   30 </span>import           Data.Map                   (Map)
<span class="lineno">   31 </span>import qualified Data.Map                   as Map
<span class="lineno">   32 </span>import           Data.Maybe                 (Maybe (..), fromMaybe, maybe)
<span class="lineno">   33 </span>import           Data.Monoid                (mconcat)
<span class="lineno">   34 </span>import           Data.Time.Clock            (UTCTime)
<span class="lineno">   35 </span>import           Data.Time.Clock.POSIX      (utcTimeToPOSIXSeconds)
<span class="lineno">   36 </span>import           Data.Word                  (Word64)
<span class="lineno">   37 </span>import           Foreign.C.Types            (CTime (..))
<span class="lineno">   38 </span>import           Prelude                    (Bool (..), Eq (..), FilePath, IO, Int, Integral (..), Monad (..), Num ((-)), Ord (..), Ordering (..), Read (..), Show (..), String, fmap, fromInteger, fromIntegral, id, not, otherwise, truncate, ($), (.))
<span class="lineno">   39 </span>#ifdef PORTABLE
<span class="lineno">   40 </span>import           Prelude                    (realToFrac, ($!))
<span class="lineno">   41 </span>#endif
<span class="lineno">   42 </span>import           System.IO                  (IOMode (ReadMode), SeekMode (AbsoluteSeek), hSeek, withBinaryFile)
<span class="lineno">   43 </span>import           System.IO.Streams          (InputStream, OutputStream)
<span class="lineno">   44 </span>import qualified System.IO.Streams          as Streams
<span class="lineno">   45 </span>import           System.IO.Unsafe           (unsafePerformIO)
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>------------------------------------------------------------------------------
<span class="lineno">   48 </span>#ifdef PORTABLE
<span class="lineno">   49 </span>import           Data.Time.Clock.POSIX
<span class="lineno">   50 </span>import           Data.Time.Clock.POSIX
<span class="lineno">   51 </span>import           Data.Time.Format
<span class="lineno">   52 </span>import           Data.Time.Locale.Compat    (defaultTimeLocale)
<span class="lineno">   53 </span>import           Data.Time.LocalTime
<span class="lineno">   54 </span>#else
<span class="lineno">   55 </span>import qualified Data.ByteString.Unsafe     as S
<span class="lineno">   56 </span>import           Data.Time.Format           ()
<span class="lineno">   57 </span>import           Foreign.C.String           (CString)
<span class="lineno">   58 </span>import           Foreign.Marshal.Alloc      (mallocBytes)
<span class="lineno">   59 </span>#endif
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>------------------------------------------------------------------------------
<span class="lineno">   62 </span>import           Snap.Types.Headers         (Headers)
<span class="lineno">   63 </span>import qualified Snap.Types.Headers         as H
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>#ifndef PORTABLE
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>------------------------------------------------------------------------------
<span class="lineno">   69 </span>-- foreign imports from cbits
<span class="lineno">   70 </span>foreign import ccall unsafe &quot;set_c_locale&quot;
<span class="lineno">   71 </span>        set_c_locale :: IO ()
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>foreign import ccall unsafe &quot;c_parse_http_time&quot;
<span class="lineno">   74 </span>        c_parse_http_time :: CString -&gt; IO CTime
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>foreign import ccall unsafe &quot;c_format_http_time&quot;
<span class="lineno">   77 </span>        c_format_http_time :: CTime -&gt; CString -&gt; IO ()
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>foreign import ccall unsafe &quot;c_format_log_time&quot;
<span class="lineno">   80 </span>        c_format_log_time :: CTime -&gt; CString -&gt; IO ()
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>#endif
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>------------------------------------------------------------------------------
<span class="lineno">   86 </span>-- | A typeclass for datatypes which contain HTTP headers.
<span class="lineno">   87 </span>class HasHeaders a where
<span class="lineno">   88 </span>    -- | Modify the datatype's headers.
<span class="lineno">   89 </span>    updateHeaders :: (Headers -&gt; Headers) -&gt; a -&gt; a
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>    -- | Retrieve the headers from a datatype that has headers.
<span class="lineno">   92 </span>    headers       :: a -&gt; Headers
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>------------------------------------------------------------------------------
<span class="lineno">   96 </span>-- | Adds a header key-value-pair to the 'HasHeaders' datatype. If a header
<span class="lineno">   97 </span>-- with the same name already exists, the new value is appended to the headers
<span class="lineno">   98 </span>-- list.
<span class="lineno">   99 </span>--
<span class="lineno">  100 </span>-- Example:
<span class="lineno">  101 </span>--
<span class="lineno">  102 </span>-- @
<span class="lineno">  103 </span>-- ghci&gt; import qualified &quot;Snap.Types.Headers&quot; as H
<span class="lineno">  104 </span>-- ghci&gt; 'addHeader' &quot;Host&quot; &quot;localhost&quot; H.'empty'
<span class="lineno">  105 </span>-- H {unH = [(&quot;host&quot;,&quot;localhost&quot;)]}
<span class="lineno">  106 </span>-- ghci&gt; 'addHeader' &quot;Host&quot; &quot;127.0.0.1&quot; it
<span class="lineno">  107 </span>-- H {unH = [(&quot;host&quot;,&quot;localhost,127.0.0.1&quot;)]}
<span class="lineno">  108 </span>-- @
<span class="lineno">  109 </span>addHeader :: (HasHeaders a) =&gt; CI ByteString -&gt; ByteString -&gt; a -&gt; a
<span class="lineno">  110 </span><span class="decl"><span class="istickedoff">addHeader k v = updateHeaders $ H.insert k v</span></span>
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>------------------------------------------------------------------------------
<span class="lineno">  114 </span>-- | Sets a header key-value-pair in a 'HasHeaders' datatype. If a header with
<span class="lineno">  115 </span>-- the same name already exists, it is overwritten with the new value.
<span class="lineno">  116 </span>--
<span class="lineno">  117 </span>-- Example:
<span class="lineno">  118 </span>--
<span class="lineno">  119 </span>-- @
<span class="lineno">  120 </span>-- ghci&gt; import qualified &quot;Snap.Types.Headers&quot; as H
<span class="lineno">  121 </span>-- ghci&gt; 'setHeader' &quot;Host&quot; &quot;localhost&quot; H.'empty'
<span class="lineno">  122 </span>-- H {unH = [(\&quot;host\&quot;,\&quot;localhost\&quot;)]}
<span class="lineno">  123 </span>-- ghci&gt; setHeader &quot;Host&quot; &quot;127.0.0.1&quot; it
<span class="lineno">  124 </span>-- H {unH = [(&quot;host&quot;,&quot;127.0.0.1&quot;)]}
<span class="lineno">  125 </span>-- @
<span class="lineno">  126 </span>setHeader :: (HasHeaders a) =&gt; CI ByteString -&gt; ByteString -&gt; a -&gt; a
<span class="lineno">  127 </span><span class="decl"><span class="istickedoff">setHeader k v = updateHeaders $ H.set k v</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>------------------------------------------------------------------------------
<span class="lineno">  131 </span>-- | Gets a header value out of a 'HasHeaders' datatype.
<span class="lineno">  132 </span>--
<span class="lineno">  133 </span>-- Example:
<span class="lineno">  134 </span>--
<span class="lineno">  135 </span>-- @
<span class="lineno">  136 </span>-- ghci&gt; import qualified &quot;Snap.Types.Headers&quot; as H
<span class="lineno">  137 </span>-- ghci&gt; 'getHeader' &quot;Host&quot; $ 'setHeader' &quot;Host&quot; &quot;localhost&quot; H.'empty'
<span class="lineno">  138 </span>-- Just &quot;localhost&quot;
<span class="lineno">  139 </span>-- @
<span class="lineno">  140 </span>getHeader :: (HasHeaders a) =&gt; CI ByteString -&gt; a -&gt; Maybe ByteString
<span class="lineno">  141 </span><span class="decl"><span class="istickedoff">getHeader k a = H.lookup k $ headers a</span></span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>------------------------------------------------------------------------------
<span class="lineno">  145 </span>-- | Lists all the headers out of a 'HasHeaders' datatype. If many
<span class="lineno">  146 </span>-- headers came in with the same name, they will be catenated together.
<span class="lineno">  147 </span>--
<span class="lineno">  148 </span>-- Example:
<span class="lineno">  149 </span>--
<span class="lineno">  150 </span>-- @
<span class="lineno">  151 </span>-- ghci&gt; import qualified &quot;Snap.Types.Headers&quot; as H
<span class="lineno">  152 </span>-- ghci&gt; 'listHeaders' $ 'setHeader' &quot;Host&quot; &quot;localhost&quot; H.'empty'
<span class="lineno">  153 </span>-- [(&quot;host&quot;,&quot;localhost&quot;)]
<span class="lineno">  154 </span>-- @
<span class="lineno">  155 </span>listHeaders :: (HasHeaders a) =&gt; a -&gt; [(CI ByteString, ByteString)]
<span class="lineno">  156 </span><span class="decl"><span class="istickedoff">listHeaders = H.toList . headers</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>
<span class="lineno">  159 </span>------------------------------------------------------------------------------
<span class="lineno">  160 </span>-- | Clears a header value from a 'HasHeaders' datatype.
<span class="lineno">  161 </span>--
<span class="lineno">  162 </span>-- Example:
<span class="lineno">  163 </span>--
<span class="lineno">  164 </span>-- @
<span class="lineno">  165 </span>-- ghci&gt; import qualified &quot;Snap.Types.Headers&quot; as H
<span class="lineno">  166 </span>-- ghci&gt; 'deleteHeader' &quot;Host&quot; $ 'setHeader' &quot;Host&quot; &quot;localhost&quot; H.'empty'
<span class="lineno">  167 </span>-- H {unH = []}
<span class="lineno">  168 </span>-- @
<span class="lineno">  169 </span>deleteHeader :: (HasHeaders a) =&gt; CI ByteString -&gt; a -&gt; a
<span class="lineno">  170 </span><span class="decl"><span class="istickedoff">deleteHeader k = updateHeaders $ H.delete k</span></span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>------------------------------------------------------------------------------
<span class="lineno">  174 </span>-- | Enumerates the HTTP method values (see
<span class="lineno">  175 </span>-- &lt;http://tools.ietf.org/html/rfc2068.html#section-5.1.1&gt;).
<span class="lineno">  176 </span>data Method  = GET | HEAD | POST | PUT | DELETE | TRACE | OPTIONS | CONNECT |
<span class="lineno">  177 </span>               PATCH | Method ByteString
<span class="lineno">  178 </span>               deriving(<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Read</span></span></span></span></span></span>)
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>instance Eq Method where
<span class="lineno">  181 </span>    <span class="decl"><span class="istickedoff">a == b =</span>
<span class="lineno">  182 </span><span class="spaces">        </span><span class="istickedoff">normalizeMethod a `eq` normalizeMethod b</span>
<span class="lineno">  183 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  184 </span><span class="spaces">        </span><span class="istickedoff">GET       `eq` GET       = True</span>
<span class="lineno">  185 </span><span class="spaces">        </span><span class="istickedoff">HEAD      `eq` HEAD      = True</span>
<span class="lineno">  186 </span><span class="spaces">        </span><span class="istickedoff">POST      `eq` POST      = True</span>
<span class="lineno">  187 </span><span class="spaces">        </span><span class="istickedoff">PUT       `eq` PUT       = True</span>
<span class="lineno">  188 </span><span class="spaces">        </span><span class="istickedoff">DELETE    `eq` DELETE    = True</span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">TRACE     `eq` TRACE     = True</span>
<span class="lineno">  190 </span><span class="spaces">        </span><span class="istickedoff">OPTIONS   `eq` OPTIONS   = True</span>
<span class="lineno">  191 </span><span class="spaces">        </span><span class="istickedoff">CONNECT   `eq` CONNECT   = True</span>
<span class="lineno">  192 </span><span class="spaces">        </span><span class="istickedoff">PATCH     `eq` PATCH     = True</span>
<span class="lineno">  193 </span><span class="spaces">        </span><span class="istickedoff">Method x1 `eq` Method y1 = x1 == y1</span>
<span class="lineno">  194 </span><span class="spaces">        </span><span class="istickedoff">_         `eq` _         = False</span></span>
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>instance Ord Method where
<span class="lineno">  197 </span>        <span class="decl"><span class="istickedoff">compare a b =</span>
<span class="lineno">  198 </span><span class="spaces">            </span><span class="istickedoff">check (normalizeMethod a) (normalizeMethod b)</span>
<span class="lineno">  199 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno">  200 </span><span class="spaces">            </span><span class="istickedoff">check   GET          GET           = EQ</span>
<span class="lineno">  201 </span><span class="spaces">            </span><span class="istickedoff">check   HEAD         HEAD          = EQ</span>
<span class="lineno">  202 </span><span class="spaces">            </span><span class="istickedoff">check   POST         POST          = EQ</span>
<span class="lineno">  203 </span><span class="spaces">            </span><span class="istickedoff">check   PUT          PUT           = EQ</span>
<span class="lineno">  204 </span><span class="spaces">            </span><span class="istickedoff">check   DELETE       DELETE        = EQ</span>
<span class="lineno">  205 </span><span class="spaces">            </span><span class="istickedoff">check   TRACE        TRACE         = EQ</span>
<span class="lineno">  206 </span><span class="spaces">            </span><span class="istickedoff">check   OPTIONS      OPTIONS       = EQ</span>
<span class="lineno">  207 </span><span class="spaces">            </span><span class="istickedoff">check   CONNECT      CONNECT       = EQ</span>
<span class="lineno">  208 </span><span class="spaces">            </span><span class="istickedoff">check   PATCH        PATCH         = EQ</span>
<span class="lineno">  209 </span><span class="spaces">            </span><span class="istickedoff">check   (Method  x1) (Method   y1) = compare x1 y1</span>
<span class="lineno">  210 </span><span class="spaces">            </span><span class="istickedoff">check   x            y             = compare (tag x) (tag y)</span>
<span class="lineno">  211 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  212 </span><span class="spaces">            </span><span class="istickedoff">tag :: Method -&gt; Int</span>
<span class="lineno">  213 </span><span class="spaces">            </span><span class="istickedoff">tag (GET{})     = 0</span>
<span class="lineno">  214 </span><span class="spaces">            </span><span class="istickedoff">tag (HEAD{})    = 1</span>
<span class="lineno">  215 </span><span class="spaces">            </span><span class="istickedoff">tag (POST{})    = 2</span>
<span class="lineno">  216 </span><span class="spaces">            </span><span class="istickedoff">tag (PUT{})     = 3</span>
<span class="lineno">  217 </span><span class="spaces">            </span><span class="istickedoff">tag (DELETE{})  = 4</span>
<span class="lineno">  218 </span><span class="spaces">            </span><span class="istickedoff">tag (TRACE{})   = 5</span>
<span class="lineno">  219 </span><span class="spaces">            </span><span class="istickedoff">tag (OPTIONS{}) = 6</span>
<span class="lineno">  220 </span><span class="spaces">            </span><span class="istickedoff">tag (CONNECT{}) = 7</span>
<span class="lineno">  221 </span><span class="spaces">            </span><span class="istickedoff">tag (PATCH{})   = 8</span>
<span class="lineno">  222 </span><span class="spaces">            </span><span class="istickedoff">tag (Method{})  = 9</span></span>
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- | Equate the special case constructors with their corresponding
<span class="lineno">  225 </span>-- @Method name@ variant.
<span class="lineno">  226 </span>{-# INLINE normalizeMethod #-}
<span class="lineno">  227 </span>normalizeMethod :: Method -&gt; Method
<span class="lineno">  228 </span><span class="decl"><span class="istickedoff">normalizeMethod m@(Method name) = case name of</span>
<span class="lineno">  229 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;GET&quot;     -&gt; GET</span>
<span class="lineno">  230 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;HEAD&quot;    -&gt; HEAD</span>
<span class="lineno">  231 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;POST&quot;    -&gt; POST</span>
<span class="lineno">  232 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;PUT&quot;     -&gt; PUT</span>
<span class="lineno">  233 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;DELETE&quot;  -&gt; DELETE</span>
<span class="lineno">  234 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;TRACE&quot;   -&gt; TRACE</span>
<span class="lineno">  235 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;OPTIONS&quot; -&gt; OPTIONS</span>
<span class="lineno">  236 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;CONNECT&quot; -&gt; CONNECT</span>
<span class="lineno">  237 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;PATCH&quot;   -&gt; PATCH</span>
<span class="lineno">  238 </span><span class="spaces">                                    </span><span class="istickedoff">_         -&gt; m</span>
<span class="lineno">  239 </span><span class="spaces"></span><span class="istickedoff">normalizeMethod m               = m</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>------------------------------------------------------------------------------
<span class="lineno">  243 </span>-- | Represents a (major, minor) version of the HTTP protocol.
<span class="lineno">  244 </span>type HttpVersion = (Int,Int)
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>------------------------------------------------------------------------------
<span class="lineno">  248 </span>-- | A datatype representing an HTTP cookie.
<span class="lineno">  249 </span>data Cookie = Cookie {
<span class="lineno">  250 </span>      -- | The name of the cookie.
<span class="lineno">  251 </span>      cookieName     :: !ByteString
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>      -- | The cookie's string value.
<span class="lineno">  254 </span>    , cookieValue    :: !ByteString
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>      -- | The cookie's expiration value, if it has one.
<span class="lineno">  257 </span>    , cookieExpires  :: !(Maybe UTCTime)
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>      -- | The cookie's \&quot;domain\&quot; value, if it has one.
<span class="lineno">  260 </span>    , cookieDomain   :: !(Maybe ByteString)
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>      -- | The cookie path.
<span class="lineno">  263 </span>    , cookiePath     :: !(Maybe ByteString)
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>      -- | Tag as secure cookie?
<span class="lineno">  266 </span>    , cookieSecure   :: !Bool
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>      -- | HTTP only?
<span class="lineno">  269 </span>    , cookieHttpOnly :: !Bool
<span class="lineno">  270 </span>} deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span>)
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>------------------------------------------------------------------------------
<span class="lineno">  274 </span>-- | A type alias for the HTTP parameters mapping. Each parameter
<span class="lineno">  275 </span>-- key maps to a list of 'ByteString' values; if a parameter is specified
<span class="lineno">  276 </span>-- multiple times (e.g.: \&quot;@GET /foo?param=bar1&amp;param=bar2@\&quot;), looking up
<span class="lineno">  277 </span>-- \&quot;@param@\&quot; in the mapping will give you @[\&quot;bar1\&quot;, \&quot;bar2\&quot;]@.
<span class="lineno">  278 </span>type Params = Map ByteString [ByteString]
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>------------------------------------------------------------------------------
<span class="lineno">  282 </span>-- request type
<span class="lineno">  283 </span>------------------------------------------------------------------------------
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>------------------------------------------------------------------------------
<span class="lineno">  286 </span>-- | Contains all of the information about an incoming HTTP request.
<span class="lineno">  287 </span>data Request = Request
<span class="lineno">  288 </span>    { -- | The server name of the request, as it came in from the request's
<span class="lineno">  289 </span>      -- @Host:@ header.
<span class="lineno">  290 </span>      --
<span class="lineno">  291 </span>      -- Example:
<span class="lineno">  292 </span>      --
<span class="lineno">  293 </span>      -- @
<span class="lineno">  294 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  295 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  296 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  297 </span>      -- ghci&gt; :{
<span class="lineno">  298 </span>      -- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  299 </span>      -- ghci|         T.get &quot;\/foo\/bar&quot; M.empty
<span class="lineno">  300 </span>      -- ghci|         T.setHeader &quot;host&quot; &quot;example.com&quot;
<span class="lineno">  301 </span>      -- ghci| :}
<span class="lineno">  302 </span>      -- ghci&gt; rqHostName rq
<span class="lineno">  303 </span>      -- &quot;example.com&quot;
<span class="lineno">  304 </span>      -- @
<span class="lineno">  305 </span>      rqHostName      :: ByteString
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>      -- | The remote IP address.
<span class="lineno">  308 </span>      --
<span class="lineno">  309 </span>      -- Example:
<span class="lineno">  310 </span>      --
<span class="lineno">  311 </span>      -- @
<span class="lineno">  312 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  313 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  314 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  315 </span>      -- ghci&gt; rqClientAddr \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  316 </span>      -- &quot;127.0.0.1&quot;
<span class="lineno">  317 </span>      -- @
<span class="lineno">  318 </span>    , rqClientAddr    :: ByteString
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>      -- | The remote TCP port number.
<span class="lineno">  321 </span>      --
<span class="lineno">  322 </span>      -- Example:
<span class="lineno">  323 </span>      --
<span class="lineno">  324 </span>      -- @
<span class="lineno">  325 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  326 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  327 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  328 </span>      -- ghci&gt; rqClientPort \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  329 </span>      -- &quot;60000&quot;
<span class="lineno">  330 </span>      -- @
<span class="lineno">  331 </span>    , rqClientPort    :: {-# UNPACK #-} !Int
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>      -- | The local IP address for this request.
<span class="lineno">  334 </span>      --
<span class="lineno">  335 </span>      -- Example:
<span class="lineno">  336 </span>      --
<span class="lineno">  337 </span>      -- @
<span class="lineno">  338 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  339 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  340 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  341 </span>      -- ghci&gt; rqServerAddr \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  342 </span>      -- &quot;127.0.0.1&quot;
<span class="lineno">  343 </span>      -- @
<span class="lineno">  344 </span>    , rqServerAddr    :: ByteString
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>      -- | Returns the port number the HTTP server is listening on. This may be
<span class="lineno">  347 </span>      -- useless from the perspective of external requests, e.g. if the server
<span class="lineno">  348 </span>      -- is running behind a proxy.
<span class="lineno">  349 </span>      --
<span class="lineno">  350 </span>      -- Example:
<span class="lineno">  351 </span>      --
<span class="lineno">  352 </span>      -- @
<span class="lineno">  353 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  354 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  355 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  356 </span>      -- ghci&gt; rqServerPort \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  357 </span>      -- 8080
<span class="lineno">  358 </span>      -- @
<span class="lineno">  359 </span>    , rqServerPort    :: {-# UNPACK #-} !Int
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>      -- | Returns the HTTP server's idea of its local hostname, including
<span class="lineno">  362 </span>      -- port. This is as configured with the @Config@ object at startup.
<span class="lineno">  363 </span>      --
<span class="lineno">  364 </span>      -- Example:
<span class="lineno">  365 </span>      --
<span class="lineno">  366 </span>      -- @
<span class="lineno">  367 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  368 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  369 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  370 </span>      -- ghci&gt; rqLocalHostname \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  371 </span>      -- &quot;localhost&quot;
<span class="lineno">  372 </span>      -- @
<span class="lineno">  373 </span>    , rqLocalHostname :: ByteString
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>      -- | Returns @True@ if this is an HTTPS session.
<span class="lineno">  376 </span>      --
<span class="lineno">  377 </span>      -- Example:
<span class="lineno">  378 </span>      --
<span class="lineno">  379 </span>      -- @
<span class="lineno">  380 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  381 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  382 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  383 </span>      -- ghci&gt; rqIsSecure \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  384 </span>      -- False
<span class="lineno">  385 </span>      -- @
<span class="lineno">  386 </span>    , rqIsSecure      :: !Bool
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>      -- | Contains all HTTP 'Headers' associated with this request.
<span class="lineno">  389 </span>      --
<span class="lineno">  390 </span>      -- Example:
<span class="lineno">  391 </span>      --
<span class="lineno">  392 </span>      -- @
<span class="lineno">  393 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  394 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  395 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  396 </span>      -- ghci&gt; rqHeaders \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  397 </span>      -- H {unH = [(&quot;host&quot;,&quot;localhost&quot;)]}
<span class="lineno">  398 </span>      -- @
<span class="lineno">  399 </span>    , rqHeaders       :: Headers
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>      -- | Actual body of the request.
<span class="lineno">  402 </span>    , rqBody          :: InputStream ByteString
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>      -- | Returns the @Content-Length@ of the HTTP request body.
<span class="lineno">  405 </span>      --
<span class="lineno">  406 </span>      -- Example:
<span class="lineno">  407 </span>      --
<span class="lineno">  408 </span>      -- @
<span class="lineno">  409 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  410 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  411 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  412 </span>      -- ghci&gt; rqContentLength \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  413 </span>      -- Nothing
<span class="lineno">  414 </span>      -- @
<span class="lineno">  415 </span>    , rqContentLength :: !(Maybe Word64)
<span class="lineno">  416 </span>
<span class="lineno">  417 </span>      -- | Returns the HTTP request method.
<span class="lineno">  418 </span>      --
<span class="lineno">  419 </span>      -- Example:
<span class="lineno">  420 </span>      --
<span class="lineno">  421 </span>      -- @
<span class="lineno">  422 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  423 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  424 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  425 </span>      -- ghci&gt; rqMethod \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  426 </span>      -- GET
<span class="lineno">  427 </span>      -- @
<span class="lineno">  428 </span>    , rqMethod        :: !Method
<span class="lineno">  429 </span>
<span class="lineno">  430 </span>      -- | Returns the HTTP version used by the client.
<span class="lineno">  431 </span>      --
<span class="lineno">  432 </span>      -- Example:
<span class="lineno">  433 </span>      --
<span class="lineno">  434 </span>      -- @
<span class="lineno">  435 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  436 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  437 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  438 </span>      -- ghci&gt; rqVersion \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  439 </span>      -- (1,1)
<span class="lineno">  440 </span>      -- @
<span class="lineno">  441 </span>    , rqVersion       :: {-# UNPACK #-} !HttpVersion
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>      -- | Returns a list of the cookies that came in from the HTTP request
<span class="lineno">  444 </span>      -- headers.
<span class="lineno">  445 </span>      --
<span class="lineno">  446 </span>      -- Example:
<span class="lineno">  447 </span>      --
<span class="lineno">  448 </span>      -- @
<span class="lineno">  449 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  450 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  451 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  452 </span>      -- ghci&gt; rqCookies \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  453 </span>      -- []
<span class="lineno">  454 </span>      -- @
<span class="lineno">  455 </span>    , rqCookies       :: [Cookie]
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>      -- | Handlers can be hung on a @URI@ \&quot;entry point\&quot;; this is called the
<span class="lineno">  458 </span>      -- \&quot;context path\&quot;. If a handler is hung on the context path
<span class="lineno">  459 </span>      -- @\&quot;\/foo\/\&quot;@, and you request @\&quot;\/foo\/bar\&quot;@, the value of
<span class="lineno">  460 </span>      -- 'rqPathInfo' will be @\&quot;bar\&quot;@.
<span class="lineno">  461 </span>      --
<span class="lineno">  462 </span>      -- The following identity holds:
<span class="lineno">  463 </span>      --
<span class="lineno">  464 </span>      -- &gt; rqURI r == S.concat [ rqContextPath r
<span class="lineno">  465 </span>      -- &gt;                     , rqPathInfo r
<span class="lineno">  466 </span>      -- &gt;                     , let q = rqQueryString r
<span class="lineno">  467 </span>      -- &gt;                       in if S.null q
<span class="lineno">  468 </span>      -- &gt;                            then &quot;&quot;
<span class="lineno">  469 </span>      -- &gt;                            else S.append &quot;?&quot; q
<span class="lineno">  470 </span>      -- &gt;                     ]
<span class="lineno">  471 </span>      --
<span class="lineno">  472 </span>      -- Example:
<span class="lineno">  473 </span>      --
<span class="lineno">  474 </span>      -- @
<span class="lineno">  475 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  476 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  477 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  478 </span>      -- ghci&gt; rqPathInfo \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  479 </span>      -- &quot;foo/bar&quot;
<span class="lineno">  480 </span>      -- @
<span class="lineno">  481 </span>    , rqPathInfo      :: ByteString
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>      -- | The \&quot;context path\&quot; of the request; catenating 'rqContextPath',
<span class="lineno">  484 </span>      -- and 'rqPathInfo' should get you back to the original 'rqURI'
<span class="lineno">  485 </span>      -- (ignoring query strings). The 'rqContextPath' always begins and ends
<span class="lineno">  486 </span>      -- with a slash (@\&quot;\/\&quot;@) character, and represents the path (relative
<span class="lineno">  487 </span>      -- to your component\/snaplet) you took to get to your handler.
<span class="lineno">  488 </span>      --
<span class="lineno">  489 </span>      -- Example:
<span class="lineno">  490 </span>      --
<span class="lineno">  491 </span>      -- @
<span class="lineno">  492 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  493 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  494 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  495 </span>      -- ghci&gt; rqContextPath \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  496 </span>      -- &quot;/&quot;
<span class="lineno">  497 </span>      -- @
<span class="lineno">  498 </span>    , rqContextPath   :: ByteString
<span class="lineno">  499 </span>
<span class="lineno">  500 </span>      -- | Returns the @URI@ requested by the client.
<span class="lineno">  501 </span>      --
<span class="lineno">  502 </span>      -- Example:
<span class="lineno">  503 </span>      --
<span class="lineno">  504 </span>      -- @
<span class="lineno">  505 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  506 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  507 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  508 </span>      -- ghci&gt; rqURI \`fmap\` T.buildRequest (T.get &quot;\/foo\/bar&quot; M.empty)
<span class="lineno">  509 </span>      -- &quot;foo/bar&quot;
<span class="lineno">  510 </span>      -- @
<span class="lineno">  511 </span>    , rqURI           :: ByteString
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>      -- | Returns the HTTP query string for this 'Request'.
<span class="lineno">  514 </span>      --
<span class="lineno">  515 </span>      -- Example:
<span class="lineno">  516 </span>      --
<span class="lineno">  517 </span>      -- @
<span class="lineno">  518 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  519 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  520 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  521 </span>      -- ghci&gt; rq &lt;- T.buildRequest (T.get &quot;\/foo\/bar&quot; (M.fromList [(&quot;name&quot;, [&quot;value&quot;])]))
<span class="lineno">  522 </span>      -- ghci&gt; rqQueryString rq
<span class="lineno">  523 </span>      -- &quot;name=value&quot;
<span class="lineno">  524 </span>      -- @
<span class="lineno">  525 </span>    , rqQueryString   :: ByteString
<span class="lineno">  526 </span>
<span class="lineno">  527 </span>      -- | Returns the parameters mapping for this 'Request'. \&quot;Parameters\&quot;
<span class="lineno">  528 </span>      -- are automatically decoded from the URI's query string and @POST@ body
<span class="lineno">  529 </span>      -- and entered into this mapping. The 'rqParams' value is thus a union of
<span class="lineno">  530 </span>      -- 'rqQueryParams' and 'rqPostParams'.
<span class="lineno">  531 </span>      --
<span class="lineno">  532 </span>      -- Example:
<span class="lineno">  533 </span>      --
<span class="lineno">  534 </span>      -- @
<span class="lineno">  535 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  536 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  537 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  538 </span>      -- ghci&gt; :{
<span class="lineno">  539 </span>      -- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  540 </span>      -- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  541 </span>      -- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  542 </span>      -- ghci| :}
<span class="lineno">  543 </span>      -- ghci&gt; rqParams rq
<span class="lineno">  544 </span>      -- fromList [(&quot;baz&quot;,[&quot;qux&quot;,&quot;quux&quot;])]
<span class="lineno">  545 </span>      -- @
<span class="lineno">  546 </span>    , rqParams        :: Params
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>      -- | The parameter mapping decoded from the URI's query string.
<span class="lineno">  549 </span>      --
<span class="lineno">  550 </span>      -- Example:
<span class="lineno">  551 </span>      --
<span class="lineno">  552 </span>      -- @
<span class="lineno">  553 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  554 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  555 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  556 </span>      -- ghci&gt; :{
<span class="lineno">  557 </span>      -- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  558 </span>      -- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  559 </span>      -- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  560 </span>      -- ghci| :}
<span class="lineno">  561 </span>      -- ghci&gt; rqQueryParams rq
<span class="lineno">  562 </span>      -- fromList [(&quot;baz&quot;,[&quot;quux&quot;])]
<span class="lineno">  563 </span>      -- @
<span class="lineno">  564 </span>    , rqQueryParams   :: Params
<span class="lineno">  565 </span>
<span class="lineno">  566 </span>      -- | The parameter mapping decoded from the POST body. Note that Snap
<span class="lineno">  567 </span>      -- only auto-decodes POST request bodies when the request's
<span class="lineno">  568 </span>      -- @Content-Type@ is @application\/x-www-form-urlencoded@.
<span class="lineno">  569 </span>      -- For @multipart\/form-data@ use 'Snap.Util.FileUploads.handleFileUploads'
<span class="lineno">  570 </span>      -- to decode the POST request and fill this mapping.
<span class="lineno">  571 </span>      --
<span class="lineno">  572 </span>      -- Example:
<span class="lineno">  573 </span>      --
<span class="lineno">  574 </span>      -- @
<span class="lineno">  575 </span>      -- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  576 </span>      -- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  577 </span>      -- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  578 </span>      -- ghci&gt; :{
<span class="lineno">  579 </span>      -- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  580 </span>      -- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  581 </span>      -- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  582 </span>      -- ghci| :}
<span class="lineno">  583 </span>      -- ghci&gt; rqPostParams rq
<span class="lineno">  584 </span>      -- fromList [(&quot;baz&quot;,[&quot;qux&quot;])]
<span class="lineno">  585 </span>      -- @
<span class="lineno">  586 </span>    , rqPostParams    :: Params
<span class="lineno">  587 </span>    }
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>------------------------------------------------------------------------------
<span class="lineno">  591 </span>instance Show Request where
<span class="lineno">  592 </span>  <span class="decl"><span class="istickedoff">show r = concat [ method, &quot; &quot;, uri, &quot; HTTP/&quot;, version, &quot;\n&quot;</span>
<span class="lineno">  593 </span><span class="spaces">                  </span><span class="istickedoff">, hdrs, &quot;\n\n&quot;</span>
<span class="lineno">  594 </span><span class="spaces">                  </span><span class="istickedoff">, &quot;sn=\&quot;&quot;, sname, &quot;\&quot; c=&quot;, clntAddr, &quot; s=&quot;, srvAddr</span>
<span class="lineno">  595 </span><span class="spaces">                  </span><span class="istickedoff">, &quot; ctx=&quot;, contextpath, &quot; clen=&quot;, contentlength, secure</span>
<span class="lineno">  596 </span><span class="spaces">                  </span><span class="istickedoff">, params, cookies</span>
<span class="lineno">  597 </span><span class="spaces">                  </span><span class="istickedoff">]</span>
<span class="lineno">  598 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  599 </span><span class="spaces">      </span><span class="istickedoff">method        = show $ rqMethod r</span>
<span class="lineno">  600 </span><span class="spaces">      </span><span class="istickedoff">uri           = S.unpack $ rqURI r</span>
<span class="lineno">  601 </span><span class="spaces">      </span><span class="istickedoff">version       = let (mj, mn) = rqVersion r in show mj ++ &quot;.&quot; ++ show mn</span>
<span class="lineno">  602 </span><span class="spaces">      </span><span class="istickedoff">hdrs          = intercalate &quot;\n&quot; $ map showHdr (H.toList $ rqHeaders r)</span>
<span class="lineno">  603 </span><span class="spaces">      </span><span class="istickedoff">showHdr (a,b) = (S.unpack $ CI.original a) ++ &quot;: &quot; ++ S.unpack b</span>
<span class="lineno">  604 </span><span class="spaces">      </span><span class="istickedoff">sname         = S.unpack $ rqLocalHostname r</span>
<span class="lineno">  605 </span><span class="spaces">      </span><span class="istickedoff">clntAddr      = concat [S.unpack $ rqClientAddr r, &quot;:&quot;, show $ rqClientPort r]</span>
<span class="lineno">  606 </span><span class="spaces">      </span><span class="istickedoff">srvAddr       = concat [S.unpack $ rqServerAddr r, &quot;:&quot;, show $ rqServerPort r]</span>
<span class="lineno">  607 </span><span class="spaces">      </span><span class="istickedoff">contextpath   = S.unpack $ rqContextPath r</span>
<span class="lineno">  608 </span><span class="spaces">      </span><span class="istickedoff">contentlength = maybe &quot;n/a&quot; show (rqContentLength r)</span>
<span class="lineno">  609 </span><span class="spaces">      </span><span class="istickedoff">secure        = if rqIsSecure r then &quot; secure&quot; else &quot;&quot;</span>
<span class="lineno">  610 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  611 </span><span class="spaces">      </span><span class="istickedoff">params        = showFlds &quot;\nparams: &quot; &quot;, &quot; $</span>
<span class="lineno">  612 </span><span class="spaces">                      </span><span class="istickedoff">map (\ (a,b) -&gt; S.unpack a ++ &quot;: &quot; ++ show b)</span>
<span class="lineno">  613 </span><span class="spaces">                      </span><span class="istickedoff">(Map.toAscList $ rqParams r)</span>
<span class="lineno">  614 </span><span class="spaces">      </span><span class="istickedoff">cookies       = showFlds &quot;\ncookies: &quot; &quot;\n         &quot; $</span>
<span class="lineno">  615 </span><span class="spaces">                      </span><span class="istickedoff">map show (rqCookies r)</span>
<span class="lineno">  616 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  617 </span><span class="spaces">      </span><span class="istickedoff">showFlds header delim lst</span>
<span class="lineno">  618 </span><span class="spaces">                    </span><span class="istickedoff">= if not . null $ lst then header ++ (intercalate delim lst)</span>
<span class="lineno">  619 </span><span class="spaces">                      </span><span class="istickedoff">else &quot;&quot; :: String</span></span>
<span class="lineno">  620 </span>
<span class="lineno">  621 </span>------------------------------------------------------------------------------
<span class="lineno">  622 </span>instance HasHeaders Request where
<span class="lineno">  623 </span>    <span class="decl"><span class="istickedoff">headers           = rqHeaders</span></span>
<span class="lineno">  624 </span>    <span class="decl"><span class="istickedoff">updateHeaders f r = r { rqHeaders = f (rqHeaders r) }</span></span>
<span class="lineno">  625 </span>
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>------------------------------------------------------------------------------
<span class="lineno">  628 </span>instance HasHeaders Headers where
<span class="lineno">  629 </span>    <span class="decl"><span class="istickedoff">headers       = id</span></span>
<span class="lineno">  630 </span>    <span class="decl"><span class="istickedoff">updateHeaders = id</span></span>
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>------------------------------------------------------------------------------
<span class="lineno">  633 </span>-- response type
<span class="lineno">  634 </span>------------------------------------------------------------------------------
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>type StreamProc = OutputStream Builder -&gt; IO (OutputStream Builder)
<span class="lineno">  637 </span>data ResponseBody = Stream (StreamProc)
<span class="lineno">  638 </span>                      -- ^ output body is a function that writes to a 'Builder'
<span class="lineno">  639 </span>                      -- stream
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>                  | SendFile FilePath (Maybe (Word64, Word64))
<span class="lineno">  642 </span>                      -- ^ output body is sendfile(), optional second argument
<span class="lineno">  643 </span>                      --   is a byte range to send
<span class="lineno">  644 </span>
<span class="lineno">  645 </span>
<span class="lineno">  646 </span>------------------------------------------------------------------------------
<span class="lineno">  647 </span>rspBodyMap :: (StreamProc -&gt; StreamProc) -&gt; ResponseBody -&gt; ResponseBody
<span class="lineno">  648 </span><span class="decl"><span class="istickedoff">rspBodyMap f b = Stream $ f $ rspBodyToEnum b</span></span>
<span class="lineno">  649 </span>
<span class="lineno">  650 </span>
<span class="lineno">  651 </span>------------------------------------------------------------------------------
<span class="lineno">  652 </span>rspBodyToEnum :: ResponseBody -&gt; StreamProc
<span class="lineno">  653 </span><span class="decl"><span class="istickedoff">rspBodyToEnum (Stream e) = e</span>
<span class="lineno">  654 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  655 </span><span class="spaces"></span><span class="istickedoff">rspBodyToEnum (SendFile fp Nothing) = \out -&gt;</span>
<span class="lineno">  656 </span><span class="spaces">    </span><span class="istickedoff">Streams.withFileAsInput fp $ \is -&gt; do</span>
<span class="lineno">  657 </span><span class="spaces">        </span><span class="istickedoff">is' &lt;- Streams.mapM (return . byteString) is</span>
<span class="lineno">  658 </span><span class="spaces">        </span><span class="istickedoff">Streams.connect is' out</span>
<span class="lineno">  659 </span><span class="spaces">        </span><span class="istickedoff">return out</span>
<span class="lineno">  660 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  661 </span><span class="spaces"></span><span class="istickedoff">rspBodyToEnum (SendFile fp (Just (start, end))) = \out -&gt;</span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="istickedoff">withBinaryFile fp ReadMode $ \handle -&gt; do</span>
<span class="lineno">  663 </span><span class="spaces">        </span><span class="istickedoff">unless (start == 0) $ hSeek handle AbsoluteSeek $ toInteger start</span>
<span class="lineno">  664 </span><span class="spaces">        </span><span class="istickedoff">is  &lt;- Streams.handleToInputStream handle</span>
<span class="lineno">  665 </span><span class="spaces">        </span><span class="istickedoff">is' &lt;- Streams.takeBytes (fromIntegral $ end - start) is &gt;&gt;=</span>
<span class="lineno">  666 </span><span class="spaces">               </span><span class="istickedoff">Streams.mapM (return . byteString)</span>
<span class="lineno">  667 </span><span class="spaces">        </span><span class="istickedoff">Streams.connect is' out</span>
<span class="lineno">  668 </span><span class="spaces">        </span><span class="istickedoff">return out</span></span>
<span class="lineno">  669 </span>
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>------------------------------------------------------------------------------
<span class="lineno">  672 </span>-- | Represents an HTTP response.
<span class="lineno">  673 </span>data Response = Response
<span class="lineno">  674 </span>    { rspHeaders            :: Headers
<span class="lineno">  675 </span>    , rspCookies            :: Map ByteString Cookie
<span class="lineno">  676 </span>
<span class="lineno">  677 </span>      -- | We will need to inspect the content length no matter what, and
<span class="lineno">  678 </span>      --   looking up \&quot;content-length\&quot; in the headers and parsing the number
<span class="lineno">  679 </span>      --   out of the text will be too expensive.
<span class="lineno">  680 </span>    , rspContentLength      :: !(Maybe Word64)
<span class="lineno">  681 </span>    , rspBody               :: ResponseBody
<span class="lineno">  682 </span>
<span class="lineno">  683 </span>      -- | Returns the HTTP status code.
<span class="lineno">  684 </span>      --
<span class="lineno">  685 </span>      -- Example:
<span class="lineno">  686 </span>      --
<span class="lineno">  687 </span>      -- @
<span class="lineno">  688 </span>      -- ghci&gt; rspStatus 'emptyResponse'
<span class="lineno">  689 </span>      -- 200
<span class="lineno">  690 </span>      -- @
<span class="lineno">  691 </span>    , rspStatus             :: !Int
<span class="lineno">  692 </span>
<span class="lineno">  693 </span>      -- | Returns the HTTP status explanation string.
<span class="lineno">  694 </span>      --
<span class="lineno">  695 </span>      -- Example:
<span class="lineno">  696 </span>      --
<span class="lineno">  697 </span>      -- @
<span class="lineno">  698 </span>      -- ghci&gt; rspStatusReason 'emptyResponse'
<span class="lineno">  699 </span>      -- &quot;OK&quot;
<span class="lineno">  700 </span>      -- @
<span class="lineno">  701 </span>    , rspStatusReason       :: !ByteString
<span class="lineno">  702 </span>
<span class="lineno">  703 </span>      -- | If true, we are transforming the request body with
<span class="lineno">  704 </span>      -- 'transformRequestBody'
<span class="lineno">  705 </span>    , rspTransformingRqBody :: !Bool
<span class="lineno">  706 </span>    }
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>------------------------------------------------------------------------------
<span class="lineno">  710 </span>instance Show Response where
<span class="lineno">  711 </span>  <span class="decl"><span class="istickedoff">show r = concat [ statusline</span>
<span class="lineno">  712 </span><span class="spaces">                  </span><span class="istickedoff">, hdrs</span>
<span class="lineno">  713 </span><span class="spaces">                  </span><span class="istickedoff">, contentLength</span>
<span class="lineno">  714 </span><span class="spaces">                  </span><span class="istickedoff">, &quot;\r\n&quot;</span>
<span class="lineno">  715 </span><span class="spaces">                  </span><span class="istickedoff">, body</span>
<span class="lineno">  716 </span><span class="spaces">                  </span><span class="istickedoff">]</span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  718 </span><span class="spaces">      </span><span class="istickedoff">statusline = concat [ &quot;HTTP/1.1 &quot;</span>
<span class="lineno">  719 </span><span class="spaces">                          </span><span class="istickedoff">, show $ rspStatus r</span>
<span class="lineno">  720 </span><span class="spaces">                          </span><span class="istickedoff">, &quot; &quot;</span>
<span class="lineno">  721 </span><span class="spaces">                          </span><span class="istickedoff">, S.unpack $ rspStatusReason r</span>
<span class="lineno">  722 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;\r\n&quot; ]</span>
<span class="lineno">  723 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  724 </span><span class="spaces">      </span><span class="istickedoff">hdrs = concatMap showHdr $ H.toList $ renderCookies r</span>
<span class="lineno">  725 </span><span class="spaces">             </span><span class="istickedoff">$ rspHeaders $ clearContentLength r</span>
<span class="lineno">  726 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  727 </span><span class="spaces">      </span><span class="istickedoff">contentLength = maybe &quot;&quot; (\l -&gt; concat [&quot;Content-Length: &quot;, show l, &quot;\r\n&quot;] ) (rspContentLength r)</span>
<span class="lineno">  728 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  729 </span><span class="spaces">      </span><span class="istickedoff">showHdr (k,v) = concat [ S.unpack (CI.original k), &quot;: &quot;, S.unpack v, &quot;\r\n&quot; ]</span>
<span class="lineno">  730 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  731 </span><span class="spaces">      </span><span class="istickedoff">-- io-streams are impure, so we're forced to use 'unsafePerformIO'.</span>
<span class="lineno">  732 </span><span class="spaces">      </span><span class="istickedoff">body = unsafePerformIO $ do</span>
<span class="lineno">  733 </span><span class="spaces">        </span><span class="istickedoff">(os, grab) &lt;- Streams.listOutputStream</span>
<span class="lineno">  734 </span><span class="spaces">        </span><span class="istickedoff">let f = rspBodyToEnum $ rspBody r</span>
<span class="lineno">  735 </span><span class="spaces">        </span><span class="istickedoff">_ &lt;- f os</span>
<span class="lineno">  736 </span><span class="spaces">        </span><span class="istickedoff">fmap (L.unpack . toLazyByteString . mconcat) grab</span></span>
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>
<span class="lineno">  740 </span>------------------------------------------------------------------------------
<span class="lineno">  741 </span>instance HasHeaders Response where
<span class="lineno">  742 </span>    <span class="decl"><span class="istickedoff">headers = rspHeaders</span></span>
<span class="lineno">  743 </span>    <span class="decl"><span class="istickedoff">updateHeaders f r = r { rspHeaders = f (rspHeaders r) }</span></span>
<span class="lineno">  744 </span>
<span class="lineno">  745 </span>
<span class="lineno">  746 </span>------------------------------------------------------------------------------
<span class="lineno">  747 </span>-- | Looks up the value(s) for the given named parameter. Parameters initially
<span class="lineno">  748 </span>-- come from the request's query string and any decoded POST body (if the
<span class="lineno">  749 </span>-- request's @Content-Type@ is @application\/x-www-form-urlencoded@).
<span class="lineno">  750 </span>-- Parameter values can be modified within handlers using &quot;rqModifyParams&quot;.
<span class="lineno">  751 </span>--
<span class="lineno">  752 </span>-- Example:
<span class="lineno">  753 </span>--
<span class="lineno">  754 </span>-- @
<span class="lineno">  755 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  756 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  757 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  758 </span>-- ghci&gt; :{
<span class="lineno">  759 </span>-- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  760 </span>-- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  761 </span>-- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  762 </span>-- ghci| :}
<span class="lineno">  763 </span>-- ghci&gt; 'rqParam' &quot;baz&quot; rq
<span class="lineno">  764 </span>-- Just [&quot;qux&quot;,&quot;quux&quot;]
<span class="lineno">  765 </span>-- @
<span class="lineno">  766 </span>rqParam :: ByteString           -- ^ parameter name to look up
<span class="lineno">  767 </span>        -&gt; Request              -- ^ HTTP request
<span class="lineno">  768 </span>        -&gt; Maybe [ByteString]
<span class="lineno">  769 </span><span class="decl"><span class="istickedoff">rqParam k rq = Map.lookup k $ rqParams rq</span></span>
<span class="lineno">  770 </span>{-# INLINE rqParam #-}
<span class="lineno">  771 </span>
<span class="lineno">  772 </span>
<span class="lineno">  773 </span>------------------------------------------------------------------------------
<span class="lineno">  774 </span>-- | Looks up the value(s) for the given named parameter in the POST parameters
<span class="lineno">  775 </span>-- mapping.
<span class="lineno">  776 </span>--
<span class="lineno">  777 </span>-- Example:
<span class="lineno">  778 </span>--
<span class="lineno">  779 </span>-- @
<span class="lineno">  780 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  781 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  782 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  783 </span>-- ghci&gt; :{
<span class="lineno">  784 </span>-- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  785 </span>-- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  786 </span>-- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  787 </span>-- ghci| :}
<span class="lineno">  788 </span>-- ghci&gt; 'rqPostParam' &quot;baz&quot; rq
<span class="lineno">  789 </span>-- Just [&quot;qux&quot;]
<span class="lineno">  790 </span>-- @
<span class="lineno">  791 </span>rqPostParam :: ByteString           -- ^ parameter name to look up
<span class="lineno">  792 </span>            -&gt; Request              -- ^ HTTP request
<span class="lineno">  793 </span>            -&gt; Maybe [ByteString]
<span class="lineno">  794 </span><span class="decl"><span class="istickedoff">rqPostParam k rq = Map.lookup k $ rqPostParams rq</span></span>
<span class="lineno">  795 </span>{-# INLINE rqPostParam #-}
<span class="lineno">  796 </span>
<span class="lineno">  797 </span>
<span class="lineno">  798 </span>------------------------------------------------------------------------------
<span class="lineno">  799 </span>-- | Looks up the value(s) for the given named parameter in the query
<span class="lineno">  800 </span>-- parameters mapping.
<span class="lineno">  801 </span>--
<span class="lineno">  802 </span>-- Example:
<span class="lineno">  803 </span>--
<span class="lineno">  804 </span>-- @
<span class="lineno">  805 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  806 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  807 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  808 </span>-- ghci&gt; :{
<span class="lineno">  809 </span>-- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  810 </span>-- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  811 </span>-- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  812 </span>-- ghci| :}
<span class="lineno">  813 </span>-- ghci&gt; 'rqQueryParam' &quot;baz&quot; rq
<span class="lineno">  814 </span>-- Just [&quot;quux&quot;]
<span class="lineno">  815 </span>-- @
<span class="lineno">  816 </span>rqQueryParam :: ByteString           -- ^ parameter name to look up
<span class="lineno">  817 </span>             -&gt; Request              -- ^ HTTP request
<span class="lineno">  818 </span>             -&gt; Maybe [ByteString]
<span class="lineno">  819 </span><span class="decl"><span class="istickedoff">rqQueryParam k rq = Map.lookup k $ rqQueryParams rq</span></span>
<span class="lineno">  820 </span>{-# INLINE rqQueryParam #-}
<span class="lineno">  821 </span>
<span class="lineno">  822 </span>
<span class="lineno">  823 </span>------------------------------------------------------------------------------
<span class="lineno">  824 </span>-- | Modifies the parameters mapping (which is a @Map ByteString ByteString@)
<span class="lineno">  825 </span>-- in a 'Request' using the given function.
<span class="lineno">  826 </span>--
<span class="lineno">  827 </span>-- Example:
<span class="lineno">  828 </span>--
<span class="lineno">  829 </span>-- @
<span class="lineno">  830 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  831 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  832 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  833 </span>-- ghci&gt; :{
<span class="lineno">  834 </span>-- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  835 </span>-- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  836 </span>-- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  837 </span>-- ghci| :}
<span class="lineno">  838 </span>-- ghci&gt; 'rqParams' rq
<span class="lineno">  839 </span>-- fromList [(&quot;baz&quot;,[&quot;qux&quot;,&quot;quux&quot;])]
<span class="lineno">  840 </span>-- ghci&gt; 'rqParams' $ 'rqModifyParams' (M.delete &quot;baz&quot;) rq
<span class="lineno">  841 </span>-- fromList []
<span class="lineno">  842 </span>-- @
<span class="lineno">  843 </span>rqModifyParams :: (Params -&gt; Params) -&gt; Request -&gt; Request
<span class="lineno">  844 </span><span class="decl"><span class="istickedoff">rqModifyParams f r = r { rqParams = p }</span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  846 </span><span class="spaces">    </span><span class="istickedoff">p = f $ rqParams r</span></span>
<span class="lineno">  847 </span>{-# INLINE rqModifyParams #-}
<span class="lineno">  848 </span>
<span class="lineno">  849 </span>
<span class="lineno">  850 </span>------------------------------------------------------------------------------
<span class="lineno">  851 </span>-- | Writes a key-value pair to the parameters mapping within the given
<span class="lineno">  852 </span>-- request.
<span class="lineno">  853 </span>--
<span class="lineno">  854 </span>-- Example:
<span class="lineno">  855 </span>--
<span class="lineno">  856 </span>-- @
<span class="lineno">  857 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  858 </span>-- ghci&gt; import qualified &quot;Snap.Test&quot; as T
<span class="lineno">  859 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  860 </span>-- ghci&gt; :{
<span class="lineno">  861 </span>-- ghci| rq &lt;- T.buildRequest $ do
<span class="lineno">  862 </span>-- ghci|         T.postUrlEncoded &quot;\/foo\/bar&quot; $ M.fromList [(&quot;baz&quot;, [&quot;qux&quot;])]
<span class="lineno">  863 </span>-- ghci|         T.setQueryStringRaw &quot;baz=quux&quot;
<span class="lineno">  864 </span>-- ghci| :}
<span class="lineno">  865 </span>-- ghci&gt; 'rqParams' rq
<span class="lineno">  866 </span>-- fromList [(&quot;baz&quot;,[&quot;qux&quot;,&quot;quux&quot;])]
<span class="lineno">  867 </span>-- ghci&gt; 'rqParams' $ 'rqSetParam' &quot;baz&quot; [&quot;corge&quot;] rq
<span class="lineno">  868 </span>-- fromList [(&quot;baz&quot;, [&quot;corge&quot;])]
<span class="lineno">  869 </span>-- @
<span class="lineno">  870 </span>rqSetParam :: ByteString        -- ^ parameter name
<span class="lineno">  871 </span>           -&gt; [ByteString]      -- ^ parameter values
<span class="lineno">  872 </span>           -&gt; Request           -- ^ request
<span class="lineno">  873 </span>           -&gt; Request
<span class="lineno">  874 </span><span class="decl"><span class="istickedoff">rqSetParam k v = rqModifyParams $ Map.insert k v</span></span>
<span class="lineno">  875 </span>{-# INLINE rqSetParam #-}
<span class="lineno">  876 </span>
<span class="lineno">  877 </span>
<span class="lineno">  878 </span>                                ---------------
<span class="lineno">  879 </span>                                -- responses --
<span class="lineno">  880 </span>                                ---------------
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>------------------------------------------------------------------------------
<span class="lineno">  883 </span>-- | An empty 'Response'.
<span class="lineno">  884 </span>--
<span class="lineno">  885 </span>-- Example:
<span class="lineno">  886 </span>--
<span class="lineno">  887 </span>-- @
<span class="lineno">  888 </span>-- ghci&gt; 'emptyResponse'
<span class="lineno">  889 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  890 </span>--
<span class="lineno">  891 </span>--
<span class="lineno">  892 </span>-- @
<span class="lineno">  893 </span>emptyResponse :: Response
<span class="lineno">  894 </span><span class="decl"><span class="istickedoff">emptyResponse = Response H.empty Map.empty Nothing</span>
<span class="lineno">  895 </span><span class="spaces">                         </span><span class="istickedoff">(Stream (return . id))</span>
<span class="lineno">  896 </span><span class="spaces">                         </span><span class="istickedoff">200 &quot;OK&quot; False</span></span>
<span class="lineno">  897 </span>
<span class="lineno">  898 </span>
<span class="lineno">  899 </span>------------------------------------------------------------------------------
<span class="lineno">  900 </span>-- | Sets an HTTP response body to the given stream procedure.
<span class="lineno">  901 </span>--
<span class="lineno">  902 </span>-- Example:
<span class="lineno">  903 </span>--
<span class="lineno">  904 </span>-- @
<span class="lineno">  905 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  906 </span>-- ghci&gt; import qualified &quot;System.IO.Streams&quot; as Streams
<span class="lineno">  907 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Builder&quot; as Builder
<span class="lineno">  908 </span>-- ghci&gt; :{
<span class="lineno">  909 </span>-- ghci| let r = 'setResponseBody'
<span class="lineno">  910 </span>-- ghci|         (\out -&gt; do
<span class="lineno">  911 </span>-- ghci|             Streams.write (Just $ Builder.'byteString' \&quot;Hello, world!\&quot;) out
<span class="lineno">  912 </span>-- ghci|             return out)
<span class="lineno">  913 </span>-- ghci|         'emptyResponse'
<span class="lineno">  914 </span>-- ghci| :}
<span class="lineno">  915 </span>-- ghci&gt; r
<span class="lineno">  916 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  917 </span>--
<span class="lineno">  918 </span>-- Hello, world!
<span class="lineno">  919 </span>-- @
<span class="lineno">  920 </span>setResponseBody     :: (OutputStream Builder -&gt; IO (OutputStream Builder))
<span class="lineno">  921 </span>                                   -- ^ new response body
<span class="lineno">  922 </span>                    -&gt; Response    -- ^ response to modify
<span class="lineno">  923 </span>                    -&gt; Response
<span class="lineno">  924 </span><span class="decl"><span class="istickedoff">setResponseBody e r = r { rspBody = Stream e }</span></span>
<span class="lineno">  925 </span>{-# INLINE setResponseBody #-}
<span class="lineno">  926 </span>
<span class="lineno">  927 </span>
<span class="lineno">  928 </span>------------------------------------------------------------------------------
<span class="lineno">  929 </span>-- | Sets the HTTP response status. Note: normally you would use
<span class="lineno">  930 </span>-- 'setResponseCode' unless you needed a custom response explanation.
<span class="lineno">  931 </span>--
<span class="lineno">  932 </span>--
<span class="lineno">  933 </span>-- Example:
<span class="lineno">  934 </span>--
<span class="lineno">  935 </span>-- @
<span class="lineno">  936 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  937 </span>-- ghci&gt; setResponseStatus 500 \&quot;Internal Server Error\&quot; 'emptyResponse'
<span class="lineno">  938 </span>-- HTTP\/1.1 500 Internal Server Error
<span class="lineno">  939 </span>--
<span class="lineno">  940 </span>--
<span class="lineno">  941 </span>-- @
<span class="lineno">  942 </span>setResponseStatus   :: Int        -- ^ HTTP response integer code
<span class="lineno">  943 </span>                    -&gt; ByteString -- ^ HTTP response explanation
<span class="lineno">  944 </span>                    -&gt; Response   -- ^ Response to be modified
<span class="lineno">  945 </span>                    -&gt; Response
<span class="lineno">  946 </span><span class="decl"><span class="istickedoff">setResponseStatus s reason r = r { rspStatus=s, rspStatusReason=reason }</span></span>
<span class="lineno">  947 </span>{-# INLINE setResponseStatus #-}
<span class="lineno">  948 </span>
<span class="lineno">  949 </span>
<span class="lineno">  950 </span>------------------------------------------------------------------------------
<span class="lineno">  951 </span>-- | Sets the HTTP response code.
<span class="lineno">  952 </span>--
<span class="lineno">  953 </span>-- Example:
<span class="lineno">  954 </span>--
<span class="lineno">  955 </span>-- @
<span class="lineno">  956 </span>-- ghci&gt; setResponseCode 404 'emptyResponse'
<span class="lineno">  957 </span>-- HTTP\/1.1 404 Not Found
<span class="lineno">  958 </span>--
<span class="lineno">  959 </span>--
<span class="lineno">  960 </span>-- @
<span class="lineno">  961 </span>setResponseCode   :: Int        -- ^ HTTP response integer code
<span class="lineno">  962 </span>                  -&gt; Response   -- ^ Response to be modified
<span class="lineno">  963 </span>                  -&gt; Response
<span class="lineno">  964 </span><span class="decl"><span class="istickedoff">setResponseCode s r = setResponseStatus s reason r</span>
<span class="lineno">  965 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  966 </span><span class="spaces">    </span><span class="istickedoff">reason = fromMaybe &quot;Unknown&quot; (IM.lookup s statusReasonMap)</span></span>
<span class="lineno">  967 </span>{-# INLINE setResponseCode #-}
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>
<span class="lineno">  970 </span>------------------------------------------------------------------------------
<span class="lineno">  971 </span>-- | Modifies a response body.
<span class="lineno">  972 </span>--
<span class="lineno">  973 </span>-- Example:
<span class="lineno">  974 </span>--
<span class="lineno">  975 </span>-- @
<span class="lineno">  976 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  977 </span>-- ghci&gt; import qualified &quot;System.IO.Streams&quot; as Streams
<span class="lineno">  978 </span>-- ghci&gt; import qualified &quot;Data.ByteString.Builder&quot; as Builder
<span class="lineno">  979 </span>-- ghci&gt; :{
<span class="lineno">  980 </span>-- ghci| let r = 'setResponseBody'
<span class="lineno">  981 </span>-- ghci|         (\out -&gt; do
<span class="lineno">  982 </span>-- ghci|             Streams.write (Just $ Builder.'byteString' \&quot;Hello, world!\&quot;) out
<span class="lineno">  983 </span>-- ghci|             return out)
<span class="lineno">  984 </span>-- ghci|         'emptyResponse'
<span class="lineno">  985 </span>-- ghci| :}
<span class="lineno">  986 </span>-- ghci&gt; r
<span class="lineno">  987 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  988 </span>--
<span class="lineno">  989 </span>-- Hello, world!
<span class="lineno">  990 </span>-- ghci&gt; :{
<span class="lineno">  991 </span>-- ghci| let r' = 'modifyResponseBody'
<span class="lineno">  992 </span>-- ghci|          (\f out -&gt; do
<span class="lineno">  993 </span>-- ghci|              out' &lt;- f out
<span class="lineno">  994 </span>-- ghci|              Streams.write (Just $ Builder.'byteString' \&quot;\\nBye, world!\&quot;) out'
<span class="lineno">  995 </span>-- ghci|              return out') r
<span class="lineno">  996 </span>-- ghci| :}
<span class="lineno">  997 </span>-- ghci&gt; r'
<span class="lineno">  998 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  999 </span>--
<span class="lineno"> 1000 </span>-- Hello, world!
<span class="lineno"> 1001 </span>-- Bye, world!
<span class="lineno"> 1002 </span>-- @
<span class="lineno"> 1003 </span>modifyResponseBody  :: ((OutputStream Builder -&gt; IO (OutputStream Builder)) -&gt;
<span class="lineno"> 1004 </span>                        (OutputStream Builder -&gt; IO (OutputStream Builder)))
<span class="lineno"> 1005 </span>                    -&gt; Response
<span class="lineno"> 1006 </span>                    -&gt; Response
<span class="lineno"> 1007 </span><span class="decl"><span class="istickedoff">modifyResponseBody f r = r { rspBody = rspBodyMap f (rspBody r) }</span></span>
<span class="lineno"> 1008 </span>{-# INLINE modifyResponseBody #-}
<span class="lineno"> 1009 </span>
<span class="lineno"> 1010 </span>
<span class="lineno"> 1011 </span>------------------------------------------------------------------------------
<span class="lineno"> 1012 </span>-- | Sets the @Content-Type@ in the 'Response' headers.
<span class="lineno"> 1013 </span>--
<span class="lineno"> 1014 </span>-- Example:
<span class="lineno"> 1015 </span>--
<span class="lineno"> 1016 </span>-- @
<span class="lineno"> 1017 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1018 </span>-- ghci&gt; setContentType \&quot;text\/html\&quot; 'emptyResponse'
<span class="lineno"> 1019 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1020 </span>-- content-type: text\/html
<span class="lineno"> 1021 </span>--
<span class="lineno"> 1022 </span>--
<span class="lineno"> 1023 </span>-- @
<span class="lineno"> 1024 </span>setContentType      :: ByteString -&gt; Response -&gt; Response
<span class="lineno"> 1025 </span><span class="decl"><span class="istickedoff">setContentType = setHeader &quot;Content-Type&quot;</span></span>
<span class="lineno"> 1026 </span>{-# INLINE setContentType #-}
<span class="lineno"> 1027 </span>
<span class="lineno"> 1028 </span>
<span class="lineno"> 1029 </span>------------------------------------------------------------------------------
<span class="lineno"> 1030 </span>-- | Convert 'Cookie' into 'ByteString' for output.
<span class="lineno"> 1031 </span>--
<span class="lineno"> 1032 </span>-- TODO: Remove duplication. This function is copied from
<span class="lineno"> 1033 </span>-- snap-server/Snap.Internal.Http.Server.Session.
<span class="lineno"> 1034 </span>cookieToBS :: Cookie -&gt; ByteString
<span class="lineno"> 1035 </span><span class="decl"><span class="istickedoff">cookieToBS (Cookie k v mbExpTime mbDomain mbPath isSec isHOnly) = cookie</span>
<span class="lineno"> 1036 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1037 </span><span class="spaces">    </span><span class="istickedoff">cookie = S.concat [k, &quot;=&quot;, v, path, exptime, domain, secure, hOnly]</span>
<span class="lineno"> 1038 </span><span class="spaces">    </span><span class="istickedoff">path = maybe &quot;&quot; (S.append &quot;; path=&quot;) mbPath</span>
<span class="lineno"> 1039 </span><span class="spaces">    </span><span class="istickedoff">domain = maybe &quot;&quot; (S.append &quot;; domain=&quot;) mbDomain</span>
<span class="lineno"> 1040 </span><span class="spaces">    </span><span class="istickedoff">exptime = maybe &quot;&quot; (S.append &quot;; expires=&quot; . fmt) mbExpTime</span>
<span class="lineno"> 1041 </span><span class="spaces">    </span><span class="istickedoff">secure = if isSec then &quot;; Secure&quot; else &quot;&quot;</span>
<span class="lineno"> 1042 </span><span class="spaces">    </span><span class="istickedoff">hOnly = if isHOnly then &quot;; HttpOnly&quot; else &quot;&quot;</span>
<span class="lineno"> 1043 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1044 </span><span class="spaces">    </span><span class="istickedoff">-- TODO: 'formatHttpTime' uses &quot;DD MMM YYYY&quot; instead of &quot;DD-MMM-YYYY&quot;,</span>
<span class="lineno"> 1045 </span><span class="spaces">    </span><span class="istickedoff">-- unlike the code in 'Snap.Internal.Http.Server.Session'. Is this form</span>
<span class="lineno"> 1046 </span><span class="spaces">    </span><span class="istickedoff">-- allowed?</span>
<span class="lineno"> 1047 </span><span class="spaces">    </span><span class="istickedoff">fmt = unsafePerformIO . formatHttpTime . toCTime</span>
<span class="lineno"> 1048 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1049 </span><span class="spaces">    </span><span class="istickedoff">toCTime :: UTCTime -&gt; CTime</span>
<span class="lineno"> 1050 </span><span class="spaces">    </span><span class="istickedoff">toCTime = fromInteger . truncate . utcTimeToPOSIXSeconds</span></span>
<span class="lineno"> 1051 </span>
<span class="lineno"> 1052 </span>------------------------------------------------------------------------------
<span class="lineno"> 1053 </span>-- | Render cookies from a given 'Response' to 'Headers'.
<span class="lineno"> 1054 </span>--
<span class="lineno"> 1055 </span>-- TODO: Remove duplication. This function is copied from
<span class="lineno"> 1056 </span>-- snap-server/Snap.Internal.Http.Server.Session.
<span class="lineno"> 1057 </span>renderCookies :: Response -&gt; Headers -&gt; Headers
<span class="lineno"> 1058 </span><span class="decl"><span class="istickedoff">renderCookies r hdrs</span>
<span class="lineno"> 1059 </span><span class="spaces">    </span><span class="istickedoff">| null cookies = hdrs</span>
<span class="lineno"> 1060 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = foldl' (\m v -&gt; H.unsafeInsert &quot;set-cookie&quot; v m) hdrs cookies</span>
<span class="lineno"> 1061 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1062 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1063 </span><span class="spaces">    </span><span class="istickedoff">cookies = fmap cookieToBS . Map.elems $ rspCookies r</span></span>
<span class="lineno"> 1064 </span>
<span class="lineno"> 1065 </span>------------------------------------------------------------------------------
<span class="lineno"> 1066 </span>-- | Adds an HTTP 'Cookie' to 'Response' headers.
<span class="lineno"> 1067 </span>--
<span class="lineno"> 1068 </span>-- Example:
<span class="lineno"> 1069 </span>--
<span class="lineno"> 1070 </span>-- @
<span class="lineno"> 1071 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1072 </span>-- ghci&gt; let cookie = 'Cookie' \&quot;name\&quot; \&quot;value\&quot; Nothing Nothing Nothing False False
<span class="lineno"> 1073 </span>-- ghci&gt; 'getResponseCookie' \&quot;name\&quot; $ 'addResponseCookie' cookie 'emptyResponse'
<span class="lineno"> 1074 </span>-- Just (Cookie {cookieName = \&quot;name\&quot;, cookieValue = \&quot;value\&quot;, ...})
<span class="lineno"> 1075 </span>-- @
<span class="lineno"> 1076 </span>addResponseCookie :: Cookie            -- ^ cookie value
<span class="lineno"> 1077 </span>                  -&gt; Response          -- ^ response to modify
<span class="lineno"> 1078 </span>                  -&gt; Response
<span class="lineno"> 1079 </span><span class="decl"><span class="istickedoff">addResponseCookie ck@(Cookie k _ _ _ _ _ _) r = r { rspCookies = cks' }</span>
<span class="lineno"> 1080 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1081 </span><span class="spaces">    </span><span class="istickedoff">cks'= Map.insert k ck $ rspCookies r</span></span>
<span class="lineno"> 1082 </span>{-# INLINE addResponseCookie #-}
<span class="lineno"> 1083 </span>
<span class="lineno"> 1084 </span>
<span class="lineno"> 1085 </span>------------------------------------------------------------------------------
<span class="lineno"> 1086 </span>-- | Gets an HTTP 'Cookie' with the given name from 'Response' headers.
<span class="lineno"> 1087 </span>--
<span class="lineno"> 1088 </span>-- Example:
<span class="lineno"> 1089 </span>--
<span class="lineno"> 1090 </span>-- @
<span class="lineno"> 1091 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1092 </span>-- ghci&gt; 'getResponseCookie' \&quot;cookie-name\&quot; 'emptyResponse'
<span class="lineno"> 1093 </span>-- Nothing
<span class="lineno"> 1094 </span>-- @
<span class="lineno"> 1095 </span>getResponseCookie :: ByteString            -- ^ cookie name
<span class="lineno"> 1096 </span>                  -&gt; Response              -- ^ response to query
<span class="lineno"> 1097 </span>                  -&gt; Maybe Cookie
<span class="lineno"> 1098 </span><span class="decl"><span class="istickedoff">getResponseCookie cn r = Map.lookup cn $ rspCookies r</span></span>
<span class="lineno"> 1099 </span>{-# INLINE getResponseCookie #-}
<span class="lineno"> 1100 </span>
<span class="lineno"> 1101 </span>
<span class="lineno"> 1102 </span>-- | Returns a list of 'Cookie's present in 'Response'
<span class="lineno"> 1103 </span>--
<span class="lineno"> 1104 </span>-- Example:
<span class="lineno"> 1105 </span>--
<span class="lineno"> 1106 </span>-- @
<span class="lineno"> 1107 </span>-- ghci&gt; 'getResponseCookies' 'emptyResponse'
<span class="lineno"> 1108 </span>-- []
<span class="lineno"> 1109 </span>-- @
<span class="lineno"> 1110 </span>getResponseCookies :: Response              -- ^ response to query
<span class="lineno"> 1111 </span>                   -&gt; [Cookie]
<span class="lineno"> 1112 </span><span class="decl"><span class="istickedoff">getResponseCookies = Map.elems . rspCookies</span></span>
<span class="lineno"> 1113 </span>{-# INLINE getResponseCookies #-}
<span class="lineno"> 1114 </span>
<span class="lineno"> 1115 </span>
<span class="lineno"> 1116 </span>------------------------------------------------------------------------------
<span class="lineno"> 1117 </span>-- | Deletes an HTTP 'Cookie' from the 'Response' headers. Please note
<span class="lineno"> 1118 </span>-- this does not necessarily erase the cookie from the client browser.
<span class="lineno"> 1119 </span>--
<span class="lineno"> 1120 </span>-- Example:
<span class="lineno"> 1121 </span>--
<span class="lineno"> 1122 </span>-- @
<span class="lineno"> 1123 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1124 </span>-- ghci&gt; let cookie = 'Cookie' \&quot;name\&quot; \&quot;value\&quot; Nothing Nothing Nothing False False
<span class="lineno"> 1125 </span>-- ghci&gt; let rsp    = 'addResponseCookie' cookie 'emptyResponse'
<span class="lineno"> 1126 </span>-- ghci&gt; 'getResponseCookie' \&quot;name\&quot; rsp
<span class="lineno"> 1127 </span>-- Just (Cookie {cookieName = \&quot;name\&quot;, cookieValue = \&quot;value\&quot;, ...})
<span class="lineno"> 1128 </span>-- ghci&gt; 'getResponseCookie' \&quot;name\&quot; $ 'deleteResponseCookie' \&quot;name\&quot; rsp
<span class="lineno"> 1129 </span>-- Nothing
<span class="lineno"> 1130 </span>-- @
<span class="lineno"> 1131 </span>deleteResponseCookie :: ByteString        -- ^ cookie name
<span class="lineno"> 1132 </span>                     -&gt; Response          -- ^ response to modify
<span class="lineno"> 1133 </span>                     -&gt; Response
<span class="lineno"> 1134 </span><span class="decl"><span class="istickedoff">deleteResponseCookie cn r = r { rspCookies = cks' }</span>
<span class="lineno"> 1135 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1136 </span><span class="spaces">    </span><span class="istickedoff">cks'= Map.delete cn $ rspCookies r</span></span>
<span class="lineno"> 1137 </span>{-# INLINE deleteResponseCookie #-}
<span class="lineno"> 1138 </span>
<span class="lineno"> 1139 </span>
<span class="lineno"> 1140 </span>------------------------------------------------------------------------------
<span class="lineno"> 1141 </span>-- | Modifies an HTTP 'Cookie' with given name in 'Response' headers.
<span class="lineno"> 1142 </span>-- Nothing will happen if a matching 'Cookie' can not be found in 'Response'.
<span class="lineno"> 1143 </span>--
<span class="lineno"> 1144 </span>-- Example:
<span class="lineno"> 1145 </span>--
<span class="lineno"> 1146 </span>-- @
<span class="lineno"> 1147 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1148 </span>-- ghci&gt; import &quot;Data.Monoid&quot;
<span class="lineno"> 1149 </span>-- ghci&gt; let cookie = 'Cookie' \&quot;name\&quot; \&quot;value\&quot; Nothing Nothing Nothing False False
<span class="lineno"> 1150 </span>-- ghci&gt; let rsp    = 'addResponseCookie' cookie 'emptyResponse'
<span class="lineno"> 1151 </span>-- ghci&gt; 'getResponseCookie' \&quot;name\&quot; rsp
<span class="lineno"> 1152 </span>-- Just (Cookie {cookieName = \&quot;name\&quot;, cookieValue = \&quot;value\&quot;, ...})
<span class="lineno"> 1153 </span>-- ghci&gt; let f ck@('Cookie' { cookieName = name }) = ck { cookieName = name &lt;&gt; \&quot;\'\&quot;}
<span class="lineno"> 1154 </span>-- ghci&gt; let rsp' = 'modifyResponseCookie' \&quot;name\&quot; f rsp
<span class="lineno"> 1155 </span>-- ghci&gt; 'getResponseCookie' \&quot;name\'\&quot; rsp\'
<span class="lineno"> 1156 </span>-- Just (Cookie {cookieName = \&quot;name\'\&quot;, ...})
<span class="lineno"> 1157 </span>-- ghci&gt; 'getResponseCookie' \&quot;name\&quot; rsp\'
<span class="lineno"> 1158 </span>-- Just (Cookie {cookieName = \&quot;name\&quot;, ...})
<span class="lineno"> 1159 </span>-- @
<span class="lineno"> 1160 </span>modifyResponseCookie :: ByteString          -- ^ cookie name
<span class="lineno"> 1161 </span>                     -&gt; (Cookie -&gt; Cookie)  -- ^ modifier function
<span class="lineno"> 1162 </span>                     -&gt; Response            -- ^ response to modify
<span class="lineno"> 1163 </span>                     -&gt; Response
<span class="lineno"> 1164 </span><span class="decl"><span class="istickedoff">modifyResponseCookie cn f r = maybe r modify $ getResponseCookie cn r</span>
<span class="lineno"> 1165 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1166 </span><span class="spaces">    </span><span class="istickedoff">modify ck = addResponseCookie (f ck) r</span></span>
<span class="lineno"> 1167 </span>{-# INLINE modifyResponseCookie #-}
<span class="lineno"> 1168 </span>
<span class="lineno"> 1169 </span>
<span class="lineno"> 1170 </span>------------------------------------------------------------------------------
<span class="lineno"> 1171 </span>-- | A note here: if you want to set the @Content-Length@ for the response,
<span class="lineno"> 1172 </span>-- Snap forces you to do it with this function rather than by setting it in
<span class="lineno"> 1173 </span>-- the headers; the @Content-Length@ in the headers will be ignored.
<span class="lineno"> 1174 </span>--
<span class="lineno"> 1175 </span>-- The reason for this is that Snap needs to look up the value of
<span class="lineno"> 1176 </span>-- @Content-Length@ for each request, and looking the string value up in the
<span class="lineno"> 1177 </span>-- headers and parsing the number out of the text will be too expensive.
<span class="lineno"> 1178 </span>--
<span class="lineno"> 1179 </span>-- If you don't set a content length in your response, HTTP keep-alive will be
<span class="lineno"> 1180 </span>-- disabled for HTTP\/1.0 clients, forcing a @Connection: close@. For
<span class="lineno"> 1181 </span>-- HTTP\/1.1 clients, Snap will switch to the chunked transfer encoding if
<span class="lineno"> 1182 </span>-- @Content-Length@ is not specified.
<span class="lineno"> 1183 </span>--
<span class="lineno"> 1184 </span>-- Example:
<span class="lineno"> 1185 </span>--
<span class="lineno"> 1186 </span>-- @
<span class="lineno"> 1187 </span>-- ghci&gt; setContentLength 400 'emptyResponse'
<span class="lineno"> 1188 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1189 </span>-- Content-Length: 400
<span class="lineno"> 1190 </span>--
<span class="lineno"> 1191 </span>--
<span class="lineno"> 1192 </span>-- @
<span class="lineno"> 1193 </span>setContentLength    :: Word64 -&gt; Response -&gt; Response
<span class="lineno"> 1194 </span><span class="decl"><span class="istickedoff">setContentLength !l r = r { rspContentLength = Just l }</span></span>
<span class="lineno"> 1195 </span>{-# INLINE setContentLength #-}
<span class="lineno"> 1196 </span>
<span class="lineno"> 1197 </span>
<span class="lineno"> 1198 </span>------------------------------------------------------------------------------
<span class="lineno"> 1199 </span>-- | Removes any @Content-Length@ set in the 'Response'.
<span class="lineno"> 1200 </span>--
<span class="lineno"> 1201 </span>-- Example:
<span class="lineno"> 1202 </span>--
<span class="lineno"> 1203 </span>-- @
<span class="lineno"> 1204 </span>-- ghci&gt; clearContentLength $ 'setContentLength' 400 'emptyResponse'
<span class="lineno"> 1205 </span>-- HTTP\/1.1 200 OK
<span class="lineno"> 1206 </span>--
<span class="lineno"> 1207 </span>--
<span class="lineno"> 1208 </span>-- @
<span class="lineno"> 1209 </span>clearContentLength :: Response -&gt; Response
<span class="lineno"> 1210 </span><span class="decl"><span class="istickedoff">clearContentLength r = r { rspContentLength = Nothing }</span></span>
<span class="lineno"> 1211 </span>{-# INLINE clearContentLength #-}
<span class="lineno"> 1212 </span>
<span class="lineno"> 1213 </span>
<span class="lineno"> 1214 </span>                               ----------------
<span class="lineno"> 1215 </span>                               -- HTTP dates --
<span class="lineno"> 1216 </span>                               ----------------
<span class="lineno"> 1217 </span>
<span class="lineno"> 1218 </span>------------------------------------------------------------------------------
<span class="lineno"> 1219 </span>-- | Convert a 'CTime' into an HTTP timestamp.
<span class="lineno"> 1220 </span>--
<span class="lineno"> 1221 </span>-- Example:
<span class="lineno"> 1222 </span>--
<span class="lineno"> 1223 </span>-- @
<span class="lineno"> 1224 </span>-- ghci&gt; 'formatHttpTime' . 'fromIntegral' $ 10
<span class="lineno"> 1225 </span>-- \&quot;Thu, 01 Jan 1970 00:00:10 GMT\&quot;
<span class="lineno"> 1226 </span>-- @
<span class="lineno"> 1227 </span>formatHttpTime :: CTime -&gt; IO ByteString
<span class="lineno"> 1228 </span>
<span class="lineno"> 1229 </span>
<span class="lineno"> 1230 </span>------------------------------------------------------------------------------
<span class="lineno"> 1231 </span>-- | Convert a 'CTime' into common log entry format.
<span class="lineno"> 1232 </span>formatLogTime :: CTime -&gt; IO ByteString
<span class="lineno"> 1233 </span>
<span class="lineno"> 1234 </span>
<span class="lineno"> 1235 </span>------------------------------------------------------------------------------
<span class="lineno"> 1236 </span>-- | Converts an HTTP timestamp into a 'CTime'.
<span class="lineno"> 1237 </span>--
<span class="lineno"> 1238 </span>-- Example:
<span class="lineno"> 1239 </span>--
<span class="lineno"> 1240 </span>-- @
<span class="lineno"> 1241 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno"> 1242 </span>-- ghci&gt; 'parseHttpTime' \&quot;Thu, 01 Jan 1970 00:00:10 GMT\&quot;
<span class="lineno"> 1243 </span>-- 10
<span class="lineno"> 1244 </span>-- @
<span class="lineno"> 1245 </span>parseHttpTime :: ByteString -&gt; IO CTime
<span class="lineno"> 1246 </span>
<span class="lineno"> 1247 </span>#ifdef PORTABLE
<span class="lineno"> 1248 </span>
<span class="lineno"> 1249 </span>------------------------------------------------------------------------------
<span class="lineno"> 1250 </span>-- local definitions
<span class="lineno"> 1251 </span>fromStr :: String -&gt; ByteString
<span class="lineno"> 1252 </span>fromStr = S.pack                -- only because we know there's no unicode
<span class="lineno"> 1253 </span>{-# INLINE fromStr #-}
<span class="lineno"> 1254 </span>
<span class="lineno"> 1255 </span>
<span class="lineno"> 1256 </span>------------------------------------------------------------------------------
<span class="lineno"> 1257 </span>formatHttpTime = return . format . toUTCTime
<span class="lineno"> 1258 </span>  where
<span class="lineno"> 1259 </span>    format :: UTCTime -&gt; ByteString
<span class="lineno"> 1260 </span>    format = fromStr . formatTime defaultTimeLocale &quot;%a, %d %b %Y %X GMT&quot;
<span class="lineno"> 1261 </span>
<span class="lineno"> 1262 </span>    toUTCTime :: CTime -&gt; UTCTime
<span class="lineno"> 1263 </span>    toUTCTime = posixSecondsToUTCTime . realToFrac
<span class="lineno"> 1264 </span>
<span class="lineno"> 1265 </span>
<span class="lineno"> 1266 </span>------------------------------------------------------------------------------
<span class="lineno"> 1267 </span>formatLogTime ctime = do
<span class="lineno"> 1268 </span>  t &lt;- utcToLocalZonedTime $ toUTCTime ctime
<span class="lineno"> 1269 </span>  return $! format t
<span class="lineno"> 1270 </span>
<span class="lineno"> 1271 </span>  where
<span class="lineno"> 1272 </span>    format :: ZonedTime -&gt; ByteString
<span class="lineno"> 1273 </span>    format = fromStr . formatTime defaultTimeLocale &quot;%d/%b/%Y:%H:%M:%S %z&quot;
<span class="lineno"> 1274 </span>
<span class="lineno"> 1275 </span>    toUTCTime :: CTime -&gt; UTCTime
<span class="lineno"> 1276 </span>    toUTCTime = posixSecondsToUTCTime . realToFrac
<span class="lineno"> 1277 </span>
<span class="lineno"> 1278 </span>
<span class="lineno"> 1279 </span>------------------------------------------------------------------------------
<span class="lineno"> 1280 </span>parseHttpTime = return . toCTime . prs . S.unpack
<span class="lineno"> 1281 </span>  where
<span class="lineno"> 1282 </span>    prs :: String -&gt; Maybe UTCTime
<span class="lineno"> 1283 </span>    prs = parseTime defaultTimeLocale &quot;%a, %d %b %Y %H:%M:%S GMT&quot;
<span class="lineno"> 1284 </span>
<span class="lineno"> 1285 </span>    toCTime :: Maybe UTCTime -&gt; CTime
<span class="lineno"> 1286 </span>    toCTime (Just t) = fromInteger $ truncate $ utcTimeToPOSIXSeconds t
<span class="lineno"> 1287 </span>    toCTime Nothing  = fromInteger 0
<span class="lineno"> 1288 </span>
<span class="lineno"> 1289 </span>#else
<span class="lineno"> 1290 </span>
<span class="lineno"> 1291 </span>------------------------------------------------------------------------------
<span class="lineno"> 1292 </span><span class="decl"><span class="istickedoff">formatLogTime t = do</span>
<span class="lineno"> 1293 </span><span class="spaces">    </span><span class="istickedoff">ptr &lt;- mallocBytes 40</span>
<span class="lineno"> 1294 </span><span class="spaces">    </span><span class="istickedoff">c_format_log_time t ptr</span>
<span class="lineno"> 1295 </span><span class="spaces">    </span><span class="istickedoff">S.unsafePackMallocCString ptr</span></span>
<span class="lineno"> 1296 </span>
<span class="lineno"> 1297 </span>
<span class="lineno"> 1298 </span>------------------------------------------------------------------------------
<span class="lineno"> 1299 </span><span class="decl"><span class="istickedoff">formatHttpTime t = do</span>
<span class="lineno"> 1300 </span><span class="spaces">    </span><span class="istickedoff">ptr &lt;- mallocBytes 40</span>
<span class="lineno"> 1301 </span><span class="spaces">    </span><span class="istickedoff">c_format_http_time t ptr</span>
<span class="lineno"> 1302 </span><span class="spaces">    </span><span class="istickedoff">S.unsafePackMallocCString ptr</span></span>
<span class="lineno"> 1303 </span>
<span class="lineno"> 1304 </span>
<span class="lineno"> 1305 </span>------------------------------------------------------------------------------
<span class="lineno"> 1306 </span><span class="decl"><span class="istickedoff">parseHttpTime s = S.unsafeUseAsCString s $ \ptr -&gt;</span>
<span class="lineno"> 1307 </span><span class="spaces">    </span><span class="istickedoff">c_parse_http_time ptr</span></span>
<span class="lineno"> 1308 </span>
<span class="lineno"> 1309 </span>#endif
<span class="lineno"> 1310 </span>
<span class="lineno"> 1311 </span>
<span class="lineno"> 1312 </span>------------------------------------------------------------------------------
<span class="lineno"> 1313 </span>statusReasonMap :: IM.IntMap ByteString
<span class="lineno"> 1314 </span><span class="decl"><span class="istickedoff">statusReasonMap = IM.fromList [</span>
<span class="lineno"> 1315 </span><span class="spaces">        </span><span class="istickedoff">(100, &quot;Continue&quot;),</span>
<span class="lineno"> 1316 </span><span class="spaces">        </span><span class="istickedoff">(101, &quot;Switching Protocols&quot;),</span>
<span class="lineno"> 1317 </span><span class="spaces">        </span><span class="istickedoff">(200, &quot;OK&quot;),</span>
<span class="lineno"> 1318 </span><span class="spaces">        </span><span class="istickedoff">(201, &quot;Created&quot;),</span>
<span class="lineno"> 1319 </span><span class="spaces">        </span><span class="istickedoff">(202, &quot;Accepted&quot;),</span>
<span class="lineno"> 1320 </span><span class="spaces">        </span><span class="istickedoff">(203, &quot;Non-Authoritative Information&quot;),</span>
<span class="lineno"> 1321 </span><span class="spaces">        </span><span class="istickedoff">(204, &quot;No Content&quot;),</span>
<span class="lineno"> 1322 </span><span class="spaces">        </span><span class="istickedoff">(205, &quot;Reset Content&quot;),</span>
<span class="lineno"> 1323 </span><span class="spaces">        </span><span class="istickedoff">(206, &quot;Partial Content&quot;),</span>
<span class="lineno"> 1324 </span><span class="spaces">        </span><span class="istickedoff">(300, &quot;Multiple Choices&quot;),</span>
<span class="lineno"> 1325 </span><span class="spaces">        </span><span class="istickedoff">(301, &quot;Moved Permanently&quot;),</span>
<span class="lineno"> 1326 </span><span class="spaces">        </span><span class="istickedoff">(302, &quot;Found&quot;),</span>
<span class="lineno"> 1327 </span><span class="spaces">        </span><span class="istickedoff">(303, &quot;See Other&quot;),</span>
<span class="lineno"> 1328 </span><span class="spaces">        </span><span class="istickedoff">(304, &quot;Not Modified&quot;),</span>
<span class="lineno"> 1329 </span><span class="spaces">        </span><span class="istickedoff">(305, &quot;Use Proxy&quot;),</span>
<span class="lineno"> 1330 </span><span class="spaces">        </span><span class="istickedoff">(307, &quot;Temporary Redirect&quot;),</span>
<span class="lineno"> 1331 </span><span class="spaces">        </span><span class="istickedoff">(400, &quot;Bad Request&quot;),</span>
<span class="lineno"> 1332 </span><span class="spaces">        </span><span class="istickedoff">(401, &quot;Unauthorized&quot;),</span>
<span class="lineno"> 1333 </span><span class="spaces">        </span><span class="istickedoff">(402, &quot;Payment Required&quot;),</span>
<span class="lineno"> 1334 </span><span class="spaces">        </span><span class="istickedoff">(403, &quot;Forbidden&quot;),</span>
<span class="lineno"> 1335 </span><span class="spaces">        </span><span class="istickedoff">(404, &quot;Not Found&quot;),</span>
<span class="lineno"> 1336 </span><span class="spaces">        </span><span class="istickedoff">(405, &quot;Method Not Allowed&quot;),</span>
<span class="lineno"> 1337 </span><span class="spaces">        </span><span class="istickedoff">(406, &quot;Not Acceptable&quot;),</span>
<span class="lineno"> 1338 </span><span class="spaces">        </span><span class="istickedoff">(407, &quot;Proxy Authentication Required&quot;),</span>
<span class="lineno"> 1339 </span><span class="spaces">        </span><span class="istickedoff">(408, &quot;Request Time-out&quot;),</span>
<span class="lineno"> 1340 </span><span class="spaces">        </span><span class="istickedoff">(409, &quot;Conflict&quot;),</span>
<span class="lineno"> 1341 </span><span class="spaces">        </span><span class="istickedoff">(410, &quot;Gone&quot;),</span>
<span class="lineno"> 1342 </span><span class="spaces">        </span><span class="istickedoff">(411, &quot;Length Required&quot;),</span>
<span class="lineno"> 1343 </span><span class="spaces">        </span><span class="istickedoff">(412, &quot;Precondition Failed&quot;),</span>
<span class="lineno"> 1344 </span><span class="spaces">        </span><span class="istickedoff">(413, &quot;Request Entity Too Large&quot;),</span>
<span class="lineno"> 1345 </span><span class="spaces">        </span><span class="istickedoff">(414, &quot;Request-URI Too Large&quot;),</span>
<span class="lineno"> 1346 </span><span class="spaces">        </span><span class="istickedoff">(415, &quot;Unsupported Media Type&quot;),</span>
<span class="lineno"> 1347 </span><span class="spaces">        </span><span class="istickedoff">(416, &quot;Requested range not satisfiable&quot;),</span>
<span class="lineno"> 1348 </span><span class="spaces">        </span><span class="istickedoff">(417, &quot;Expectation Failed&quot;),</span>
<span class="lineno"> 1349 </span><span class="spaces">        </span><span class="istickedoff">(500, &quot;Internal Server Error&quot;),</span>
<span class="lineno"> 1350 </span><span class="spaces">        </span><span class="istickedoff">(501, &quot;Not Implemented&quot;),</span>
<span class="lineno"> 1351 </span><span class="spaces">        </span><span class="istickedoff">(502, &quot;Bad Gateway&quot;),</span>
<span class="lineno"> 1352 </span><span class="spaces">        </span><span class="istickedoff">(503, &quot;Service Unavailable&quot;),</span>
<span class="lineno"> 1353 </span><span class="spaces">        </span><span class="istickedoff">(504, &quot;Gateway Time-out&quot;),</span>
<span class="lineno"> 1354 </span><span class="spaces">        </span><span class="istickedoff">(505, &quot;HTTP Version not supported&quot;)</span>
<span class="lineno"> 1355 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1356 </span>
<span class="lineno"> 1357 </span>
<span class="lineno"> 1358 </span>------------------------------------------------------------------------------
<span class="lineno"> 1359 </span>-- Deprecated functions
<span class="lineno"> 1360 </span>
<span class="lineno"> 1361 </span>-- | See 'rqClientAddr'.
<span class="lineno"> 1362 </span>rqRemoteAddr :: Request -&gt; ByteString
<span class="lineno"> 1363 </span><span class="decl"><span class="istickedoff">rqRemoteAddr = rqClientAddr</span></span>
<span class="lineno"> 1364 </span>{-# DEPRECATED rqRemoteAddr &quot;(snap-core &gt;= 1.0.0.0) please use 'rqClientAddr', this will be removed in 1.1.*&quot; #-}
<span class="lineno"> 1365 </span>
<span class="lineno"> 1366 </span>-- | See 'rqClientPort'.
<span class="lineno"> 1367 </span>rqRemotePort :: Request -&gt; Int
<span class="lineno"> 1368 </span><span class="decl"><span class="istickedoff">rqRemotePort = rqClientPort</span></span>
<span class="lineno"> 1369 </span>{-# DEPRECATED rqRemotePort &quot;(snap-core &gt;= 1.0.0.0) please use 'rqClientPort', this will be removed in 1.1.*&quot; #-}

</pre>
</html>
