<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{- Temporary workaround for https://ghc.haskell.org/trac/ghc/ticket/9127 -}
<span class="lineno">    2 </span>{-# OPTIONS_GHC -fno-warn-unused-binds  #-}
<span class="lineno">    3 </span>
<span class="lineno">    4 </span>{-# LANGUAGE BangPatterns               #-}
<span class="lineno">    5 </span>{-# LANGUAGE CPP                        #-}
<span class="lineno">    6 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    7 </span>{-# LANGUAGE OverloadedStrings          #-}
<span class="lineno">    8 </span>{-# LANGUAGE Rank2Types                 #-}
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>module Snap.Internal.Test.RequestBuilder
<span class="lineno">   11 </span>  ( RequestBuilder
<span class="lineno">   12 </span>  , MultipartParams
<span class="lineno">   13 </span>  , MultipartParam(..)
<span class="lineno">   14 </span>  , FileData      (..)
<span class="lineno">   15 </span>  , RequestType   (..)
<span class="lineno">   16 </span>  , addHeader
<span class="lineno">   17 </span>  , buildRequest
<span class="lineno">   18 </span>  , delete
<span class="lineno">   19 </span>  , evalHandler
<span class="lineno">   20 </span>  , evalHandlerM
<span class="lineno">   21 </span>  , get
<span class="lineno">   22 </span>  , postMultipart
<span class="lineno">   23 </span>  , postRaw
<span class="lineno">   24 </span>  , postUrlEncoded
<span class="lineno">   25 </span>  , put
<span class="lineno">   26 </span>  , requestToString
<span class="lineno">   27 </span>  , responseToString
<span class="lineno">   28 </span>  , runHandler
<span class="lineno">   29 </span>  , runHandlerM
<span class="lineno">   30 </span>  , setContentType
<span class="lineno">   31 </span>  , setHeader
<span class="lineno">   32 </span>  , addCookies
<span class="lineno">   33 </span>  , setHttpVersion
<span class="lineno">   34 </span>  , setQueryString
<span class="lineno">   35 </span>  , setQueryStringRaw
<span class="lineno">   36 </span>  , setRequestPath
<span class="lineno">   37 </span>  , setRequestType
<span class="lineno">   38 </span>  , setSecure
<span class="lineno">   39 </span>  ) where
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>------------------------------------------------------------------------------
<span class="lineno">   42 </span>import           Control.Monad              (liftM, replicateM, void)
<span class="lineno">   43 </span>import           Control.Monad.State.Strict (MonadIO (..), MonadState, MonadTrans, StateT, execStateT, modify)
<span class="lineno">   44 </span>import qualified Control.Monad.State.Strict as State
<span class="lineno">   45 </span>import           Data.Bits                  (Bits ((.&amp;.), unsafeShiftR))
<span class="lineno">   46 </span>import qualified Data.ByteString            as S8
<span class="lineno">   47 </span>import           Data.ByteString.Builder    (Builder, byteString, char8, stringUtf8, toLazyByteString, word8)
<span class="lineno">   48 </span>import           Data.ByteString.Char8      (ByteString)
<span class="lineno">   49 </span>import qualified Data.ByteString.Char8      as S
<span class="lineno">   50 </span>import qualified Data.ByteString.Lazy.Char8 as L
<span class="lineno">   51 </span>import           Data.CaseInsensitive       (CI, original)
<span class="lineno">   52 </span>import qualified Data.Map                   as Map
<span class="lineno">   53 </span>import qualified Data.Vector                as V
<span class="lineno">   54 </span>import           Data.Word                  (Word8)
<span class="lineno">   55 </span>import           Snap.Core                  (Cookie (Cookie), Method (DELETE, GET, HEAD, POST, PUT), MonadSnap, Params, Request (rqContentLength, rqContextPath, rqCookies, rqHeaders, rqHostName, rqIsSecure, rqMethod, rqParams, rqPathInfo, rqPostParams, rqQueryParams, rqQueryString, rqURI, rqVersion), Response, Snap, deleteHeader, formatHttpTime, getHeader, parseUrlEncoded, printUrlEncoded, runSnap)
<span class="lineno">   56 </span>import           Snap.Internal.Core         (evalSnap, fixupResponse)
<span class="lineno">   57 </span>import           Snap.Internal.Http.Types   (Request (Request, rqBody), Response (rspBody, rspContentLength), rspBodyToEnum)
<span class="lineno">   58 </span>import qualified Snap.Internal.Http.Types   as H
<span class="lineno">   59 </span>import qualified Snap.Types.Headers         as H
<span class="lineno">   60 </span>import qualified System.IO.Streams          as Streams
<span class="lineno">   61 </span>import           System.PosixCompat.Time    (epochTime)
<span class="lineno">   62 </span>import           System.Random              (Random (randomIO))
<span class="lineno">   63 </span>import           Text.Printf                (printf)
<span class="lineno">   64 </span>#if !MIN_VERSION_base(4,8,0)
<span class="lineno">   65 </span>import           Control.Applicative        (Applicative)
<span class="lineno">   66 </span>import           Data.Monoid                (Monoid (mappend, mconcat, mempty))
<span class="lineno">   67 </span>#endif
<span class="lineno">   68 </span>------------------------------------------------------------------------------
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>------------------------------------------------------------------------------
<span class="lineno">   72 </span>-- | RequestBuilder is a monad transformer that allows you to conveniently
<span class="lineno">   73 </span>-- build a snap 'Request' for testing.
<span class="lineno">   74 </span>newtype RequestBuilder m a = RequestBuilder (StateT Request m a)
<span class="lineno">   75 </span>  deriving ( Applicative
<span class="lineno">   76 </span>           , Functor
<span class="lineno">   77 </span>           , Monad
<span class="lineno">   78 </span>           , MonadIO
<span class="lineno">   79 </span>           , MonadState Request
<span class="lineno">   80 </span>           , MonadTrans
<span class="lineno">   81 </span>           )
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>------------------------------------------------------------------------------
<span class="lineno">   85 </span>mkDefaultRequest :: IO Request
<span class="lineno">   86 </span><span class="decl"><span class="istickedoff">mkDefaultRequest = do</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">b &lt;- Streams.fromList $! []</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">return $ Request &quot;localhost&quot;</span>
<span class="lineno">   89 </span><span class="spaces">                     </span><span class="istickedoff">&quot;127.0.0.1&quot;</span>
<span class="lineno">   90 </span><span class="spaces">                     </span><span class="istickedoff">60000</span>
<span class="lineno">   91 </span><span class="spaces">                     </span><span class="istickedoff">&quot;127.0.0.1&quot;</span>
<span class="lineno">   92 </span><span class="spaces">                     </span><span class="istickedoff">8080</span>
<span class="lineno">   93 </span><span class="spaces">                     </span><span class="istickedoff">&quot;localhost&quot;</span>
<span class="lineno">   94 </span><span class="spaces">                     </span><span class="istickedoff">False</span>
<span class="lineno">   95 </span><span class="spaces">                     </span><span class="istickedoff">H.empty</span>
<span class="lineno">   96 </span><span class="spaces">                     </span><span class="istickedoff">b</span>
<span class="lineno">   97 </span><span class="spaces">                     </span><span class="istickedoff">Nothing</span>
<span class="lineno">   98 </span><span class="spaces">                     </span><span class="istickedoff">GET</span>
<span class="lineno">   99 </span><span class="spaces">                     </span><span class="istickedoff">(1,1)</span>
<span class="lineno">  100 </span><span class="spaces">                     </span><span class="istickedoff">[]</span>
<span class="lineno">  101 </span><span class="spaces">                     </span><span class="istickedoff">&quot;&quot;</span>
<span class="lineno">  102 </span><span class="spaces">                     </span><span class="istickedoff">&quot;/&quot;</span>
<span class="lineno">  103 </span><span class="spaces">                     </span><span class="istickedoff">&quot;/&quot;</span>
<span class="lineno">  104 </span><span class="spaces">                     </span><span class="istickedoff">&quot;&quot;</span>
<span class="lineno">  105 </span><span class="spaces">                     </span><span class="istickedoff">Map.empty</span>
<span class="lineno">  106 </span><span class="spaces">                     </span><span class="istickedoff">Map.empty</span>
<span class="lineno">  107 </span><span class="spaces">                     </span><span class="istickedoff">Map.empty</span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>------------------------------------------------------------------------------
<span class="lineno">  111 </span>-- | Runs a 'RequestBuilder', producing the desired 'Request'.
<span class="lineno">  112 </span>--
<span class="lineno">  113 </span>-- N.B. /please/ don't use the request you get here in a real Snap application;
<span class="lineno">  114 </span>-- things will probably break. Don't say you weren't warned :-)
<span class="lineno">  115 </span>--
<span class="lineno">  116 </span>--
<span class="lineno">  117 </span>-- Example:
<span class="lineno">  118 </span>--
<span class="lineno">  119 </span>-- @
<span class="lineno">  120 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  121 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  122 </span>-- ghci&gt; 'buildRequest' $ 'get' \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  123 </span>-- GET \/foo\/bar HTTP\/1.1
<span class="lineno">  124 </span>-- host: localhost
<span class="lineno">  125 </span>--
<span class="lineno">  126 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  127 </span>-- @
<span class="lineno">  128 </span>buildRequest :: MonadIO m =&gt; RequestBuilder m () -&gt; m Request
<span class="lineno">  129 </span><span class="decl"><span class="istickedoff">buildRequest mm = do</span>
<span class="lineno">  130 </span><span class="spaces">    </span><span class="istickedoff">let (RequestBuilder m) = (mm &gt;&gt; fixup)</span>
<span class="lineno">  131 </span><span class="spaces">    </span><span class="istickedoff">rq0 &lt;- liftIO mkDefaultRequest</span>
<span class="lineno">  132 </span><span class="spaces">    </span><span class="istickedoff">execStateT m rq0</span>
<span class="lineno">  133 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  134 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="istickedoff">fixup = do</span>
<span class="lineno">  136 </span><span class="spaces">        </span><span class="istickedoff">fixupURI</span>
<span class="lineno">  137 </span><span class="spaces">        </span><span class="istickedoff">fixupMethod</span>
<span class="lineno">  138 </span><span class="spaces">        </span><span class="istickedoff">fixupCL</span>
<span class="lineno">  139 </span><span class="spaces">        </span><span class="istickedoff">fixupParams</span>
<span class="lineno">  140 </span><span class="spaces">        </span><span class="istickedoff">fixupHost</span>
<span class="lineno">  141 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="istickedoff">fixupMethod = do</span>
<span class="lineno">  143 </span><span class="spaces">        </span><span class="istickedoff">rq &lt;- rGet</span>
<span class="lineno">  144 </span><span class="spaces">        </span><span class="istickedoff">if (rqMethod rq == GET || rqMethod rq == DELETE ||</span>
<span class="lineno">  145 </span><span class="spaces">            </span><span class="istickedoff">rqMethod rq == HEAD)</span>
<span class="lineno">  146 </span><span class="spaces">          </span><span class="istickedoff">then do</span>
<span class="lineno">  147 </span><span class="spaces">              </span><span class="istickedoff">-- drain the old request body and replace it with a new one</span>
<span class="lineno">  148 </span><span class="spaces">              </span><span class="istickedoff">!_ &lt;- liftIO $ Streams.toList $ rqBody rq</span>
<span class="lineno">  149 </span><span class="spaces">              </span><span class="istickedoff">!b &lt;- liftIO $ Streams.fromList $! []</span>
<span class="lineno">  150 </span><span class="spaces">              </span><span class="istickedoff">-- These requests are not permitted to have bodies</span>
<span class="lineno">  151 </span><span class="spaces">              </span><span class="istickedoff">let rq' = deleteHeader &quot;Content-Type&quot; $</span>
<span class="lineno">  152 </span><span class="spaces">                        </span><span class="istickedoff">rq { rqBody = b }</span>
<span class="lineno">  153 </span><span class="spaces">              </span><span class="istickedoff">rPut $ rq' { rqContentLength = Nothing }</span>
<span class="lineno">  154 </span><span class="spaces">          </span><span class="istickedoff">else return $! ()</span>
<span class="lineno">  155 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  156 </span><span class="spaces">    </span><span class="istickedoff">fixupCL = do</span>
<span class="lineno">  157 </span><span class="spaces">        </span><span class="istickedoff">rq &lt;- rGet</span>
<span class="lineno">  158 </span><span class="spaces">        </span><span class="istickedoff">maybe (rPut $ deleteHeader &quot;Content-Length&quot; rq)</span>
<span class="lineno">  159 </span><span class="spaces">              </span><span class="istickedoff">(\cl -&gt; rPut $ H.setHeader &quot;Content-Length&quot;</span>
<span class="lineno">  160 </span><span class="spaces">                                         </span><span class="istickedoff">(S.pack (show cl)) rq)</span>
<span class="lineno">  161 </span><span class="spaces">              </span><span class="istickedoff">(rqContentLength rq)</span>
<span class="lineno">  162 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="istickedoff">fixupParams = do</span>
<span class="lineno">  164 </span><span class="spaces">        </span><span class="istickedoff">rq &lt;- rGet</span>
<span class="lineno">  165 </span><span class="spaces">        </span><span class="istickedoff">let !query       = rqQueryString rq</span>
<span class="lineno">  166 </span><span class="spaces">        </span><span class="istickedoff">-- force the stuff from mkDefaultRequest that we just overwrite</span>
<span class="lineno">  167 </span><span class="spaces">        </span><span class="istickedoff">let !_           = rqPostParams rq</span>
<span class="lineno">  168 </span><span class="spaces">        </span><span class="istickedoff">let !_           = rqParams rq</span>
<span class="lineno">  169 </span><span class="spaces">        </span><span class="istickedoff">let !_           = rqQueryParams rq</span>
<span class="lineno">  170 </span><span class="spaces">        </span><span class="istickedoff">let !queryParams = parseUrlEncoded query</span>
<span class="lineno">  171 </span><span class="spaces">        </span><span class="istickedoff">let !mbCT        = getHeader &quot;Content-Type&quot; rq</span>
<span class="lineno">  172 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  173 </span><span class="spaces">        </span><span class="istickedoff">(!postParams, rq') &lt;-</span>
<span class="lineno">  174 </span><span class="spaces">            </span><span class="istickedoff">if mbCT == Just &quot;application/x-www-form-urlencoded&quot;</span>
<span class="lineno">  175 </span><span class="spaces">              </span><span class="istickedoff">then liftIO $ do</span>
<span class="lineno">  176 </span><span class="spaces">                  </span><span class="istickedoff">!l &lt;- Streams.toList $ rqBody rq</span>
<span class="lineno">  177 </span><span class="spaces">                  </span><span class="istickedoff">-- snap-server regurgitates the parsed form body</span>
<span class="lineno">  178 </span><span class="spaces">                  </span><span class="istickedoff">!b &lt;- Streams.fromList l</span>
<span class="lineno">  179 </span><span class="spaces">                  </span><span class="istickedoff">return (parseUrlEncoded (S.concat l), rq { rqBody = b })</span>
<span class="lineno">  180 </span><span class="spaces">              </span><span class="istickedoff">else return (Map.empty, rq)</span>
<span class="lineno">  181 </span><span class="spaces">        </span><span class="istickedoff">let !newParams = Map.unionWith (flip (++)) queryParams postParams</span>
<span class="lineno">  182 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  183 </span><span class="spaces">        </span><span class="istickedoff">rPut $ rq' { rqParams      = newParams</span>
<span class="lineno">  184 </span><span class="spaces">                   </span><span class="istickedoff">, rqPostParams  = postParams</span>
<span class="lineno">  185 </span><span class="spaces">                   </span><span class="istickedoff">, rqQueryParams = queryParams }</span>
<span class="lineno">  186 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">fixupHost = do</span>
<span class="lineno">  188 </span><span class="spaces">        </span><span class="istickedoff">rq &lt;- rGet</span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">case H.getHeader &quot;Host&quot; rq of</span>
<span class="lineno">  190 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno">  191 </span><span class="spaces">            </span><span class="istickedoff">let !hn = rqHostName rq</span>
<span class="lineno">  192 </span><span class="spaces">            </span><span class="istickedoff">rPut $ H.setHeader &quot;Host&quot; hn rq</span>
<span class="lineno">  193 </span><span class="spaces">          </span><span class="istickedoff">Just hn -&gt;</span>
<span class="lineno">  194 </span><span class="spaces">            </span><span class="istickedoff">rPut $ rq { rqHostName = hn }</span></span>
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>------------------------------------------------------------------------------
<span class="lineno">  198 </span>-- | A request body of type \&quot;@multipart/form-data@\&quot; consists of a set of
<span class="lineno">  199 </span>-- named form parameters, each of which can by either a list of regular form
<span class="lineno">  200 </span>-- values or a set of file uploads.
<span class="lineno">  201 </span>type MultipartParams = [(ByteString, MultipartParam)]
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>------------------------------------------------------------------------------
<span class="lineno">  205 </span>-- | A single \&quot;@multipart/form-data@\&quot; form parameter: either a list of regular
<span class="lineno">  206 </span>-- form values or a set of file uploads.
<span class="lineno">  207 </span>data MultipartParam =
<span class="lineno">  208 </span>    FormData [ByteString]
<span class="lineno">  209 </span>        -- ^ a form variable consisting of the given 'ByteString' values.
<span class="lineno">  210 </span>  | Files [FileData]
<span class="lineno">  211 </span>        -- ^ a file upload consisting of the given 'FileData' values.
<span class="lineno">  212 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span>)
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>------------------------------------------------------------------------------
<span class="lineno">  216 </span>-- | Represents a single file upload for the 'MultipartParam'.
<span class="lineno">  217 </span>data FileData = FileData {
<span class="lineno">  218 </span>      fdFileName    :: ByteString  -- ^ the file's name
<span class="lineno">  219 </span>    , fdContentType :: ByteString  -- ^ the file's content-type
<span class="lineno">  220 </span>    , fdContents    :: ByteString  -- ^ the file contents
<span class="lineno">  221 </span>    }
<span class="lineno">  222 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span>)
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>------------------------------------------------------------------------------
<span class="lineno">  226 </span>-- | The 'RequestType' datatype enumerates the different kinds of HTTP
<span class="lineno">  227 </span>-- requests you can generate using the testing interface. Most users will
<span class="lineno">  228 </span>-- prefer to use the 'get', 'postUrlEncoded', 'postMultipart', 'put', and
<span class="lineno">  229 </span>-- 'delete' convenience functions.
<span class="lineno">  230 </span>data RequestType
<span class="lineno">  231 </span>    = GetRequest
<span class="lineno">  232 </span>    | RequestWithRawBody Method ByteString
<span class="lineno">  233 </span>    | MultipartPostRequest MultipartParams
<span class="lineno">  234 </span>    | UrlEncodedPostRequest Params
<span class="lineno">  235 </span>    | DeleteRequest
<span class="lineno">  236 </span>    deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span>)
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>------------------------------------------------------------------------------
<span class="lineno">  240 </span>-- | Sets the type of the 'Request' being built.
<span class="lineno">  241 </span>--
<span class="lineno">  242 </span>-- Example:
<span class="lineno">  243 </span>--
<span class="lineno">  244 </span>-- @
<span class="lineno">  245 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  246 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  247 </span>-- ghci&gt; 'buildRequest' $ 'delete' \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; 'setRequestType' GetRequest
<span class="lineno">  248 </span>-- GET \/foo\/bar HTTP\/1.1
<span class="lineno">  249 </span>-- host: localhost
<span class="lineno">  250 </span>--
<span class="lineno">  251 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  252 </span>-- @
<span class="lineno">  253 </span>setRequestType :: MonadIO m =&gt; RequestType -&gt; RequestBuilder m ()
<span class="lineno">  254 </span><span class="decl"><span class="istickedoff">setRequestType GetRequest = do</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">rq   &lt;- rGet</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">body &lt;- liftIO $ Streams.fromList $! []</span>
<span class="lineno">  257 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">rPut $ rq { rqMethod        = GET</span>
<span class="lineno">  259 </span><span class="spaces">              </span><span class="istickedoff">, rqContentLength = Nothing</span>
<span class="lineno">  260 </span><span class="spaces">              </span><span class="istickedoff">, rqBody          = body</span>
<span class="lineno">  261 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno">  262 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  263 </span><span class="spaces"></span><span class="istickedoff">setRequestType DeleteRequest = do</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">rq   &lt;- rGet</span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">body &lt;- liftIO $ Streams.fromList $! []</span>
<span class="lineno">  266 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">rPut $ rq { rqMethod        = DELETE</span>
<span class="lineno">  268 </span><span class="spaces">              </span><span class="istickedoff">, rqContentLength = Nothing</span>
<span class="lineno">  269 </span><span class="spaces">              </span><span class="istickedoff">, rqBody          = body</span>
<span class="lineno">  270 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno">  271 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  272 </span><span class="spaces"></span><span class="istickedoff">setRequestType (RequestWithRawBody m b) = do</span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff">rq &lt;- rGet</span>
<span class="lineno">  274 </span><span class="spaces">    </span><span class="istickedoff">body &lt;- liftIO $ Streams.fromList $! [ b ]</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="istickedoff">rPut $ rq { rqMethod        = m</span>
<span class="lineno">  276 </span><span class="spaces">              </span><span class="istickedoff">, rqContentLength = Just $ fromIntegral $ S.length b</span>
<span class="lineno">  277 </span><span class="spaces">              </span><span class="istickedoff">, rqBody          = body</span>
<span class="lineno">  278 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno">  279 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  280 </span><span class="spaces"></span><span class="istickedoff">setRequestType (MultipartPostRequest fp) = encodeMultipart fp</span>
<span class="lineno">  281 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  282 </span><span class="spaces"></span><span class="istickedoff">setRequestType (UrlEncodedPostRequest fp) = do</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">rq &lt;- liftM (H.setHeader &quot;Content-Type&quot;</span>
<span class="lineno">  284 </span><span class="spaces">                             </span><span class="istickedoff">&quot;application/x-www-form-urlencoded&quot;) rGet</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">let b = printUrlEncoded fp</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">body &lt;- liftIO $ Streams.fromList $! [b]</span>
<span class="lineno">  287 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">rPut $ rq { rqMethod        = POST</span>
<span class="lineno">  289 </span><span class="spaces">              </span><span class="istickedoff">, rqContentLength = Just $!  fromIntegral $ S.length b</span>
<span class="lineno">  290 </span><span class="spaces">              </span><span class="istickedoff">, rqBody          = body</span>
<span class="lineno">  291 </span><span class="spaces">              </span><span class="istickedoff">}</span></span>
<span class="lineno">  292 </span>
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>------------------------------------------------------------------------------
<span class="lineno">  295 </span>makeBoundary :: MonadIO m =&gt; m ByteString
<span class="lineno">  296 </span><span class="decl"><span class="istickedoff">makeBoundary = do</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="istickedoff">xs  &lt;- liftIO $ replicateM 16 randomWord8</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">let x = S.pack $ map (toEnum . fromEnum) xs</span>
<span class="lineno">  299 </span><span class="spaces">    </span><span class="istickedoff">return $ S.concat [ &quot;snap-boundary-&quot;, encode x ]</span>
<span class="lineno">  300 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  301 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">randomWord8 :: IO Word8</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">randomWord8 = liftM (\c -&gt; toEnum $ c .&amp;. 0xff) randomIO</span>
<span class="lineno">  304 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">table = V.fromList [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</span>
<span class="lineno">  306 </span><span class="spaces">                       </span><span class="istickedoff">, 'a', 'b', 'c', 'd', 'e', 'f' ]</span>
<span class="lineno">  307 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">encode = toByteString . S8.foldl' f mempty</span>
<span class="lineno">  309 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  310 </span><span class="spaces"></span><span class="istickedoff">#if MIN_VERSION_base(4,5,0)</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="istickedoff">shR = unsafeShiftR</span>
<span class="lineno">  312 </span><span class="spaces"></span><span class="istickedoff">#else</span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="istickedoff">shR = shiftR</span>
<span class="lineno">  314 </span><span class="spaces"></span><span class="istickedoff">#endif</span>
<span class="lineno">  315 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  316 </span><span class="spaces">    </span><span class="istickedoff">f m c = let low = c .&amp;. 0xf</span>
<span class="lineno">  317 </span><span class="spaces">                </span><span class="istickedoff">hi  = (c .&amp;. 0xf0) `shR` 4</span>
<span class="lineno">  318 </span><span class="spaces">                </span><span class="istickedoff">k   = \i -&gt; word8 $! toEnum $! fromEnum $!</span>
<span class="lineno">  319 </span><span class="spaces">                            </span><span class="istickedoff">V.unsafeIndex table (fromEnum i)</span>
<span class="lineno">  320 </span><span class="spaces">            </span><span class="istickedoff">in m `mappend` k hi `mappend` k low</span></span>
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>------------------------------------------------------------------------------
<span class="lineno">  324 </span>multipartHeader :: ByteString -&gt; ByteString -&gt; Builder
<span class="lineno">  325 </span><span class="decl"><span class="istickedoff">multipartHeader boundary name =</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">mconcat [ byteString boundary</span>
<span class="lineno">  327 </span><span class="spaces">            </span><span class="istickedoff">, byteString &quot;\r\ncontent-disposition: form-data&quot;</span>
<span class="lineno">  328 </span><span class="spaces">            </span><span class="istickedoff">, byteString &quot;; name=\&quot;&quot;</span>
<span class="lineno">  329 </span><span class="spaces">            </span><span class="istickedoff">, byteString name</span>
<span class="lineno">  330 </span><span class="spaces">            </span><span class="istickedoff">, byteString &quot;\&quot;\r\n&quot; ]</span></span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>------------------------------------------------------------------------------
<span class="lineno">  334 </span>-- Assume initial or preceding &quot;--&quot; just before this
<span class="lineno">  335 </span>encodeFormData :: ByteString -&gt; ByteString -&gt; [ByteString] -&gt; IO Builder
<span class="lineno">  336 </span><span class="decl"><span class="istickedoff">encodeFormData boundary name vals =</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="istickedoff">case vals of</span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="istickedoff">[]  -&gt; return mempty</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="istickedoff">[v] -&gt; return $ mconcat [ hdr</span>
<span class="lineno">  340 </span><span class="spaces">                              </span><span class="istickedoff">, cr</span>
<span class="lineno">  341 </span><span class="spaces">                              </span><span class="istickedoff">, byteString v</span>
<span class="lineno">  342 </span><span class="spaces">                              </span><span class="istickedoff">, byteString &quot;\r\n--&quot; ]</span>
<span class="lineno">  343 </span><span class="spaces">      </span><span class="istickedoff">_   -&gt; multi</span>
<span class="lineno">  344 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">hdr = multipartHeader boundary name</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="istickedoff">cr = byteString &quot;\r\n&quot;</span>
<span class="lineno">  348 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">oneVal b v = mconcat [ byteString b</span>
<span class="lineno">  350 </span><span class="spaces">                         </span><span class="istickedoff">, cr</span>
<span class="lineno">  351 </span><span class="spaces">                         </span><span class="istickedoff">, cr</span>
<span class="lineno">  352 </span><span class="spaces">                         </span><span class="istickedoff">, byteString v</span>
<span class="lineno">  353 </span><span class="spaces">                         </span><span class="istickedoff">, byteString &quot;\r\n--&quot; ]</span>
<span class="lineno">  354 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">multi = do</span>
<span class="lineno">  356 </span><span class="spaces">        </span><span class="istickedoff">b &lt;- makeBoundary</span>
<span class="lineno">  357 </span><span class="spaces">        </span><span class="istickedoff">return $ mconcat [ hdr</span>
<span class="lineno">  358 </span><span class="spaces">                         </span><span class="istickedoff">, multipartMixed b</span>
<span class="lineno">  359 </span><span class="spaces">                         </span><span class="istickedoff">, cr</span>
<span class="lineno">  360 </span><span class="spaces">                         </span><span class="istickedoff">, byteString &quot;--&quot;</span>
<span class="lineno">  361 </span><span class="spaces">                         </span><span class="istickedoff">, mconcat (map (oneVal b) vals)</span>
<span class="lineno">  362 </span><span class="spaces">                         </span><span class="istickedoff">, byteString b</span>
<span class="lineno">  363 </span><span class="spaces">                         </span><span class="istickedoff">, byteString &quot;--\r\n--&quot; ]</span></span>
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>------------------------------------------------------------------------------
<span class="lineno">  367 </span>multipartMixed :: ByteString -&gt; Builder
<span class="lineno">  368 </span><span class="decl"><span class="istickedoff">multipartMixed b = mconcat [ byteString &quot;Content-Type: multipart/mixed&quot;</span>
<span class="lineno">  369 </span><span class="spaces">                           </span><span class="istickedoff">, byteString &quot;; boundary=&quot;</span>
<span class="lineno">  370 </span><span class="spaces">                           </span><span class="istickedoff">, byteString b</span>
<span class="lineno">  371 </span><span class="spaces">                           </span><span class="istickedoff">, byteString &quot;\r\n&quot; ]</span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>------------------------------------------------------------------------------
<span class="lineno">  375 </span>encodeFiles :: ByteString -&gt; ByteString -&gt; [FileData] -&gt; IO Builder
<span class="lineno">  376 </span><span class="decl"><span class="istickedoff">encodeFiles boundary name files =</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff">case files of</span>
<span class="lineno">  378 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; return mempty</span>
<span class="lineno">  379 </span><span class="spaces">      </span><span class="istickedoff">_  -&gt; do</span>
<span class="lineno">  380 </span><span class="spaces">          </span><span class="istickedoff">b &lt;- makeBoundary</span>
<span class="lineno">  381 </span><span class="spaces">          </span><span class="istickedoff">return $ mconcat [ hdr</span>
<span class="lineno">  382 </span><span class="spaces">                           </span><span class="istickedoff">, multipartMixed b</span>
<span class="lineno">  383 </span><span class="spaces">                           </span><span class="istickedoff">, cr</span>
<span class="lineno">  384 </span><span class="spaces">                           </span><span class="istickedoff">, byteString &quot;--&quot;</span>
<span class="lineno">  385 </span><span class="spaces">                           </span><span class="istickedoff">, mconcat (map (oneVal b) files)</span>
<span class="lineno">  386 </span><span class="spaces">                           </span><span class="istickedoff">, byteString b</span>
<span class="lineno">  387 </span><span class="spaces">                           </span><span class="istickedoff">, byteString &quot;--\r\n--&quot;</span>
<span class="lineno">  388 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  389 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  390 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  391 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  392 </span><span class="spaces">    </span><span class="istickedoff">contentDisposition fn = mconcat [</span>
<span class="lineno">  393 </span><span class="spaces">                              </span><span class="istickedoff">byteString &quot;Content-Disposition: attachment&quot;</span>
<span class="lineno">  394 </span><span class="spaces">                            </span><span class="istickedoff">, byteString &quot;; filename=\&quot;&quot;</span>
<span class="lineno">  395 </span><span class="spaces">                            </span><span class="istickedoff">, byteString fn</span>
<span class="lineno">  396 </span><span class="spaces">                            </span><span class="istickedoff">, byteString &quot;\&quot;\r\n&quot;</span>
<span class="lineno">  397 </span><span class="spaces">                            </span><span class="istickedoff">]</span>
<span class="lineno">  398 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  399 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="istickedoff">contentType ct = mconcat [</span>
<span class="lineno">  401 </span><span class="spaces">                       </span><span class="istickedoff">byteString &quot;Content-Type: &quot;</span>
<span class="lineno">  402 </span><span class="spaces">                     </span><span class="istickedoff">, byteString ct</span>
<span class="lineno">  403 </span><span class="spaces">                     </span><span class="istickedoff">, cr</span>
<span class="lineno">  404 </span><span class="spaces">                     </span><span class="istickedoff">]</span>
<span class="lineno">  405 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  407 </span><span class="spaces">    </span><span class="istickedoff">oneVal b fd =</span>
<span class="lineno">  408 </span><span class="spaces">        </span><span class="istickedoff">mconcat [ byteString b</span>
<span class="lineno">  409 </span><span class="spaces">                </span><span class="istickedoff">, cr</span>
<span class="lineno">  410 </span><span class="spaces">                </span><span class="istickedoff">, contentType ct</span>
<span class="lineno">  411 </span><span class="spaces">                </span><span class="istickedoff">, contentDisposition fileName</span>
<span class="lineno">  412 </span><span class="spaces">                </span><span class="istickedoff">, byteString &quot;Content-Transfer-Encoding: binary\r\n&quot;</span>
<span class="lineno">  413 </span><span class="spaces">                </span><span class="istickedoff">, cr</span>
<span class="lineno">  414 </span><span class="spaces">                </span><span class="istickedoff">, byteString contents</span>
<span class="lineno">  415 </span><span class="spaces">                </span><span class="istickedoff">, byteString &quot;\r\n--&quot;</span>
<span class="lineno">  416 </span><span class="spaces">                </span><span class="istickedoff">]</span>
<span class="lineno">  417 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  418 </span><span class="spaces">        </span><span class="istickedoff">fileName = fdFileName fd</span>
<span class="lineno">  419 </span><span class="spaces">        </span><span class="istickedoff">ct       = fdContentType fd</span>
<span class="lineno">  420 </span><span class="spaces">        </span><span class="istickedoff">contents = fdContents fd</span>
<span class="lineno">  421 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="istickedoff">hdr = multipartHeader boundary name</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">cr  = byteString &quot;\r\n&quot;</span></span>
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>------------------------------------------------------------------------------
<span class="lineno">  428 </span>encodeMultipart :: MonadIO m =&gt; MultipartParams -&gt; RequestBuilder m ()
<span class="lineno">  429 </span><span class="decl"><span class="istickedoff">encodeMultipart kvps = do</span>
<span class="lineno">  430 </span><span class="spaces">    </span><span class="istickedoff">boundary &lt;- liftIO $ makeBoundary</span>
<span class="lineno">  431 </span><span class="spaces">    </span><span class="istickedoff">builders &lt;- liftIO $ mapM (handleOne boundary) kvps</span>
<span class="lineno">  432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">let b = toByteString $ mconcat (byteString &quot;--&quot; : builders)</span>
<span class="lineno">  434 </span><span class="spaces">                             </span><span class="istickedoff">`mappend` finalBoundary boundary</span>
<span class="lineno">  435 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">rq0 &lt;- rGet</span>
<span class="lineno">  437 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">body &lt;- liftIO $ Streams.fromList [b]</span>
<span class="lineno">  439 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">let rq = H.setHeader &quot;Content-Type&quot;</span>
<span class="lineno">  441 </span><span class="spaces">               </span><span class="istickedoff">(S.append &quot;multipart/form-data; boundary=&quot; boundary)</span>
<span class="lineno">  442 </span><span class="spaces">               </span><span class="istickedoff">rq0</span>
<span class="lineno">  443 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">rPut $ rq { rqMethod        = POST</span>
<span class="lineno">  445 </span><span class="spaces">              </span><span class="istickedoff">, rqContentLength = Just $ fromIntegral $ S.length b</span>
<span class="lineno">  446 </span><span class="spaces">              </span><span class="istickedoff">, rqBody          = body</span>
<span class="lineno">  447 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno">  448 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  449 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  450 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">finalBoundary b = mconcat [byteString b, byteString &quot;--\r\n&quot;]</span>
<span class="lineno">  452 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">handleOne boundary (name, mp) =</span>
<span class="lineno">  454 </span><span class="spaces">        </span><span class="istickedoff">case mp of</span>
<span class="lineno">  455 </span><span class="spaces">          </span><span class="istickedoff">(FormData vals) -&gt; encodeFormData boundary name vals</span>
<span class="lineno">  456 </span><span class="spaces">          </span><span class="istickedoff">(Files fs)      -&gt; encodeFiles boundary name fs</span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>------------------------------------------------------------------------------
<span class="lineno">  460 </span>fixupURI :: Monad m =&gt; RequestBuilder m ()
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">fixupURI = do</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">rq &lt;- rGet</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">upd rq $! S.concat [ rqContextPath rq</span>
<span class="lineno">  464 </span><span class="spaces">                       </span><span class="istickedoff">, rqPathInfo rq</span>
<span class="lineno">  465 </span><span class="spaces">                       </span><span class="istickedoff">, let q = rqQueryString rq</span>
<span class="lineno">  466 </span><span class="spaces">                         </span><span class="istickedoff">in if S.null q</span>
<span class="lineno">  467 </span><span class="spaces">                              </span><span class="istickedoff">then &quot;&quot;</span>
<span class="lineno">  468 </span><span class="spaces">                              </span><span class="istickedoff">else S.append &quot;?&quot; q</span>
<span class="lineno">  469 </span><span class="spaces">                       </span><span class="istickedoff">]</span>
<span class="lineno">  470 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">upd rq !u = let !_ = rqURI rq</span>
<span class="lineno">  472 </span><span class="spaces">                </span><span class="istickedoff">in rPut $ rq { rqURI = u }</span></span>
<span class="lineno">  473 </span>
<span class="lineno">  474 </span>
<span class="lineno">  475 </span>------------------------------------------------------------------------------
<span class="lineno">  476 </span>-- | Sets the request's query string to be the raw bytestring provided,
<span class="lineno">  477 </span>-- without any escaping or other interpretation. Most users should instead
<span class="lineno">  478 </span>-- choose the 'setQueryString' function, which takes a parameter mapping.
<span class="lineno">  479 </span>--
<span class="lineno">  480 </span>-- Example:
<span class="lineno">  481 </span>--
<span class="lineno">  482 </span>-- @
<span class="lineno">  483 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  484 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  485 </span>-- ghci&gt; 'buildRequest' $ 'get' \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; 'setQueryStringRaw' &quot;param0=baz&amp;param1=qux&quot;
<span class="lineno">  486 </span>-- GET \/foo\/bar?param0=baz&amp;param1=qux HTTP\/1.1
<span class="lineno">  487 </span>-- host: localhost
<span class="lineno">  488 </span>--
<span class="lineno">  489 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  490 </span>-- params: param0: [&quot;baz&quot;], param1: [&quot;qux&quot;]
<span class="lineno">  491 </span>-- @
<span class="lineno">  492 </span>setQueryStringRaw :: Monad m =&gt; ByteString -&gt; RequestBuilder m ()
<span class="lineno">  493 </span><span class="decl"><span class="istickedoff">setQueryStringRaw r = do</span>
<span class="lineno">  494 </span><span class="spaces">    </span><span class="istickedoff">rq &lt;- rGet</span>
<span class="lineno">  495 </span><span class="spaces">    </span><span class="istickedoff">rPut $ rq { rqQueryString = r }</span>
<span class="lineno">  496 </span><span class="spaces">    </span><span class="istickedoff">fixupURI</span></span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>------------------------------------------------------------------------------
<span class="lineno">  500 </span>-- | Escapes the given parameter mapping and sets it as the request's query
<span class="lineno">  501 </span>-- string.
<span class="lineno">  502 </span>--
<span class="lineno">  503 </span>-- Example:
<span class="lineno">  504 </span>--
<span class="lineno">  505 </span>-- @
<span class="lineno">  506 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  507 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  508 </span>-- ghci&gt; 'buildRequest' $ 'get' \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; 'setQueryString' (M.fromList [(&quot;param0&quot;, [&quot;baz&quot;]), (&quot;param1&quot;, [&quot;qux&quot;])])
<span class="lineno">  509 </span>-- GET \/foo\/bar?param0=baz&amp;param1=qux HTTP\/1.1
<span class="lineno">  510 </span>-- host: localhost
<span class="lineno">  511 </span>--
<span class="lineno">  512 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  513 </span>-- params: param0: [&quot;baz&quot;], param1: [&quot;qux&quot;]
<span class="lineno">  514 </span>-- @
<span class="lineno">  515 </span>setQueryString :: Monad m =&gt; Params -&gt; RequestBuilder m ()
<span class="lineno">  516 </span><span class="decl"><span class="istickedoff">setQueryString p = setQueryStringRaw $ printUrlEncoded p</span></span>
<span class="lineno">  517 </span>
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>------------------------------------------------------------------------------
<span class="lineno">  520 </span>-- | Sets the given header in the request being built, overwriting any header
<span class="lineno">  521 </span>-- with the same name already present.
<span class="lineno">  522 </span>--
<span class="lineno">  523 </span>-- Example:
<span class="lineno">  524 </span>--
<span class="lineno">  525 </span>-- @
<span class="lineno">  526 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  527 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  528 </span>-- ghci&gt; :{
<span class="lineno">  529 </span>-- ghci| 'buildRequest' $ do get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  530 </span>-- ghci|                   'setHeader' \&quot;Accept\&quot; &quot;text\/html&quot;
<span class="lineno">  531 </span>-- ghci|                   'setHeader' \&quot;Accept\&quot; &quot;text\/plain&quot;
<span class="lineno">  532 </span>-- ghci| :}
<span class="lineno">  533 </span>-- GET \/foo\/bar HTTP\/1.1
<span class="lineno">  534 </span>-- accept: text\/plain
<span class="lineno">  535 </span>-- host: localhost
<span class="lineno">  536 </span>--
<span class="lineno">  537 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  538 </span>-- @
<span class="lineno">  539 </span>setHeader :: (Monad m) =&gt; CI ByteString -&gt; ByteString -&gt; RequestBuilder m ()
<span class="lineno">  540 </span><span class="decl"><span class="istickedoff">setHeader k v = rModify (H.setHeader k v)</span></span>
<span class="lineno">  541 </span>
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>------------------------------------------------------------------------------
<span class="lineno">  544 </span>-- | Adds the given header to the request being built.
<span class="lineno">  545 </span>--
<span class="lineno">  546 </span>-- Example:
<span class="lineno">  547 </span>--
<span class="lineno">  548 </span>-- @
<span class="lineno">  549 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  550 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  551 </span>-- ghci&gt; :{
<span class="lineno">  552 </span>-- ghci| 'buildRequest' $ do 'get' \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  553 </span>-- ghci|                   'addHeader' \&quot;Accept\&quot; &quot;text\/html&quot;
<span class="lineno">  554 </span>-- ghci|                   'addHeader' \&quot;Accept\&quot; &quot;text\/plain&quot;
<span class="lineno">  555 </span>-- ghci| :}
<span class="lineno">  556 </span>-- GET \/foo\/bar HTTP\/1.1
<span class="lineno">  557 </span>-- accept: text\/html,text\/plain
<span class="lineno">  558 </span>-- host: localhost
<span class="lineno">  559 </span>--
<span class="lineno">  560 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  561 </span>-- @
<span class="lineno">  562 </span>addHeader :: (Monad m) =&gt; CI ByteString -&gt; ByteString -&gt; RequestBuilder m ()
<span class="lineno">  563 </span><span class="decl"><span class="istickedoff">addHeader k v = rModify (H.addHeader k v)</span></span>
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>------------------------------------------------------------------------------
<span class="lineno">  566 </span>-- | Adds the given cookies to the request being built.
<span class="lineno">  567 </span>--
<span class="lineno">  568 </span>-- Example:
<span class="lineno">  569 </span>--
<span class="lineno">  570 </span>-- @
<span class="lineno">  571 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  572 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  573 </span>-- ghci&gt; import &quot;Snap.Core&quot;
<span class="lineno">  574 </span>-- ghci&gt; let cookie = 'Snap.Core.Cookie' &quot;name&quot; &quot;value&quot; Nothing Nothing Nothing False False
<span class="lineno">  575 </span>-- ghci&gt; 'buildRequest' $ 'get' \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; 'addCookies' [cookie]
<span class="lineno">  576 </span>-- GET \/foo\/bar HTTP\/1.1
<span class="lineno">  577 </span>-- cookie: name=value
<span class="lineno">  578 </span>-- host: localhost
<span class="lineno">  579 </span>--
<span class="lineno">  580 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  581 </span>-- cookies: Cookie {cookieName = &quot;name&quot;, cookieValue = &quot;value&quot;, ...}
<span class="lineno">  582 </span>-- @
<span class="lineno">  583 </span>addCookies :: (Monad m) =&gt; [Cookie] -&gt; RequestBuilder m ()
<span class="lineno">  584 </span><span class="decl"><span class="istickedoff">addCookies cookies = do</span>
<span class="lineno">  585 </span><span class="spaces">    </span><span class="istickedoff">rModify $ \rq -&gt; rq { rqCookies = rqCookies rq ++ cookies }</span>
<span class="lineno">  586 </span><span class="spaces">    </span><span class="istickedoff">allCookies &lt;- liftM rqCookies rGet</span>
<span class="lineno">  587 </span><span class="spaces">    </span><span class="istickedoff">let cstr = map cookieToBS allCookies</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff">setHeader &quot;Cookie&quot; $ S.intercalate &quot;; &quot; cstr</span></span>
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>
<span class="lineno">  591 </span>------------------------------------------------------------------------------
<span class="lineno">  592 </span>-- | Convert 'Cookie' into 'ByteString' for output.
<span class="lineno">  593 </span>cookieToBS :: Cookie -&gt; ByteString
<span class="lineno">  594 </span><span class="decl"><span class="istickedoff">cookieToBS (Cookie k v !_ !_ !_ !_ !_) = cookie</span>
<span class="lineno">  595 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  596 </span><span class="spaces">    </span><span class="istickedoff">cookie  = S.concat [k, &quot;=&quot;, v]</span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>------------------------------------------------------------------------------
<span class="lineno">  600 </span>-- | Sets the request's @content-type@ to the given MIME type.
<span class="lineno">  601 </span>--
<span class="lineno">  602 </span>-- Example:
<span class="lineno">  603 </span>--
<span class="lineno">  604 </span>-- @
<span class="lineno">  605 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  606 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  607 </span>-- ghci&gt; 'buildRequest' $ 'put' \&quot;\/foo\/bar\&quot; &quot;text\/html&quot; &quot;some text&quot; &gt;&gt; 'setContentType' &quot;text\/plain&quot;
<span class="lineno">  608 </span>-- PUT \/foo\/bar HTTP\/1.1
<span class="lineno">  609 </span>-- content-type: text\/plain
<span class="lineno">  610 </span>-- content-length: 9
<span class="lineno">  611 </span>-- host: localhost
<span class="lineno">  612 </span>--
<span class="lineno">  613 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=9
<span class="lineno">  614 </span>-- @
<span class="lineno">  615 </span>setContentType :: Monad m =&gt; ByteString -&gt; RequestBuilder m ()
<span class="lineno">  616 </span><span class="decl"><span class="istickedoff">setContentType c = rModify (H.setHeader &quot;Content-Type&quot; c)</span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>
<span class="lineno">  619 </span>------------------------------------------------------------------------------
<span class="lineno">  620 </span>-- | Controls whether the test request being generated appears to be an https
<span class="lineno">  621 </span>-- request or not.
<span class="lineno">  622 </span>--
<span class="lineno">  623 </span>-- Example:
<span class="lineno">  624 </span>--
<span class="lineno">  625 </span>-- @
<span class="lineno">  626 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  627 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  628 </span>-- ghci&gt; 'buildRequest' $ 'delete' \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; 'setSecure' True
<span class="lineno">  629 </span>-- DELETE \/foo\/bar HTTP\/1.1
<span class="lineno">  630 </span>-- host: localhost
<span class="lineno">  631 </span>--
<span class="lineno">  632 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a secure
<span class="lineno">  633 </span>-- @
<span class="lineno">  634 </span>setSecure :: Monad m =&gt; Bool -&gt; RequestBuilder m ()
<span class="lineno">  635 </span><span class="decl"><span class="istickedoff">setSecure b = rModify $ \rq -&gt; rq { rqIsSecure = b }</span></span>
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>
<span class="lineno">  638 </span>------------------------------------------------------------------------------
<span class="lineno">  639 </span>-- | Sets the test request's http version
<span class="lineno">  640 </span>--
<span class="lineno">  641 </span>-- Example:
<span class="lineno">  642 </span>--
<span class="lineno">  643 </span>-- @
<span class="lineno">  644 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  645 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  646 </span>-- ghci&gt; 'buildRequest' $ 'delete' \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; 'setHttpVersion' (1,0)
<span class="lineno">  647 </span>-- DELETE \/foo\/bar HTTP\/1.0
<span class="lineno">  648 </span>-- host: localhost
<span class="lineno">  649 </span>--
<span class="lineno">  650 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  651 </span>-- @
<span class="lineno">  652 </span>setHttpVersion :: Monad m =&gt; (Int,Int) -&gt; RequestBuilder m ()
<span class="lineno">  653 </span><span class="decl"><span class="istickedoff">setHttpVersion v = rModify $ \rq -&gt; rq { rqVersion = v }</span></span>
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>------------------------------------------------------------------------------
<span class="lineno">  657 </span>-- | Sets the request's path. The path provided must begin with a \&quot;@/@\&quot; and
<span class="lineno">  658 </span>-- must /not/ contain a query string; if you want to provide a query string
<span class="lineno">  659 </span>-- in your test request, you must use 'setQueryString' or 'setQueryStringRaw'.
<span class="lineno">  660 </span>-- Note that 'rqContextPath' is never set by any 'RequestBuilder' function.
<span class="lineno">  661 </span>--
<span class="lineno">  662 </span>-- Example:
<span class="lineno">  663 </span>--
<span class="lineno">  664 </span>-- @
<span class="lineno">  665 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  666 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  667 </span>-- ghci&gt; 'buildRequest' $ 'get' \&quot;\/foo\/bar\&quot; M.empty &gt;&gt; 'setRequestPath' &quot;\/bar\/foo&quot;
<span class="lineno">  668 </span>-- GET \/bar\/foo HTTP\/1.1
<span class="lineno">  669 </span>-- host: localhost
<span class="lineno">  670 </span>--
<span class="lineno">  671 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  672 </span>-- @
<span class="lineno">  673 </span>setRequestPath :: Monad m =&gt; ByteString -&gt; RequestBuilder m ()
<span class="lineno">  674 </span><span class="decl"><span class="istickedoff">setRequestPath p0 = do</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">rModify $ \rq -&gt; rq { rqContextPath = &quot;/&quot;</span>
<span class="lineno">  676 </span><span class="spaces">                        </span><span class="istickedoff">, rqPathInfo    = p }</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="istickedoff">fixupURI</span>
<span class="lineno">  678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  679 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  680 </span><span class="spaces">    </span><span class="istickedoff">p = if S.isPrefixOf &quot;/&quot; p0 then S.drop 1 p0 else p0</span></span>
<span class="lineno">  681 </span>
<span class="lineno">  682 </span>
<span class="lineno">  683 </span>------------------------------------------------------------------------------
<span class="lineno">  684 </span>-- | Builds an HTTP \&quot;GET\&quot; request with the given query parameters.
<span class="lineno">  685 </span>--
<span class="lineno">  686 </span>-- Example:
<span class="lineno">  687 </span>--
<span class="lineno">  688 </span>-- @
<span class="lineno">  689 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  690 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  691 </span>-- ghci&gt; 'buildRequest' $ 'get' \&quot;\/foo\/bar\&quot; (M.fromList [(&quot;param0&quot;, [&quot;baz&quot;, &quot;quux&quot;])])
<span class="lineno">  692 </span>-- GET \/foo\/bar?param0=baz&amp;param0=quux HTTP\/1.1
<span class="lineno">  693 </span>-- host: localhost
<span class="lineno">  694 </span>--
<span class="lineno">  695 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  696 </span>-- params: param0: [&quot;baz&quot;,&quot;quux&quot;]
<span class="lineno">  697 </span>-- @
<span class="lineno">  698 </span>get :: MonadIO m =&gt;
<span class="lineno">  699 </span>       ByteString               -- ^ request path
<span class="lineno">  700 </span>    -&gt; Params                   -- ^ request's form parameters
<span class="lineno">  701 </span>    -&gt; RequestBuilder m ()
<span class="lineno">  702 </span><span class="decl"><span class="istickedoff">get uri params = do</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">setRequestType GetRequest</span>
<span class="lineno">  704 </span><span class="spaces">    </span><span class="istickedoff">setQueryString params</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="istickedoff">setRequestPath uri</span></span>
<span class="lineno">  706 </span>
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>------------------------------------------------------------------------------
<span class="lineno">  709 </span>-- | Builds an HTTP \&quot;DELETE\&quot; request with the given query parameters.
<span class="lineno">  710 </span>--
<span class="lineno">  711 </span>-- Example:
<span class="lineno">  712 </span>--
<span class="lineno">  713 </span>-- @
<span class="lineno">  714 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  715 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  716 </span>-- ghci&gt; 'buildRequest' $ 'delete' \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  717 </span>-- DELETE \/foo\/bar HTTP\/1.1
<span class="lineno">  718 </span>-- host: localhost
<span class="lineno">  719 </span>--
<span class="lineno">  720 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=n\/a
<span class="lineno">  721 </span>-- @
<span class="lineno">  722 </span>delete :: MonadIO m =&gt;
<span class="lineno">  723 </span>          ByteString            -- ^ request path
<span class="lineno">  724 </span>       -&gt; Params                -- ^ request's form parameters
<span class="lineno">  725 </span>       -&gt; RequestBuilder m ()
<span class="lineno">  726 </span><span class="decl"><span class="istickedoff">delete uri params = do</span>
<span class="lineno">  727 </span><span class="spaces">    </span><span class="istickedoff">setRequestType DeleteRequest</span>
<span class="lineno">  728 </span><span class="spaces">    </span><span class="istickedoff">setQueryString params</span>
<span class="lineno">  729 </span><span class="spaces">    </span><span class="istickedoff">setRequestPath uri</span></span>
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>------------------------------------------------------------------------------
<span class="lineno">  733 </span>-- | Builds an HTTP \&quot;POST\&quot; request with the given form parameters, using the
<span class="lineno">  734 </span>-- \&quot;application/x-www-form-urlencoded\&quot; MIME type.
<span class="lineno">  735 </span>--
<span class="lineno">  736 </span>-- Example:
<span class="lineno">  737 </span>--
<span class="lineno">  738 </span>-- @
<span class="lineno">  739 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  740 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  741 </span>-- ghci&gt; 'buildRequest' $ 'postUrlEncoded' \&quot;\/foo\/bar\&quot; (M.fromList [(&quot;param0&quot;, [&quot;baz&quot;, &quot;quux&quot;])])
<span class="lineno">  742 </span>-- POST \/foo\/bar HTTP\/1.1
<span class="lineno">  743 </span>-- content-type: application\/x-www-form-urlencoded
<span class="lineno">  744 </span>-- content-length: 22
<span class="lineno">  745 </span>-- host: localhost
<span class="lineno">  746 </span>--
<span class="lineno">  747 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=22
<span class="lineno">  748 </span>-- params: param0: [&quot;baz&quot;,&quot;quux&quot;]
<span class="lineno">  749 </span>-- @
<span class="lineno">  750 </span>postUrlEncoded :: MonadIO m =&gt;
<span class="lineno">  751 </span>                  ByteString    -- ^ request path
<span class="lineno">  752 </span>               -&gt; Params        -- ^ request's form parameters
<span class="lineno">  753 </span>               -&gt; RequestBuilder m ()
<span class="lineno">  754 </span><span class="decl"><span class="istickedoff">postUrlEncoded uri params = do</span>
<span class="lineno">  755 </span><span class="spaces">    </span><span class="istickedoff">setRequestType $ UrlEncodedPostRequest params</span>
<span class="lineno">  756 </span><span class="spaces">    </span><span class="istickedoff">setRequestPath uri</span></span>
<span class="lineno">  757 </span>
<span class="lineno">  758 </span>
<span class="lineno">  759 </span>------------------------------------------------------------------------------
<span class="lineno">  760 </span>-- | Builds an HTTP \&quot;POST\&quot; request with the given form parameters, using the
<span class="lineno">  761 </span>-- \&quot;form-data/multipart\&quot; MIME type.
<span class="lineno">  762 </span>--
<span class="lineno">  763 </span>-- Example:
<span class="lineno">  764 </span>--
<span class="lineno">  765 </span>-- @
<span class="lineno">  766 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  767 </span>-- ghci&gt; 'buildRequest' $ 'postMultipart' \&quot;\/foo\/bar\&quot; [(&quot;param0&quot;, FormData [&quot;baz&quot;, &quot;quux&quot;])]
<span class="lineno">  768 </span>-- POST \/foo\/bar HTTP\/1.1
<span class="lineno">  769 </span>-- content-type: multipart\/form-data; boundary=snap-boundary-572334111ec0c05ad4812481e8585dfa
<span class="lineno">  770 </span>-- content-length: 406
<span class="lineno">  771 </span>-- host: localhost
<span class="lineno">  772 </span>--
<span class="lineno">  773 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=406
<span class="lineno">  774 </span>-- @
<span class="lineno">  775 </span>postMultipart :: MonadIO m =&gt;
<span class="lineno">  776 </span>                 ByteString        -- ^ request path
<span class="lineno">  777 </span>              -&gt; MultipartParams   -- ^ multipart form parameters
<span class="lineno">  778 </span>              -&gt; RequestBuilder m ()
<span class="lineno">  779 </span><span class="decl"><span class="istickedoff">postMultipart uri params = do</span>
<span class="lineno">  780 </span><span class="spaces">    </span><span class="istickedoff">setRequestType $ MultipartPostRequest params</span>
<span class="lineno">  781 </span><span class="spaces">    </span><span class="istickedoff">setRequestPath uri</span></span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>
<span class="lineno">  784 </span>------------------------------------------------------------------------------
<span class="lineno">  785 </span>-- | Builds an HTTP \&quot;PUT\&quot; request.
<span class="lineno">  786 </span>--
<span class="lineno">  787 </span>-- Example:
<span class="lineno">  788 </span>--
<span class="lineno">  789 </span>-- @
<span class="lineno">  790 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  791 </span>-- ghci&gt; 'buildRequest' $ 'put' \&quot;\/foo\/bar\&quot; &quot;text\/plain&quot; &quot;some text&quot;
<span class="lineno">  792 </span>-- PUT \/foo\/bar HTTP\/1.1
<span class="lineno">  793 </span>-- content-type: text/plain
<span class="lineno">  794 </span>-- content-length: 9
<span class="lineno">  795 </span>-- host: localhost
<span class="lineno">  796 </span>--
<span class="lineno">  797 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=9
<span class="lineno">  798 </span>-- @
<span class="lineno">  799 </span>put :: MonadIO m =&gt;
<span class="lineno">  800 </span>       ByteString               -- ^ request path
<span class="lineno">  801 </span>    -&gt; ByteString               -- ^ request body MIME content-type
<span class="lineno">  802 </span>    -&gt; ByteString               -- ^ request body contents
<span class="lineno">  803 </span>    -&gt; RequestBuilder m ()
<span class="lineno">  804 </span><span class="decl"><span class="istickedoff">put uri contentType putData = do</span>
<span class="lineno">  805 </span><span class="spaces">    </span><span class="istickedoff">setRequestType $ RequestWithRawBody PUT putData</span>
<span class="lineno">  806 </span><span class="spaces">    </span><span class="istickedoff">setHeader &quot;Content-Type&quot; contentType</span>
<span class="lineno">  807 </span><span class="spaces">    </span><span class="istickedoff">setRequestPath uri</span></span>
<span class="lineno">  808 </span>
<span class="lineno">  809 </span>
<span class="lineno">  810 </span>------------------------------------------------------------------------------
<span class="lineno">  811 </span>-- | Builds a \&quot;raw\&quot; HTTP \&quot;POST\&quot; request, with the given MIME type and body
<span class="lineno">  812 </span>-- contents.
<span class="lineno">  813 </span>--
<span class="lineno">  814 </span>-- Example:
<span class="lineno">  815 </span>--
<span class="lineno">  816 </span>-- @
<span class="lineno">  817 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  818 </span>-- ghci&gt; 'buildRequest' $ 'postRaw' \&quot;\/foo\/bar\&quot; &quot;text/plain&quot; &quot;some text&quot;
<span class="lineno">  819 </span>-- POST \/foo\/bar HTTP\/1.1
<span class="lineno">  820 </span>-- content-type: text\/plain
<span class="lineno">  821 </span>-- content-length: 9
<span class="lineno">  822 </span>-- host: localhost
<span class="lineno">  823 </span>--
<span class="lineno">  824 </span>-- sn=&quot;localhost&quot; c=127.0.0.1:60000 s=127.0.0.1:8080 ctx=\/ clen=9
<span class="lineno">  825 </span>-- @
<span class="lineno">  826 </span>postRaw :: MonadIO m =&gt;
<span class="lineno">  827 </span>           ByteString           -- ^ request path
<span class="lineno">  828 </span>        -&gt; ByteString           -- ^ request body MIME content-type
<span class="lineno">  829 </span>        -&gt; ByteString           -- ^ request body contents
<span class="lineno">  830 </span>        -&gt; RequestBuilder m ()
<span class="lineno">  831 </span><span class="decl"><span class="istickedoff">postRaw uri contentType postData = do</span>
<span class="lineno">  832 </span><span class="spaces">    </span><span class="istickedoff">setRequestType $ RequestWithRawBody POST postData</span>
<span class="lineno">  833 </span><span class="spaces">    </span><span class="istickedoff">setContentType contentType</span>
<span class="lineno">  834 </span><span class="spaces">    </span><span class="istickedoff">setRequestPath uri</span></span>
<span class="lineno">  835 </span>
<span class="lineno">  836 </span>
<span class="lineno">  837 </span>------------------------------------------------------------------------------
<span class="lineno">  838 </span>-- | Given a web handler in the 'Snap' monad, and a 'RequestBuilder' defining
<span class="lineno">  839 </span>-- a test request, runs the handler, producing an HTTP 'Response'.
<span class="lineno">  840 </span>--
<span class="lineno">  841 </span>-- This function will produce almost exactly the same output as running the
<span class="lineno">  842 </span>-- handler in a real server, except that chunked transfer encoding is not
<span class="lineno">  843 </span>-- applied, and the \&quot;Transfer-Encoding\&quot; header is not set (this makes it
<span class="lineno">  844 </span>-- easier to test response output).
<span class="lineno">  845 </span>--
<span class="lineno">  846 </span>-- Example:
<span class="lineno">  847 </span>--
<span class="lineno">  848 </span>-- @
<span class="lineno">  849 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  850 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  851 </span>-- ghci&gt; import &quot;Snap.Core&quot;
<span class="lineno">  852 </span>-- ghci&gt; 'runHandler' ('get' &quot;foo/bar&quot; M.empty) ('Snap.Core.writeBS' &quot;Hello, world!&quot;)
<span class="lineno">  853 </span>-- HTTP\/1.1 200 OK
<span class="lineno">  854 </span>-- server: Snap/test
<span class="lineno">  855 </span>-- date: Thu, 17 Jul 2014 21:03:23 GMT
<span class="lineno">  856 </span>--
<span class="lineno">  857 </span>-- Hello, world!
<span class="lineno">  858 </span>-- @
<span class="lineno">  859 </span>runHandler :: MonadIO m =&gt;
<span class="lineno">  860 </span>              RequestBuilder m ()   -- ^ a request builder
<span class="lineno">  861 </span>           -&gt; Snap a                -- ^ a web handler
<span class="lineno">  862 </span>           -&gt; m Response
<span class="lineno">  863 </span><span class="decl"><span class="istickedoff">runHandler = runHandlerM rs</span>
<span class="lineno">  864 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff">rs rq s = liftIO $ do</span>
<span class="lineno">  866 </span><span class="spaces">        </span><span class="istickedoff">(_,rsp) &lt;- runSnap s (\x -&gt; return $! (x `seq` ()))</span>
<span class="lineno">  867 </span><span class="spaces">                             </span><span class="istickedoff">(\f -&gt; let !_ = f 0 in return $! ())</span>
<span class="lineno">  868 </span><span class="spaces">                             </span><span class="istickedoff">rq</span>
<span class="lineno">  869 </span><span class="spaces">        </span><span class="istickedoff">fixupResponse rq rsp</span></span>
<span class="lineno">  870 </span>
<span class="lineno">  871 </span>
<span class="lineno">  872 </span>------------------------------------------------------------------------------
<span class="lineno">  873 </span>-- | Given a web handler in some arbitrary 'MonadSnap' monad, a function
<span class="lineno">  874 </span>-- specifying how to evaluate it within the context of the test monad, and a
<span class="lineno">  875 </span>-- 'RequestBuilder' defining a test request, runs the handler, producing an
<span class="lineno">  876 </span>-- HTTP 'Response'.
<span class="lineno">  877 </span>runHandlerM :: (MonadIO m, MonadSnap n) =&gt;
<span class="lineno">  878 </span>               (forall a . Request -&gt; n a -&gt; m Response)
<span class="lineno">  879 </span>            -- ^ a function defining how the 'MonadSnap' monad should be run
<span class="lineno">  880 </span>            -&gt; RequestBuilder m ()
<span class="lineno">  881 </span>            -- ^ a request builder
<span class="lineno">  882 </span>            -&gt; n b
<span class="lineno">  883 </span>            -- ^ a web handler
<span class="lineno">  884 </span>            -&gt; m Response
<span class="lineno">  885 </span><span class="decl"><span class="istickedoff">runHandlerM rSnap rBuilder snap = do</span>
<span class="lineno">  886 </span><span class="spaces">    </span><span class="istickedoff">rq  &lt;- buildRequest rBuilder</span>
<span class="lineno">  887 </span><span class="spaces">    </span><span class="istickedoff">rsp &lt;- rSnap rq snap</span>
<span class="lineno">  888 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  889 </span><span class="spaces">    </span><span class="istickedoff">-- simulate server logic</span>
<span class="lineno">  890 </span><span class="spaces">    </span><span class="istickedoff">t1  &lt;- liftIO (epochTime &gt;&gt;= formatHttpTime)</span>
<span class="lineno">  891 </span><span class="spaces">    </span><span class="istickedoff">return $ H.setHeader &quot;Date&quot; t1</span>
<span class="lineno">  892 </span><span class="spaces">           </span><span class="istickedoff">$ H.setHeader &quot;Server&quot; &quot;Snap/test&quot;</span>
<span class="lineno">  893 </span><span class="spaces">           </span><span class="istickedoff">$ if rspContentLength rsp == Nothing &amp;&amp;</span>
<span class="lineno">  894 </span><span class="spaces">                </span><span class="istickedoff">rqVersion rq &lt; (1,1)</span>
<span class="lineno">  895 </span><span class="spaces">               </span><span class="istickedoff">then H.setHeader &quot;Connection&quot; &quot;close&quot; rsp</span>
<span class="lineno">  896 </span><span class="spaces">               </span><span class="istickedoff">else rsp</span></span>
<span class="lineno">  897 </span>
<span class="lineno">  898 </span>
<span class="lineno">  899 </span>------------------------------------------------------------------------------
<span class="lineno">  900 </span>-- | Given a web handler in the 'Snap' monad, and a 'RequestBuilder' defining a
<span class="lineno">  901 </span>-- test request, runs the handler and returns the monadic value it produces.
<span class="lineno">  902 </span>--
<span class="lineno">  903 </span>-- Throws an exception if the 'Snap' handler early-terminates with
<span class="lineno">  904 </span>-- 'Snap.Core.finishWith' or 'Control.Monad.mzero'.
<span class="lineno">  905 </span>--
<span class="lineno">  906 </span>-- Example:
<span class="lineno">  907 </span>--
<span class="lineno">  908 </span>-- @
<span class="lineno">  909 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  910 </span>-- ghci&gt; import &quot;Control.Monad&quot;
<span class="lineno">  911 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  912 </span>-- ghci&gt; import &quot;Snap.Core&quot;
<span class="lineno">  913 </span>-- ghci&gt; 'evalHandler' ('get' &quot;foo/bar&quot; M.empty) ('Snap.Core.writeBS' &quot;Hello, world!&quot; &gt;&gt; return 42)
<span class="lineno">  914 </span>-- 42
<span class="lineno">  915 </span>-- ghci&gt; 'evalHandler' ('get' &quot;foo/bar&quot; M.empty) 'Control.Monad.mzero'
<span class="lineno">  916 </span>-- *** Exception: No handler for request: failure was pass
<span class="lineno">  917 </span>-- @
<span class="lineno">  918 </span>evalHandler :: MonadIO m =&gt;
<span class="lineno">  919 </span>               RequestBuilder m ()
<span class="lineno">  920 </span>            -&gt; Snap a
<span class="lineno">  921 </span>            -&gt; m a
<span class="lineno">  922 </span><span class="decl"><span class="istickedoff">evalHandler = evalHandlerM rs</span>
<span class="lineno">  923 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  924 </span><span class="spaces">    </span><span class="istickedoff">rs rq s = liftIO $ evalSnap s (const $ return $! ())</span>
<span class="lineno">  925 </span><span class="spaces">                                  </span><span class="istickedoff">(const $ return $! ())</span>
<span class="lineno">  926 </span><span class="spaces">                                  </span><span class="istickedoff">rq</span></span>
<span class="lineno">  927 </span>
<span class="lineno">  928 </span>
<span class="lineno">  929 </span>------------------------------------------------------------------------------
<span class="lineno">  930 </span>-- | Given a web handler in some arbitrary 'MonadSnap' monad, a function
<span class="lineno">  931 </span>-- specifying how to evaluate it within the context of the test monad, and a
<span class="lineno">  932 </span>-- 'RequestBuilder' defining a test request, runs the handler, returning the
<span class="lineno">  933 </span>-- monadic value it produces.
<span class="lineno">  934 </span>--
<span class="lineno">  935 </span>-- Throws an exception if the 'Snap' handler early-terminates with
<span class="lineno">  936 </span>-- 'Snap.Core.finishWith' or 'Control.Monad.mzero'.
<span class="lineno">  937 </span>evalHandlerM :: (MonadIO m, MonadSnap n) =&gt;
<span class="lineno">  938 </span>                (forall a . Request -&gt; n a -&gt; m a)  -- ^ a function defining
<span class="lineno">  939 </span>                                                    -- how the 'MonadSnap'
<span class="lineno">  940 </span>                                                    -- monad should be run
<span class="lineno">  941 </span>             -&gt; RequestBuilder m ()                 -- ^ a request builder
<span class="lineno">  942 </span>             -&gt; n b                                 -- ^ a web handler
<span class="lineno">  943 </span>             -&gt; m b
<span class="lineno">  944 </span><span class="decl"><span class="istickedoff">evalHandlerM rSnap rBuilder snap = do</span>
<span class="lineno">  945 </span><span class="spaces">    </span><span class="istickedoff">rq &lt;- buildRequest rBuilder</span>
<span class="lineno">  946 </span><span class="spaces">    </span><span class="istickedoff">rSnap rq snap</span></span>
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>
<span class="lineno">  949 </span>------------------------------------------------------------------------------
<span class="lineno">  950 </span>-- | Converts the given 'Response' to a bytestring.
<span class="lineno">  951 </span>--
<span class="lineno">  952 </span>-- Example:
<span class="lineno">  953 </span>--
<span class="lineno">  954 </span>-- @
<span class="lineno">  955 </span>-- ghci&gt; import &quot;Snap.Core&quot;
<span class="lineno">  956 </span>-- ghci&gt; 'responseToString' 'Snap.Core.emptyResponse'
<span class="lineno">  957 </span>-- \&quot;HTTP\/1.1 200 OK\\r\\n\\r\\n\&quot;
<span class="lineno">  958 </span>-- @
<span class="lineno">  959 </span>responseToString :: Response -&gt; IO ByteString
<span class="lineno">  960 </span><span class="decl"><span class="istickedoff">responseToString resp = do</span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="istickedoff">let act = rspBodyToEnum $ rspBody resp</span>
<span class="lineno">  962 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  963 </span><span class="spaces">    </span><span class="istickedoff">(listOut, grab) &lt;- Streams.listOutputStream</span>
<span class="lineno">  964 </span><span class="spaces">    </span><span class="istickedoff">void $ act listOut</span>
<span class="lineno">  965 </span><span class="spaces">    </span><span class="istickedoff">builder &lt;- liftM mconcat grab</span>
<span class="lineno">  966 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  967 </span><span class="spaces">    </span><span class="istickedoff">return $! toByteString $ fromShow resp `mappend` builder</span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>
<span class="lineno">  970 </span>------------------------------------------------------------------------------
<span class="lineno">  971 </span>-- | Converts the given 'Request' to a bytestring.
<span class="lineno">  972 </span>--
<span class="lineno">  973 </span>-- Since: 1.0.0.0
<span class="lineno">  974 </span>--
<span class="lineno">  975 </span>-- Example:
<span class="lineno">  976 </span>--
<span class="lineno">  977 </span>-- @
<span class="lineno">  978 </span>-- ghci&gt; :set -XOverloadedStrings
<span class="lineno">  979 </span>-- ghci&gt; import qualified &quot;Data.Map&quot; as M
<span class="lineno">  980 </span>-- ghci&gt; r &lt;- 'buildRequest' $ get \&quot;\/foo\/bar\&quot; M.empty
<span class="lineno">  981 </span>-- ghci&gt; 'requestToString' r
<span class="lineno">  982 </span>-- \&quot;GET \/foo\/bar HTTP\/1.1\\r\\nhost: localhost\\r\\n\\r\\n\&quot;
<span class="lineno">  983 </span>-- @
<span class="lineno">  984 </span>requestToString :: Request -&gt; IO ByteString
<span class="lineno">  985 </span><span class="decl"><span class="istickedoff">requestToString req0 = do</span>
<span class="lineno">  986 </span><span class="spaces">    </span><span class="istickedoff">(req, is) &lt;- maybeChunk</span>
<span class="lineno">  987 </span><span class="spaces">    </span><span class="istickedoff">body &lt;- liftM S.concat $ Streams.toList is</span>
<span class="lineno">  988 </span><span class="spaces">    </span><span class="istickedoff">return $! toByteString $ mconcat [ statusLine</span>
<span class="lineno">  989 </span><span class="spaces">                                     </span><span class="istickedoff">, mconcat . map oneHeader . H.toList</span>
<span class="lineno">  990 </span><span class="spaces">                                               </span><span class="istickedoff">$ rqHeaders req</span>
<span class="lineno">  991 </span><span class="spaces">                                     </span><span class="istickedoff">, crlf</span>
<span class="lineno">  992 </span><span class="spaces">                                     </span><span class="istickedoff">, byteString body</span>
<span class="lineno">  993 </span><span class="spaces">                                     </span><span class="istickedoff">]</span>
<span class="lineno">  994 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  995 </span><span class="spaces">    </span><span class="istickedoff">maybeChunk = do</span>
<span class="lineno">  996 </span><span class="spaces">        </span><span class="istickedoff">if getHeader &quot;Transfer-Encoding&quot; req0 == Just &quot;chunked&quot;</span>
<span class="lineno">  997 </span><span class="spaces">          </span><span class="istickedoff">then do</span>
<span class="lineno">  998 </span><span class="spaces">              </span><span class="istickedoff">let req = deleteHeader &quot;Content-Length&quot; $</span>
<span class="lineno">  999 </span><span class="spaces">                        </span><span class="istickedoff">req0 { rqContentLength = Nothing }</span>
<span class="lineno"> 1000 </span><span class="spaces">              </span><span class="istickedoff">is' &lt;- Streams.map chunk $ rqBody req</span>
<span class="lineno"> 1001 </span><span class="spaces">              </span><span class="istickedoff">out &lt;- eof &gt;&gt;= Streams.appendInputStream is'</span>
<span class="lineno"> 1002 </span><span class="spaces">              </span><span class="istickedoff">return (req, out)</span>
<span class="lineno"> 1003 </span><span class="spaces">          </span><span class="istickedoff">else return (req0, rqBody req0)</span>
<span class="lineno"> 1004 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 1005 </span><span class="spaces">        </span><span class="istickedoff">chunk s = S.concat [ S.pack $ printf &quot;%x\r\n&quot; (S.length s)</span>
<span class="lineno"> 1006 </span><span class="spaces">                           </span><span class="istickedoff">, s</span>
<span class="lineno"> 1007 </span><span class="spaces">                           </span><span class="istickedoff">, &quot;\r\n&quot;</span>
<span class="lineno"> 1008 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno"> 1009 </span><span class="spaces">        </span><span class="istickedoff">eof = Streams.fromList [&quot;0\r\n\r\n&quot;]</span>
<span class="lineno"> 1010 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1011 </span><span class="spaces">    </span><span class="istickedoff">(v1,v2) = rqVersion req0</span>
<span class="lineno"> 1012 </span><span class="spaces">    </span><span class="istickedoff">crlf = char8 '\r' `mappend` char8 '\n'</span>
<span class="lineno"> 1013 </span><span class="spaces">    </span><span class="istickedoff">statusLine = mconcat [ fromShow $ rqMethod req0</span>
<span class="lineno"> 1014 </span><span class="spaces">                         </span><span class="istickedoff">, char8 ' '</span>
<span class="lineno"> 1015 </span><span class="spaces">                         </span><span class="istickedoff">, byteString $ rqURI req0</span>
<span class="lineno"> 1016 </span><span class="spaces">                         </span><span class="istickedoff">, byteString &quot; HTTP/&quot;</span>
<span class="lineno"> 1017 </span><span class="spaces">                         </span><span class="istickedoff">, fromShow v1</span>
<span class="lineno"> 1018 </span><span class="spaces">                         </span><span class="istickedoff">, char8 '.'</span>
<span class="lineno"> 1019 </span><span class="spaces">                         </span><span class="istickedoff">, fromShow v2</span>
<span class="lineno"> 1020 </span><span class="spaces">                         </span><span class="istickedoff">, crlf</span>
<span class="lineno"> 1021 </span><span class="spaces">                         </span><span class="istickedoff">]</span>
<span class="lineno"> 1022 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1023 </span><span class="spaces">    </span><span class="istickedoff">oneHeader (k,v) = mconcat [ byteString $ original k</span>
<span class="lineno"> 1024 </span><span class="spaces">                              </span><span class="istickedoff">, byteString &quot;: &quot;</span>
<span class="lineno"> 1025 </span><span class="spaces">                              </span><span class="istickedoff">, byteString v</span>
<span class="lineno"> 1026 </span><span class="spaces">                              </span><span class="istickedoff">, crlf</span>
<span class="lineno"> 1027 </span><span class="spaces">                              </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1028 </span>
<span class="lineno"> 1029 </span>
<span class="lineno"> 1030 </span>------------------------------------------------------------------------------
<span class="lineno"> 1031 </span>rGet :: Monad m =&gt; RequestBuilder m Request
<span class="lineno"> 1032 </span><span class="decl"><span class="istickedoff">rGet   = RequestBuilder State.get</span></span>
<span class="lineno"> 1033 </span>
<span class="lineno"> 1034 </span>rPut :: Monad m =&gt; Request -&gt; RequestBuilder m ()
<span class="lineno"> 1035 </span><span class="decl"><span class="istickedoff">rPut s = RequestBuilder $ State.put s</span></span>
<span class="lineno"> 1036 </span>
<span class="lineno"> 1037 </span>rModify :: Monad m =&gt; (Request -&gt; Request) -&gt; RequestBuilder m ()
<span class="lineno"> 1038 </span><span class="decl"><span class="istickedoff">rModify f = RequestBuilder $ modify f</span></span>
<span class="lineno"> 1039 </span>
<span class="lineno"> 1040 </span>
<span class="lineno"> 1041 </span>------------------------------------------------------------------------------
<span class="lineno"> 1042 </span>toByteString :: Builder -&gt; ByteString
<span class="lineno"> 1043 </span><span class="decl"><span class="istickedoff">toByteString = S.concat . L.toChunks . toLazyByteString</span></span>
<span class="lineno"> 1044 </span>
<span class="lineno"> 1045 </span>
<span class="lineno"> 1046 </span>------------------------------------------------------------------------------
<span class="lineno"> 1047 </span>fromShow :: Show a =&gt; a -&gt; Builder
<span class="lineno"> 1048 </span><span class="decl"><span class="istickedoff">fromShow = stringUtf8 . show</span></span>

</pre>
</html>
